// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZooKeeper.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ZooKeeper.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* MetaRegionServer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MetaRegionServer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Master_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Master_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClusterUp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClusterUp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SplitLogTask_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SplitLogTask_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SplitLogTask_State_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SplitLogTask_RecoveryMode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* DeprecatedTableState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeprecatedTableState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DeprecatedTableState_State_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ReplicationPeer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplicationPeer_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReplicationState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplicationState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReplicationState_State_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ReplicationHLogPosition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplicationHLogPosition_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReplicationLock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplicationLock_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableLock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableLock_reflection_ = NULL;
const ::google::protobuf::Descriptor* SwitchState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SwitchState_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ZooKeeper_2eproto() {
  protobuf_AddDesc_ZooKeeper_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ZooKeeper.proto");
  GOOGLE_CHECK(file != NULL);
  MetaRegionServer_descriptor_ = file->message_type(0);
  static const int MetaRegionServer_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaRegionServer, server_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaRegionServer, rpc_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaRegionServer, state_),
  };
  MetaRegionServer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MetaRegionServer_descriptor_,
      MetaRegionServer::default_instance_,
      MetaRegionServer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaRegionServer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaRegionServer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MetaRegionServer));
  Master_descriptor_ = file->message_type(1);
  static const int Master_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Master, master_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Master, rpc_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Master, info_port_),
  };
  Master_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Master_descriptor_,
      Master::default_instance_,
      Master_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Master, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Master, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Master));
  ClusterUp_descriptor_ = file->message_type(2);
  static const int ClusterUp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterUp, start_date_),
  };
  ClusterUp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClusterUp_descriptor_,
      ClusterUp::default_instance_,
      ClusterUp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterUp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterUp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClusterUp));
  SplitLogTask_descriptor_ = file->message_type(3);
  static const int SplitLogTask_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SplitLogTask, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SplitLogTask, server_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SplitLogTask, mode_),
  };
  SplitLogTask_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SplitLogTask_descriptor_,
      SplitLogTask::default_instance_,
      SplitLogTask_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SplitLogTask, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SplitLogTask, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SplitLogTask));
  SplitLogTask_State_descriptor_ = SplitLogTask_descriptor_->enum_type(0);
  SplitLogTask_RecoveryMode_descriptor_ = SplitLogTask_descriptor_->enum_type(1);
  DeprecatedTableState_descriptor_ = file->message_type(4);
  static const int DeprecatedTableState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeprecatedTableState, state_),
  };
  DeprecatedTableState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeprecatedTableState_descriptor_,
      DeprecatedTableState::default_instance_,
      DeprecatedTableState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeprecatedTableState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeprecatedTableState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeprecatedTableState));
  DeprecatedTableState_State_descriptor_ = DeprecatedTableState_descriptor_->enum_type(0);
  ReplicationPeer_descriptor_ = file->message_type(5);
  static const int ReplicationPeer_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, clusterkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, replicationendpointimpl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, configuration_),
  };
  ReplicationPeer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplicationPeer_descriptor_,
      ReplicationPeer::default_instance_,
      ReplicationPeer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationPeer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplicationPeer));
  ReplicationState_descriptor_ = file->message_type(6);
  static const int ReplicationState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationState, state_),
  };
  ReplicationState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplicationState_descriptor_,
      ReplicationState::default_instance_,
      ReplicationState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplicationState));
  ReplicationState_State_descriptor_ = ReplicationState_descriptor_->enum_type(0);
  ReplicationHLogPosition_descriptor_ = file->message_type(7);
  static const int ReplicationHLogPosition_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationHLogPosition, position_),
  };
  ReplicationHLogPosition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplicationHLogPosition_descriptor_,
      ReplicationHLogPosition::default_instance_,
      ReplicationHLogPosition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationHLogPosition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationHLogPosition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplicationHLogPosition));
  ReplicationLock_descriptor_ = file->message_type(8);
  static const int ReplicationLock_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationLock, lock_owner_),
  };
  ReplicationLock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplicationLock_descriptor_,
      ReplicationLock::default_instance_,
      ReplicationLock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationLock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplicationLock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplicationLock));
  TableLock_descriptor_ = file->message_type(9);
  static const int TableLock_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, lock_owner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, thread_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, is_shared_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, purpose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, create_time_),
  };
  TableLock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableLock_descriptor_,
      TableLock::default_instance_,
      TableLock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableLock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableLock));
  SwitchState_descriptor_ = file->message_type(10);
  static const int SwitchState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchState, enabled_),
  };
  SwitchState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SwitchState_descriptor_,
      SwitchState::default_instance_,
      SwitchState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SwitchState));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ZooKeeper_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MetaRegionServer_descriptor_, &MetaRegionServer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Master_descriptor_, &Master::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClusterUp_descriptor_, &ClusterUp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SplitLogTask_descriptor_, &SplitLogTask::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeprecatedTableState_descriptor_, &DeprecatedTableState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplicationPeer_descriptor_, &ReplicationPeer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplicationState_descriptor_, &ReplicationState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplicationHLogPosition_descriptor_, &ReplicationHLogPosition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplicationLock_descriptor_, &ReplicationLock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableLock_descriptor_, &TableLock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SwitchState_descriptor_, &SwitchState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ZooKeeper_2eproto() {
  delete MetaRegionServer::default_instance_;
  delete MetaRegionServer_reflection_;
  delete Master::default_instance_;
  delete Master_reflection_;
  delete ClusterUp::default_instance_;
  delete ClusterUp_reflection_;
  delete SplitLogTask::default_instance_;
  delete SplitLogTask_reflection_;
  delete DeprecatedTableState::default_instance_;
  delete DeprecatedTableState_reflection_;
  delete ReplicationPeer::default_instance_;
  delete ReplicationPeer_reflection_;
  delete ReplicationState::default_instance_;
  delete ReplicationState_reflection_;
  delete ReplicationHLogPosition::default_instance_;
  delete ReplicationHLogPosition_reflection_;
  delete ReplicationLock::default_instance_;
  delete ReplicationLock_reflection_;
  delete TableLock::default_instance_;
  delete TableLock_reflection_;
  delete SwitchState::default_instance_;
  delete SwitchState_reflection_;
}

void protobuf_AddDesc_ZooKeeper_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hbase::pb::protobuf_AddDesc_HBase_2eproto();
  ::hbase::pb::protobuf_AddDesc_ClusterStatus_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017ZooKeeper.proto\022\010hbase.pb\032\013HBase.proto"
    "\032\023ClusterStatus.proto\"y\n\020MetaRegionServe"
    "r\022$\n\006server\030\001 \002(\0132\024.hbase.pb.ServerName\022"
    "\023\n\013rpc_version\030\002 \001(\r\022*\n\005state\030\003 \001(\0162\033.hb"
    "ase.pb.RegionState.State\"V\n\006Master\022$\n\006ma"
    "ster\030\001 \002(\0132\024.hbase.pb.ServerName\022\023\n\013rpc_"
    "version\030\002 \001(\r\022\021\n\tinfo_port\030\003 \001(\r\"\037\n\tClus"
    "terUp\022\022\n\nstart_date\030\001 \002(\t\"\247\002\n\014SplitLogTa"
    "sk\022+\n\005state\030\001 \002(\0162\034.hbase.pb.SplitLogTas"
    "k.State\022)\n\013server_name\030\002 \002(\0132\024.hbase.pb."
    "ServerName\022:\n\004mode\030\003 \001(\0162#.hbase.pb.Spli"
    "tLogTask.RecoveryMode:\007UNKNOWN\"C\n\005State\022"
    "\016\n\nUNASSIGNED\020\000\022\t\n\005OWNED\020\001\022\014\n\010RESIGNED\020\002"
    "\022\010\n\004DONE\020\003\022\007\n\003ERR\020\004\">\n\014RecoveryMode\022\013\n\007U"
    "NKNOWN\020\000\022\021\n\rLOG_SPLITTING\020\001\022\016\n\nLOG_REPLA"
    "Y\020\002\"\225\001\n\024DeprecatedTableState\022<\n\005state\030\001 "
    "\002(\0162$.hbase.pb.DeprecatedTableState.Stat"
    "e:\007ENABLED\"\?\n\005State\022\013\n\007ENABLED\020\000\022\014\n\010DISA"
    "BLED\020\001\022\r\n\tDISABLING\020\002\022\014\n\010ENABLING\020\003\"\237\001\n\017"
    "ReplicationPeer\022\022\n\nclusterkey\030\001 \002(\t\022\037\n\027r"
    "eplicationEndpointImpl\030\002 \001(\t\022&\n\004data\030\003 \003"
    "(\0132\030.hbase.pb.BytesBytesPair\022/\n\rconfigur"
    "ation\030\004 \003(\0132\030.hbase.pb.NameStringPair\"g\n"
    "\020ReplicationState\022/\n\005state\030\001 \002(\0162 .hbase"
    ".pb.ReplicationState.State\"\"\n\005State\022\013\n\007E"
    "NABLED\020\000\022\014\n\010DISABLED\020\001\"+\n\027ReplicationHLo"
    "gPosition\022\020\n\010position\030\001 \002(\003\"%\n\017Replicati"
    "onLock\022\022\n\nlock_owner\030\001 \002(\t\"\252\001\n\tTableLock"
    "\022\'\n\ntable_name\030\001 \001(\0132\023.hbase.pb.TableNam"
    "e\022(\n\nlock_owner\030\002 \001(\0132\024.hbase.pb.ServerN"
    "ame\022\021\n\tthread_id\030\003 \001(\003\022\021\n\tis_shared\030\004 \001("
    "\010\022\017\n\007purpose\030\005 \001(\t\022\023\n\013create_time\030\006 \001(\003\""
    "\036\n\013SwitchState\022\017\n\007enabled\030\001 \001(\010BE\n*org.a"
    "pache.hadoop.hbase.protobuf.generatedB\017Z"
    "ooKeeperProtosH\001\210\001\001\240\001\001", 1382);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ZooKeeper.proto", &protobuf_RegisterTypes);
  MetaRegionServer::default_instance_ = new MetaRegionServer();
  Master::default_instance_ = new Master();
  ClusterUp::default_instance_ = new ClusterUp();
  SplitLogTask::default_instance_ = new SplitLogTask();
  DeprecatedTableState::default_instance_ = new DeprecatedTableState();
  ReplicationPeer::default_instance_ = new ReplicationPeer();
  ReplicationState::default_instance_ = new ReplicationState();
  ReplicationHLogPosition::default_instance_ = new ReplicationHLogPosition();
  ReplicationLock::default_instance_ = new ReplicationLock();
  TableLock::default_instance_ = new TableLock();
  SwitchState::default_instance_ = new SwitchState();
  MetaRegionServer::default_instance_->InitAsDefaultInstance();
  Master::default_instance_->InitAsDefaultInstance();
  ClusterUp::default_instance_->InitAsDefaultInstance();
  SplitLogTask::default_instance_->InitAsDefaultInstance();
  DeprecatedTableState::default_instance_->InitAsDefaultInstance();
  ReplicationPeer::default_instance_->InitAsDefaultInstance();
  ReplicationState::default_instance_->InitAsDefaultInstance();
  ReplicationHLogPosition::default_instance_->InitAsDefaultInstance();
  ReplicationLock::default_instance_->InitAsDefaultInstance();
  TableLock::default_instance_->InitAsDefaultInstance();
  SwitchState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ZooKeeper_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ZooKeeper_2eproto {
  StaticDescriptorInitializer_ZooKeeper_2eproto() {
    protobuf_AddDesc_ZooKeeper_2eproto();
  }
} static_descriptor_initializer_ZooKeeper_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MetaRegionServer::kServerFieldNumber;
const int MetaRegionServer::kRpcVersionFieldNumber;
const int MetaRegionServer::kStateFieldNumber;
#endif  // !_MSC_VER

MetaRegionServer::MetaRegionServer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MetaRegionServer::InitAsDefaultInstance() {
  server_ = const_cast< ::hbase::pb::ServerName*>(&::hbase::pb::ServerName::default_instance());
}

MetaRegionServer::MetaRegionServer(const MetaRegionServer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MetaRegionServer::SharedCtor() {
  _cached_size_ = 0;
  server_ = NULL;
  rpc_version_ = 0u;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MetaRegionServer::~MetaRegionServer() {
  SharedDtor();
}

void MetaRegionServer::SharedDtor() {
  if (this != default_instance_) {
    delete server_;
  }
}

void MetaRegionServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MetaRegionServer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MetaRegionServer_descriptor_;
}

const MetaRegionServer& MetaRegionServer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

MetaRegionServer* MetaRegionServer::default_instance_ = NULL;

MetaRegionServer* MetaRegionServer::New() const {
  return new MetaRegionServer;
}

void MetaRegionServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_server()) {
      if (server_ != NULL) server_->::hbase::pb::ServerName::Clear();
    }
    rpc_version_ = 0u;
    state_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MetaRegionServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.ServerName server = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_server()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rpc_version;
        break;
      }

      // optional uint32 rpc_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rpc_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rpc_version_)));
          set_has_rpc_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // optional .hbase.pb.RegionState.State state = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::RegionState_State_IsValid(value)) {
            set_state(static_cast< ::hbase::pb::RegionState_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MetaRegionServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.ServerName server = 1;
  if (has_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->server(), output);
  }

  // optional uint32 rpc_version = 2;
  if (has_rpc_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rpc_version(), output);
  }

  // optional .hbase.pb.RegionState.State state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MetaRegionServer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.ServerName server = 1;
  if (has_server()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->server(), target);
  }

  // optional uint32 rpc_version = 2;
  if (has_rpc_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->rpc_version(), target);
  }

  // optional .hbase.pb.RegionState.State state = 3;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MetaRegionServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.ServerName server = 1;
    if (has_server()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->server());
    }

    // optional uint32 rpc_version = 2;
    if (has_rpc_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rpc_version());
    }

    // optional .hbase.pb.RegionState.State state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MetaRegionServer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MetaRegionServer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MetaRegionServer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MetaRegionServer::MergeFrom(const MetaRegionServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server()) {
      mutable_server()->::hbase::pb::ServerName::MergeFrom(from.server());
    }
    if (from.has_rpc_version()) {
      set_rpc_version(from.rpc_version());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MetaRegionServer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetaRegionServer::CopyFrom(const MetaRegionServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetaRegionServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_server()) {
    if (!this->server().IsInitialized()) return false;
  }
  return true;
}

void MetaRegionServer::Swap(MetaRegionServer* other) {
  if (other != this) {
    std::swap(server_, other->server_);
    std::swap(rpc_version_, other->rpc_version_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MetaRegionServer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MetaRegionServer_descriptor_;
  metadata.reflection = MetaRegionServer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Master::kMasterFieldNumber;
const int Master::kRpcVersionFieldNumber;
const int Master::kInfoPortFieldNumber;
#endif  // !_MSC_VER

Master::Master()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Master::InitAsDefaultInstance() {
  master_ = const_cast< ::hbase::pb::ServerName*>(&::hbase::pb::ServerName::default_instance());
}

Master::Master(const Master& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Master::SharedCtor() {
  _cached_size_ = 0;
  master_ = NULL;
  rpc_version_ = 0u;
  info_port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Master::~Master() {
  SharedDtor();
}

void Master::SharedDtor() {
  if (this != default_instance_) {
    delete master_;
  }
}

void Master::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Master::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Master_descriptor_;
}

const Master& Master::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

Master* Master::default_instance_ = NULL;

Master* Master::New() const {
  return new Master;
}

void Master::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_master()) {
      if (master_ != NULL) master_->::hbase::pb::ServerName::Clear();
    }
    rpc_version_ = 0u;
    info_port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Master::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.ServerName master = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rpc_version;
        break;
      }

      // optional uint32 rpc_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rpc_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rpc_version_)));
          set_has_rpc_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_info_port;
        break;
      }

      // optional uint32 info_port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_info_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &info_port_)));
          set_has_info_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Master::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.ServerName master = 1;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->master(), output);
  }

  // optional uint32 rpc_version = 2;
  if (has_rpc_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rpc_version(), output);
  }

  // optional uint32 info_port = 3;
  if (has_info_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->info_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Master::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.ServerName master = 1;
  if (has_master()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->master(), target);
  }

  // optional uint32 rpc_version = 2;
  if (has_rpc_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->rpc_version(), target);
  }

  // optional uint32 info_port = 3;
  if (has_info_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->info_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Master::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.ServerName master = 1;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master());
    }

    // optional uint32 rpc_version = 2;
    if (has_rpc_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rpc_version());
    }

    // optional uint32 info_port = 3;
    if (has_info_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->info_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Master::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Master* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Master*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Master::MergeFrom(const Master& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master()) {
      mutable_master()->::hbase::pb::ServerName::MergeFrom(from.master());
    }
    if (from.has_rpc_version()) {
      set_rpc_version(from.rpc_version());
    }
    if (from.has_info_port()) {
      set_info_port(from.info_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Master::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Master::CopyFrom(const Master& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Master::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_master()) {
    if (!this->master().IsInitialized()) return false;
  }
  return true;
}

void Master::Swap(Master* other) {
  if (other != this) {
    std::swap(master_, other->master_);
    std::swap(rpc_version_, other->rpc_version_);
    std::swap(info_port_, other->info_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Master::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Master_descriptor_;
  metadata.reflection = Master_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClusterUp::kStartDateFieldNumber;
#endif  // !_MSC_VER

ClusterUp::ClusterUp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClusterUp::InitAsDefaultInstance() {
}

ClusterUp::ClusterUp(const ClusterUp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClusterUp::SharedCtor() {
  _cached_size_ = 0;
  start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClusterUp::~ClusterUp() {
  SharedDtor();
}

void ClusterUp::SharedDtor() {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    delete start_date_;
  }
  if (this != default_instance_) {
  }
}

void ClusterUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClusterUp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClusterUp_descriptor_;
}

const ClusterUp& ClusterUp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

ClusterUp* ClusterUp::default_instance_ = NULL;

ClusterUp* ClusterUp::New() const {
  return new ClusterUp;
}

void ClusterUp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_start_date()) {
      if (start_date_ != &::google::protobuf::internal::kEmptyString) {
        start_date_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClusterUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string start_date = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_start_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->start_date().data(), this->start_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClusterUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string start_date = 1;
  if (has_start_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->start_date().data(), this->start_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->start_date(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClusterUp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string start_date = 1;
  if (has_start_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->start_date().data(), this->start_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->start_date(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClusterUp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string start_date = 1;
    if (has_start_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->start_date());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClusterUp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClusterUp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClusterUp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClusterUp::MergeFrom(const ClusterUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_date()) {
      set_start_date(from.start_date());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClusterUp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClusterUp::CopyFrom(const ClusterUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterUp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClusterUp::Swap(ClusterUp* other) {
  if (other != this) {
    std::swap(start_date_, other->start_date_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClusterUp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClusterUp_descriptor_;
  metadata.reflection = ClusterUp_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SplitLogTask_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SplitLogTask_State_descriptor_;
}
bool SplitLogTask_State_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SplitLogTask_State SplitLogTask::UNASSIGNED;
const SplitLogTask_State SplitLogTask::OWNED;
const SplitLogTask_State SplitLogTask::RESIGNED;
const SplitLogTask_State SplitLogTask::DONE;
const SplitLogTask_State SplitLogTask::ERR;
const SplitLogTask_State SplitLogTask::State_MIN;
const SplitLogTask_State SplitLogTask::State_MAX;
const int SplitLogTask::State_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* SplitLogTask_RecoveryMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SplitLogTask_RecoveryMode_descriptor_;
}
bool SplitLogTask_RecoveryMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SplitLogTask_RecoveryMode SplitLogTask::UNKNOWN;
const SplitLogTask_RecoveryMode SplitLogTask::LOG_SPLITTING;
const SplitLogTask_RecoveryMode SplitLogTask::LOG_REPLAY;
const SplitLogTask_RecoveryMode SplitLogTask::RecoveryMode_MIN;
const SplitLogTask_RecoveryMode SplitLogTask::RecoveryMode_MAX;
const int SplitLogTask::RecoveryMode_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SplitLogTask::kStateFieldNumber;
const int SplitLogTask::kServerNameFieldNumber;
const int SplitLogTask::kModeFieldNumber;
#endif  // !_MSC_VER

SplitLogTask::SplitLogTask()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SplitLogTask::InitAsDefaultInstance() {
  server_name_ = const_cast< ::hbase::pb::ServerName*>(&::hbase::pb::ServerName::default_instance());
}

SplitLogTask::SplitLogTask(const SplitLogTask& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SplitLogTask::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  server_name_ = NULL;
  mode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SplitLogTask::~SplitLogTask() {
  SharedDtor();
}

void SplitLogTask::SharedDtor() {
  if (this != default_instance_) {
    delete server_name_;
  }
}

void SplitLogTask::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SplitLogTask::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SplitLogTask_descriptor_;
}

const SplitLogTask& SplitLogTask::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

SplitLogTask* SplitLogTask::default_instance_ = NULL;

SplitLogTask* SplitLogTask::New() const {
  return new SplitLogTask;
}

void SplitLogTask::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
    if (has_server_name()) {
      if (server_name_ != NULL) server_name_->::hbase::pb::ServerName::Clear();
    }
    mode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SplitLogTask::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.SplitLogTask.State state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::SplitLogTask_State_IsValid(value)) {
            set_state(static_cast< ::hbase::pb::SplitLogTask_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_server_name;
        break;
      }

      // required .hbase.pb.ServerName server_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_server_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mode;
        break;
      }

      // optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::SplitLogTask_RecoveryMode_IsValid(value)) {
            set_mode(static_cast< ::hbase::pb::SplitLogTask_RecoveryMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SplitLogTask::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.SplitLogTask.State state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // required .hbase.pb.ServerName server_name = 2;
  if (has_server_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->server_name(), output);
  }

  // optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->mode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SplitLogTask::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.SplitLogTask.State state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // required .hbase.pb.ServerName server_name = 2;
  if (has_server_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->server_name(), target);
  }

  // optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->mode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SplitLogTask::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.SplitLogTask.State state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required .hbase.pb.ServerName server_name = 2;
    if (has_server_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->server_name());
    }

    // optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SplitLogTask::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SplitLogTask* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SplitLogTask*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SplitLogTask::MergeFrom(const SplitLogTask& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_server_name()) {
      mutable_server_name()->::hbase::pb::ServerName::MergeFrom(from.server_name());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SplitLogTask::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SplitLogTask::CopyFrom(const SplitLogTask& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SplitLogTask::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_server_name()) {
    if (!this->server_name().IsInitialized()) return false;
  }
  return true;
}

void SplitLogTask::Swap(SplitLogTask* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(server_name_, other->server_name_);
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SplitLogTask::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SplitLogTask_descriptor_;
  metadata.reflection = SplitLogTask_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DeprecatedTableState_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeprecatedTableState_State_descriptor_;
}
bool DeprecatedTableState_State_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DeprecatedTableState_State DeprecatedTableState::ENABLED;
const DeprecatedTableState_State DeprecatedTableState::DISABLED;
const DeprecatedTableState_State DeprecatedTableState::DISABLING;
const DeprecatedTableState_State DeprecatedTableState::ENABLING;
const DeprecatedTableState_State DeprecatedTableState::State_MIN;
const DeprecatedTableState_State DeprecatedTableState::State_MAX;
const int DeprecatedTableState::State_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DeprecatedTableState::kStateFieldNumber;
#endif  // !_MSC_VER

DeprecatedTableState::DeprecatedTableState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DeprecatedTableState::InitAsDefaultInstance() {
}

DeprecatedTableState::DeprecatedTableState(const DeprecatedTableState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DeprecatedTableState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeprecatedTableState::~DeprecatedTableState() {
  SharedDtor();
}

void DeprecatedTableState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeprecatedTableState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeprecatedTableState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeprecatedTableState_descriptor_;
}

const DeprecatedTableState& DeprecatedTableState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

DeprecatedTableState* DeprecatedTableState::default_instance_ = NULL;

DeprecatedTableState* DeprecatedTableState::New() const {
  return new DeprecatedTableState;
}

void DeprecatedTableState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeprecatedTableState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::DeprecatedTableState_State_IsValid(value)) {
            set_state(static_cast< ::hbase::pb::DeprecatedTableState_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeprecatedTableState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DeprecatedTableState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DeprecatedTableState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeprecatedTableState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeprecatedTableState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeprecatedTableState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeprecatedTableState::MergeFrom(const DeprecatedTableState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeprecatedTableState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeprecatedTableState::CopyFrom(const DeprecatedTableState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeprecatedTableState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DeprecatedTableState::Swap(DeprecatedTableState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeprecatedTableState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeprecatedTableState_descriptor_;
  metadata.reflection = DeprecatedTableState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReplicationPeer::kClusterkeyFieldNumber;
const int ReplicationPeer::kReplicationEndpointImplFieldNumber;
const int ReplicationPeer::kDataFieldNumber;
const int ReplicationPeer::kConfigurationFieldNumber;
#endif  // !_MSC_VER

ReplicationPeer::ReplicationPeer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplicationPeer::InitAsDefaultInstance() {
}

ReplicationPeer::ReplicationPeer(const ReplicationPeer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplicationPeer::SharedCtor() {
  _cached_size_ = 0;
  clusterkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  replicationendpointimpl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplicationPeer::~ReplicationPeer() {
  SharedDtor();
}

void ReplicationPeer::SharedDtor() {
  if (clusterkey_ != &::google::protobuf::internal::kEmptyString) {
    delete clusterkey_;
  }
  if (replicationendpointimpl_ != &::google::protobuf::internal::kEmptyString) {
    delete replicationendpointimpl_;
  }
  if (this != default_instance_) {
  }
}

void ReplicationPeer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplicationPeer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicationPeer_descriptor_;
}

const ReplicationPeer& ReplicationPeer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

ReplicationPeer* ReplicationPeer::default_instance_ = NULL;

ReplicationPeer* ReplicationPeer::New() const {
  return new ReplicationPeer;
}

void ReplicationPeer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_clusterkey()) {
      if (clusterkey_ != &::google::protobuf::internal::kEmptyString) {
        clusterkey_->clear();
      }
    }
    if (has_replicationendpointimpl()) {
      if (replicationendpointimpl_ != &::google::protobuf::internal::kEmptyString) {
        replicationendpointimpl_->clear();
      }
    }
  }
  data_.Clear();
  configuration_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplicationPeer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string clusterkey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clusterkey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clusterkey().data(), this->clusterkey().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_replicationEndpointImpl;
        break;
      }

      // optional string replicationEndpointImpl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_replicationEndpointImpl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_replicationendpointimpl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->replicationendpointimpl().data(), this->replicationendpointimpl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // repeated .hbase.pb.BytesBytesPair data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        if (input->ExpectTag(34)) goto parse_configuration;
        break;
      }

      // repeated .hbase.pb.NameStringPair configuration = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_configuration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_configuration()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_configuration;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplicationPeer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string clusterkey = 1;
  if (has_clusterkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clusterkey().data(), this->clusterkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->clusterkey(), output);
  }

  // optional string replicationEndpointImpl = 2;
  if (has_replicationendpointimpl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->replicationendpointimpl().data(), this->replicationendpointimpl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->replicationendpointimpl(), output);
  }

  // repeated .hbase.pb.BytesBytesPair data = 3;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->data(i), output);
  }

  // repeated .hbase.pb.NameStringPair configuration = 4;
  for (int i = 0; i < this->configuration_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->configuration(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplicationPeer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string clusterkey = 1;
  if (has_clusterkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clusterkey().data(), this->clusterkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->clusterkey(), target);
  }

  // optional string replicationEndpointImpl = 2;
  if (has_replicationendpointimpl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->replicationendpointimpl().data(), this->replicationendpointimpl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->replicationendpointimpl(), target);
  }

  // repeated .hbase.pb.BytesBytesPair data = 3;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->data(i), target);
  }

  // repeated .hbase.pb.NameStringPair configuration = 4;
  for (int i = 0; i < this->configuration_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->configuration(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplicationPeer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string clusterkey = 1;
    if (has_clusterkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clusterkey());
    }

    // optional string replicationEndpointImpl = 2;
    if (has_replicationendpointimpl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->replicationendpointimpl());
    }

  }
  // repeated .hbase.pb.BytesBytesPair data = 3;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  // repeated .hbase.pb.NameStringPair configuration = 4;
  total_size += 1 * this->configuration_size();
  for (int i = 0; i < this->configuration_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->configuration(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicationPeer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplicationPeer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplicationPeer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplicationPeer::MergeFrom(const ReplicationPeer& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  configuration_.MergeFrom(from.configuration_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clusterkey()) {
      set_clusterkey(from.clusterkey());
    }
    if (from.has_replicationendpointimpl()) {
      set_replicationendpointimpl(from.replicationendpointimpl());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplicationPeer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplicationPeer::CopyFrom(const ReplicationPeer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationPeer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  for (int i = 0; i < configuration_size(); i++) {
    if (!this->configuration(i).IsInitialized()) return false;
  }
  return true;
}

void ReplicationPeer::Swap(ReplicationPeer* other) {
  if (other != this) {
    std::swap(clusterkey_, other->clusterkey_);
    std::swap(replicationendpointimpl_, other->replicationendpointimpl_);
    data_.Swap(&other->data_);
    configuration_.Swap(&other->configuration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplicationPeer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplicationPeer_descriptor_;
  metadata.reflection = ReplicationPeer_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ReplicationState_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicationState_State_descriptor_;
}
bool ReplicationState_State_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ReplicationState_State ReplicationState::ENABLED;
const ReplicationState_State ReplicationState::DISABLED;
const ReplicationState_State ReplicationState::State_MIN;
const ReplicationState_State ReplicationState::State_MAX;
const int ReplicationState::State_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ReplicationState::kStateFieldNumber;
#endif  // !_MSC_VER

ReplicationState::ReplicationState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplicationState::InitAsDefaultInstance() {
}

ReplicationState::ReplicationState(const ReplicationState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplicationState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplicationState::~ReplicationState() {
  SharedDtor();
}

void ReplicationState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReplicationState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplicationState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicationState_descriptor_;
}

const ReplicationState& ReplicationState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

ReplicationState* ReplicationState::default_instance_ = NULL;

ReplicationState* ReplicationState::New() const {
  return new ReplicationState;
}

void ReplicationState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplicationState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.ReplicationState.State state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::ReplicationState_State_IsValid(value)) {
            set_state(static_cast< ::hbase::pb::ReplicationState_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplicationState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.ReplicationState.State state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplicationState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.ReplicationState.State state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplicationState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.ReplicationState.State state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicationState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplicationState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplicationState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplicationState::MergeFrom(const ReplicationState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplicationState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplicationState::CopyFrom(const ReplicationState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReplicationState::Swap(ReplicationState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplicationState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplicationState_descriptor_;
  metadata.reflection = ReplicationState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReplicationHLogPosition::kPositionFieldNumber;
#endif  // !_MSC_VER

ReplicationHLogPosition::ReplicationHLogPosition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplicationHLogPosition::InitAsDefaultInstance() {
}

ReplicationHLogPosition::ReplicationHLogPosition(const ReplicationHLogPosition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplicationHLogPosition::SharedCtor() {
  _cached_size_ = 0;
  position_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplicationHLogPosition::~ReplicationHLogPosition() {
  SharedDtor();
}

void ReplicationHLogPosition::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReplicationHLogPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplicationHLogPosition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicationHLogPosition_descriptor_;
}

const ReplicationHLogPosition& ReplicationHLogPosition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

ReplicationHLogPosition* ReplicationHLogPosition::default_instance_ = NULL;

ReplicationHLogPosition* ReplicationHLogPosition::New() const {
  return new ReplicationHLogPosition;
}

void ReplicationHLogPosition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    position_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplicationHLogPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 position = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplicationHLogPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->position(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplicationHLogPosition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->position(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplicationHLogPosition::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->position());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicationHLogPosition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplicationHLogPosition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplicationHLogPosition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplicationHLogPosition::MergeFrom(const ReplicationHLogPosition& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      set_position(from.position());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplicationHLogPosition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplicationHLogPosition::CopyFrom(const ReplicationHLogPosition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationHLogPosition::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReplicationHLogPosition::Swap(ReplicationHLogPosition* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplicationHLogPosition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplicationHLogPosition_descriptor_;
  metadata.reflection = ReplicationHLogPosition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReplicationLock::kLockOwnerFieldNumber;
#endif  // !_MSC_VER

ReplicationLock::ReplicationLock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplicationLock::InitAsDefaultInstance() {
}

ReplicationLock::ReplicationLock(const ReplicationLock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplicationLock::SharedCtor() {
  _cached_size_ = 0;
  lock_owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplicationLock::~ReplicationLock() {
  SharedDtor();
}

void ReplicationLock::SharedDtor() {
  if (lock_owner_ != &::google::protobuf::internal::kEmptyString) {
    delete lock_owner_;
  }
  if (this != default_instance_) {
  }
}

void ReplicationLock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplicationLock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicationLock_descriptor_;
}

const ReplicationLock& ReplicationLock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

ReplicationLock* ReplicationLock::default_instance_ = NULL;

ReplicationLock* ReplicationLock::New() const {
  return new ReplicationLock;
}

void ReplicationLock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_lock_owner()) {
      if (lock_owner_ != &::google::protobuf::internal::kEmptyString) {
        lock_owner_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplicationLock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string lock_owner = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lock_owner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->lock_owner().data(), this->lock_owner().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplicationLock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string lock_owner = 1;
  if (has_lock_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lock_owner().data(), this->lock_owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->lock_owner(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplicationLock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string lock_owner = 1;
  if (has_lock_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lock_owner().data(), this->lock_owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->lock_owner(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplicationLock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string lock_owner = 1;
    if (has_lock_owner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->lock_owner());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicationLock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplicationLock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplicationLock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplicationLock::MergeFrom(const ReplicationLock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lock_owner()) {
      set_lock_owner(from.lock_owner());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplicationLock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplicationLock::CopyFrom(const ReplicationLock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationLock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReplicationLock::Swap(ReplicationLock* other) {
  if (other != this) {
    std::swap(lock_owner_, other->lock_owner_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplicationLock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplicationLock_descriptor_;
  metadata.reflection = ReplicationLock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TableLock::kTableNameFieldNumber;
const int TableLock::kLockOwnerFieldNumber;
const int TableLock::kThreadIdFieldNumber;
const int TableLock::kIsSharedFieldNumber;
const int TableLock::kPurposeFieldNumber;
const int TableLock::kCreateTimeFieldNumber;
#endif  // !_MSC_VER

TableLock::TableLock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TableLock::InitAsDefaultInstance() {
  table_name_ = const_cast< ::hbase::pb::TableName*>(&::hbase::pb::TableName::default_instance());
  lock_owner_ = const_cast< ::hbase::pb::ServerName*>(&::hbase::pb::ServerName::default_instance());
}

TableLock::TableLock(const TableLock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TableLock::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  lock_owner_ = NULL;
  thread_id_ = GOOGLE_LONGLONG(0);
  is_shared_ = false;
  purpose_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  create_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableLock::~TableLock() {
  SharedDtor();
}

void TableLock::SharedDtor() {
  if (purpose_ != &::google::protobuf::internal::kEmptyString) {
    delete purpose_;
  }
  if (this != default_instance_) {
    delete table_name_;
    delete lock_owner_;
  }
}

void TableLock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableLock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableLock_descriptor_;
}

const TableLock& TableLock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

TableLock* TableLock::default_instance_ = NULL;

TableLock* TableLock::New() const {
  return new TableLock;
}

void TableLock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
    }
    if (has_lock_owner()) {
      if (lock_owner_ != NULL) lock_owner_->::hbase::pb::ServerName::Clear();
    }
    thread_id_ = GOOGLE_LONGLONG(0);
    is_shared_ = false;
    if (has_purpose()) {
      if (purpose_ != &::google::protobuf::internal::kEmptyString) {
        purpose_->clear();
      }
    }
    create_time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableLock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.TableName table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_lock_owner;
        break;
      }

      // optional .hbase.pb.ServerName lock_owner = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lock_owner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lock_owner()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_thread_id;
        break;
      }

      // optional int64 thread_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_thread_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &thread_id_)));
          set_has_thread_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_shared;
        break;
      }

      // optional bool is_shared = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_shared:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_shared_)));
          set_has_is_shared();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_purpose;
        break;
      }

      // optional string purpose = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_purpose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_purpose()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->purpose().data(), this->purpose().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_create_time;
        break;
      }

      // optional int64 create_time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TableLock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .hbase.pb.TableName table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }

  // optional .hbase.pb.ServerName lock_owner = 2;
  if (has_lock_owner()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lock_owner(), output);
  }

  // optional int64 thread_id = 3;
  if (has_thread_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->thread_id(), output);
  }

  // optional bool is_shared = 4;
  if (has_is_shared()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_shared(), output);
  }

  // optional string purpose = 5;
  if (has_purpose()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->purpose().data(), this->purpose().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->purpose(), output);
  }

  // optional int64 create_time = 6;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->create_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TableLock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .hbase.pb.TableName table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }

  // optional .hbase.pb.ServerName lock_owner = 2;
  if (has_lock_owner()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lock_owner(), target);
  }

  // optional int64 thread_id = 3;
  if (has_thread_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->thread_id(), target);
  }

  // optional bool is_shared = 4;
  if (has_is_shared()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_shared(), target);
  }

  // optional string purpose = 5;
  if (has_purpose()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->purpose().data(), this->purpose().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->purpose(), target);
  }

  // optional int64 create_time = 6;
  if (has_create_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->create_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TableLock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .hbase.pb.TableName table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }

    // optional .hbase.pb.ServerName lock_owner = 2;
    if (has_lock_owner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lock_owner());
    }

    // optional int64 thread_id = 3;
    if (has_thread_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->thread_id());
    }

    // optional bool is_shared = 4;
    if (has_is_shared()) {
      total_size += 1 + 1;
    }

    // optional string purpose = 5;
    if (has_purpose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->purpose());
    }

    // optional int64 create_time = 6;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->create_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableLock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableLock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableLock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableLock::MergeFrom(const TableLock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::hbase::pb::TableName::MergeFrom(from.table_name());
    }
    if (from.has_lock_owner()) {
      mutable_lock_owner()->::hbase::pb::ServerName::MergeFrom(from.lock_owner());
    }
    if (from.has_thread_id()) {
      set_thread_id(from.thread_id());
    }
    if (from.has_is_shared()) {
      set_is_shared(from.is_shared());
    }
    if (from.has_purpose()) {
      set_purpose(from.purpose());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableLock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableLock::CopyFrom(const TableLock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableLock::IsInitialized() const {

  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  if (has_lock_owner()) {
    if (!this->lock_owner().IsInitialized()) return false;
  }
  return true;
}

void TableLock::Swap(TableLock* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(lock_owner_, other->lock_owner_);
    std::swap(thread_id_, other->thread_id_);
    std::swap(is_shared_, other->is_shared_);
    std::swap(purpose_, other->purpose_);
    std::swap(create_time_, other->create_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableLock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableLock_descriptor_;
  metadata.reflection = TableLock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SwitchState::kEnabledFieldNumber;
#endif  // !_MSC_VER

SwitchState::SwitchState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SwitchState::InitAsDefaultInstance() {
}

SwitchState::SwitchState(const SwitchState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SwitchState::SharedCtor() {
  _cached_size_ = 0;
  enabled_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SwitchState::~SwitchState() {
  SharedDtor();
}

void SwitchState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SwitchState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SwitchState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SwitchState_descriptor_;
}

const SwitchState& SwitchState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZooKeeper_2eproto();
  return *default_instance_;
}

SwitchState* SwitchState::default_instance_ = NULL;

SwitchState* SwitchState::New() const {
  return new SwitchState;
}

void SwitchState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enabled_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SwitchState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool enabled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SwitchState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool enabled = 1;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enabled(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SwitchState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool enabled = 1;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->enabled(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SwitchState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool enabled = 1;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SwitchState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SwitchState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SwitchState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SwitchState::MergeFrom(const SwitchState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SwitchState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SwitchState::CopyFrom(const SwitchState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchState::IsInitialized() const {

  return true;
}

void SwitchState::Swap(SwitchState* other) {
  if (other != this) {
    std::swap(enabled_, other->enabled_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SwitchState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SwitchState_descriptor_;
  metadata.reflection = SwitchState_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

// @@protoc_insertion_point(global_scope)
