// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WAL.proto

#ifndef PROTOBUF_WAL_2eproto__INCLUDED
#define PROTOBUF_WAL_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Client.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_WAL_2eproto();
void protobuf_AssignDesc_WAL_2eproto();
void protobuf_ShutdownFile_WAL_2eproto();

class WALHeader;
class WALKey;
class FamilyScope;
class CompactionDescriptor;
class FlushDescriptor;
class FlushDescriptor_StoreFlushDescriptor;
class StoreDescriptor;
class BulkLoadDescriptor;
class RegionEventDescriptor;
class WALTrailer;

enum FlushDescriptor_FlushAction {
  FlushDescriptor_FlushAction_START_FLUSH = 0,
  FlushDescriptor_FlushAction_COMMIT_FLUSH = 1,
  FlushDescriptor_FlushAction_ABORT_FLUSH = 2,
  FlushDescriptor_FlushAction_CANNOT_FLUSH = 3
};
bool FlushDescriptor_FlushAction_IsValid(int value);
const FlushDescriptor_FlushAction FlushDescriptor_FlushAction_FlushAction_MIN = FlushDescriptor_FlushAction_START_FLUSH;
const FlushDescriptor_FlushAction FlushDescriptor_FlushAction_FlushAction_MAX = FlushDescriptor_FlushAction_CANNOT_FLUSH;
const int FlushDescriptor_FlushAction_FlushAction_ARRAYSIZE = FlushDescriptor_FlushAction_FlushAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* FlushDescriptor_FlushAction_descriptor();
inline const ::std::string& FlushDescriptor_FlushAction_Name(FlushDescriptor_FlushAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    FlushDescriptor_FlushAction_descriptor(), value);
}
inline bool FlushDescriptor_FlushAction_Parse(
    const ::std::string& name, FlushDescriptor_FlushAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlushDescriptor_FlushAction>(
    FlushDescriptor_FlushAction_descriptor(), name, value);
}
enum RegionEventDescriptor_EventType {
  RegionEventDescriptor_EventType_REGION_OPEN = 0,
  RegionEventDescriptor_EventType_REGION_CLOSE = 1
};
bool RegionEventDescriptor_EventType_IsValid(int value);
const RegionEventDescriptor_EventType RegionEventDescriptor_EventType_EventType_MIN = RegionEventDescriptor_EventType_REGION_OPEN;
const RegionEventDescriptor_EventType RegionEventDescriptor_EventType_EventType_MAX = RegionEventDescriptor_EventType_REGION_CLOSE;
const int RegionEventDescriptor_EventType_EventType_ARRAYSIZE = RegionEventDescriptor_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegionEventDescriptor_EventType_descriptor();
inline const ::std::string& RegionEventDescriptor_EventType_Name(RegionEventDescriptor_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegionEventDescriptor_EventType_descriptor(), value);
}
inline bool RegionEventDescriptor_EventType_Parse(
    const ::std::string& name, RegionEventDescriptor_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegionEventDescriptor_EventType>(
    RegionEventDescriptor_EventType_descriptor(), name, value);
}
enum ScopeType {
  REPLICATION_SCOPE_LOCAL = 0,
  REPLICATION_SCOPE_GLOBAL = 1
};
bool ScopeType_IsValid(int value);
const ScopeType ScopeType_MIN = REPLICATION_SCOPE_LOCAL;
const ScopeType ScopeType_MAX = REPLICATION_SCOPE_GLOBAL;
const int ScopeType_ARRAYSIZE = ScopeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScopeType_descriptor();
inline const ::std::string& ScopeType_Name(ScopeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScopeType_descriptor(), value);
}
inline bool ScopeType_Parse(
    const ::std::string& name, ScopeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScopeType>(
    ScopeType_descriptor(), name, value);
}
// ===================================================================

class WALHeader : public ::google::protobuf::Message {
 public:
  WALHeader();
  virtual ~WALHeader();

  WALHeader(const WALHeader& from);

  inline WALHeader& operator=(const WALHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WALHeader& default_instance();

  void Swap(WALHeader* other);

  // implements Message ----------------------------------------------

  WALHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WALHeader& from);
  void MergeFrom(const WALHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool has_compression = 1;
  inline bool has_has_compression() const;
  inline void clear_has_compression();
  static const int kHasCompressionFieldNumber = 1;
  inline bool has_compression() const;
  inline void set_has_compression(bool value);

  // optional bytes encryption_key = 2;
  inline bool has_encryption_key() const;
  inline void clear_encryption_key();
  static const int kEncryptionKeyFieldNumber = 2;
  inline const ::std::string& encryption_key() const;
  inline void set_encryption_key(const ::std::string& value);
  inline void set_encryption_key(const char* value);
  inline void set_encryption_key(const void* value, size_t size);
  inline ::std::string* mutable_encryption_key();
  inline ::std::string* release_encryption_key();
  inline void set_allocated_encryption_key(::std::string* encryption_key);

  // optional bool has_tag_compression = 3;
  inline bool has_has_tag_compression() const;
  inline void clear_has_tag_compression();
  static const int kHasTagCompressionFieldNumber = 3;
  inline bool has_tag_compression() const;
  inline void set_has_tag_compression(bool value);

  // optional string writer_cls_name = 4;
  inline bool has_writer_cls_name() const;
  inline void clear_writer_cls_name();
  static const int kWriterClsNameFieldNumber = 4;
  inline const ::std::string& writer_cls_name() const;
  inline void set_writer_cls_name(const ::std::string& value);
  inline void set_writer_cls_name(const char* value);
  inline void set_writer_cls_name(const char* value, size_t size);
  inline ::std::string* mutable_writer_cls_name();
  inline ::std::string* release_writer_cls_name();
  inline void set_allocated_writer_cls_name(::std::string* writer_cls_name);

  // optional string cell_codec_cls_name = 5;
  inline bool has_cell_codec_cls_name() const;
  inline void clear_cell_codec_cls_name();
  static const int kCellCodecClsNameFieldNumber = 5;
  inline const ::std::string& cell_codec_cls_name() const;
  inline void set_cell_codec_cls_name(const ::std::string& value);
  inline void set_cell_codec_cls_name(const char* value);
  inline void set_cell_codec_cls_name(const char* value, size_t size);
  inline ::std::string* mutable_cell_codec_cls_name();
  inline ::std::string* release_cell_codec_cls_name();
  inline void set_allocated_cell_codec_cls_name(::std::string* cell_codec_cls_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.WALHeader)
 private:
  inline void set_has_has_compression();
  inline void clear_has_has_compression();
  inline void set_has_encryption_key();
  inline void clear_has_encryption_key();
  inline void set_has_has_tag_compression();
  inline void clear_has_has_tag_compression();
  inline void set_has_writer_cls_name();
  inline void clear_has_writer_cls_name();
  inline void set_has_cell_codec_cls_name();
  inline void clear_has_cell_codec_cls_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encryption_key_;
  ::std::string* writer_cls_name_;
  ::std::string* cell_codec_cls_name_;
  bool has_compression_;
  bool has_tag_compression_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static WALHeader* default_instance_;
};
// -------------------------------------------------------------------

class WALKey : public ::google::protobuf::Message {
 public:
  WALKey();
  virtual ~WALKey();

  WALKey(const WALKey& from);

  inline WALKey& operator=(const WALKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WALKey& default_instance();

  void Swap(WALKey* other);

  // implements Message ----------------------------------------------

  WALKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WALKey& from);
  void MergeFrom(const WALKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encoded_region_name = 1;
  inline bool has_encoded_region_name() const;
  inline void clear_encoded_region_name();
  static const int kEncodedRegionNameFieldNumber = 1;
  inline const ::std::string& encoded_region_name() const;
  inline void set_encoded_region_name(const ::std::string& value);
  inline void set_encoded_region_name(const char* value);
  inline void set_encoded_region_name(const void* value, size_t size);
  inline ::std::string* mutable_encoded_region_name();
  inline ::std::string* release_encoded_region_name();
  inline void set_allocated_encoded_region_name(::std::string* encoded_region_name);

  // required bytes table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const void* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required uint64 log_sequence_number = 3;
  inline bool has_log_sequence_number() const;
  inline void clear_log_sequence_number();
  static const int kLogSequenceNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 log_sequence_number() const;
  inline void set_log_sequence_number(::google::protobuf::uint64 value);

  // required uint64 write_time = 4;
  inline bool has_write_time() const;
  inline void clear_write_time();
  static const int kWriteTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 write_time() const;
  inline void set_write_time(::google::protobuf::uint64 value);

  // optional .hbase.pb.UUID cluster_id = 5 [deprecated = true];
  inline bool has_cluster_id() const PROTOBUF_DEPRECATED;
  inline void clear_cluster_id() PROTOBUF_DEPRECATED;
  static const int kClusterIdFieldNumber = 5;
  inline const ::hbase::pb::UUID& cluster_id() const PROTOBUF_DEPRECATED;
  inline ::hbase::pb::UUID* mutable_cluster_id() PROTOBUF_DEPRECATED;
  inline ::hbase::pb::UUID* release_cluster_id() PROTOBUF_DEPRECATED;
  inline void set_allocated_cluster_id(::hbase::pb::UUID* cluster_id) PROTOBUF_DEPRECATED;

  // repeated .hbase.pb.FamilyScope scopes = 6;
  inline int scopes_size() const;
  inline void clear_scopes();
  static const int kScopesFieldNumber = 6;
  inline const ::hbase::pb::FamilyScope& scopes(int index) const;
  inline ::hbase::pb::FamilyScope* mutable_scopes(int index);
  inline ::hbase::pb::FamilyScope* add_scopes();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::FamilyScope >&
      scopes() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::FamilyScope >*
      mutable_scopes();

  // optional uint32 following_kv_count = 7;
  inline bool has_following_kv_count() const;
  inline void clear_following_kv_count();
  static const int kFollowingKvCountFieldNumber = 7;
  inline ::google::protobuf::uint32 following_kv_count() const;
  inline void set_following_kv_count(::google::protobuf::uint32 value);

  // repeated .hbase.pb.UUID cluster_ids = 8;
  inline int cluster_ids_size() const;
  inline void clear_cluster_ids();
  static const int kClusterIdsFieldNumber = 8;
  inline const ::hbase::pb::UUID& cluster_ids(int index) const;
  inline ::hbase::pb::UUID* mutable_cluster_ids(int index);
  inline ::hbase::pb::UUID* add_cluster_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UUID >&
      cluster_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UUID >*
      mutable_cluster_ids();

  // optional uint64 nonceGroup = 9;
  inline bool has_noncegroup() const;
  inline void clear_noncegroup();
  static const int kNonceGroupFieldNumber = 9;
  inline ::google::protobuf::uint64 noncegroup() const;
  inline void set_noncegroup(::google::protobuf::uint64 value);

  // optional uint64 nonce = 10;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 10;
  inline ::google::protobuf::uint64 nonce() const;
  inline void set_nonce(::google::protobuf::uint64 value);

  // optional uint64 orig_sequence_number = 11;
  inline bool has_orig_sequence_number() const;
  inline void clear_orig_sequence_number();
  static const int kOrigSequenceNumberFieldNumber = 11;
  inline ::google::protobuf::uint64 orig_sequence_number() const;
  inline void set_orig_sequence_number(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.WALKey)
 private:
  inline void set_has_encoded_region_name();
  inline void clear_has_encoded_region_name();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_log_sequence_number();
  inline void clear_has_log_sequence_number();
  inline void set_has_write_time();
  inline void clear_has_write_time();
  inline void set_has_cluster_id();
  inline void clear_has_cluster_id();
  inline void set_has_following_kv_count();
  inline void clear_has_following_kv_count();
  inline void set_has_noncegroup();
  inline void clear_has_noncegroup();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_orig_sequence_number();
  inline void clear_has_orig_sequence_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encoded_region_name_;
  ::std::string* table_name_;
  ::google::protobuf::uint64 log_sequence_number_;
  ::google::protobuf::uint64 write_time_;
  ::hbase::pb::UUID* cluster_id_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::FamilyScope > scopes_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::UUID > cluster_ids_;
  ::google::protobuf::uint64 noncegroup_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::uint64 orig_sequence_number_;
  ::google::protobuf::uint32 following_kv_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static WALKey* default_instance_;
};
// -------------------------------------------------------------------

class FamilyScope : public ::google::protobuf::Message {
 public:
  FamilyScope();
  virtual ~FamilyScope();

  FamilyScope(const FamilyScope& from);

  inline FamilyScope& operator=(const FamilyScope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FamilyScope& default_instance();

  void Swap(FamilyScope* other);

  // implements Message ----------------------------------------------

  FamilyScope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FamilyScope& from);
  void MergeFrom(const FamilyScope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // required .hbase.pb.ScopeType scope_type = 2;
  inline bool has_scope_type() const;
  inline void clear_scope_type();
  static const int kScopeTypeFieldNumber = 2;
  inline ::hbase::pb::ScopeType scope_type() const;
  inline void set_scope_type(::hbase::pb::ScopeType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.FamilyScope)
 private:
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_scope_type();
  inline void clear_has_scope_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_;
  int scope_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static FamilyScope* default_instance_;
};
// -------------------------------------------------------------------

class CompactionDescriptor : public ::google::protobuf::Message {
 public:
  CompactionDescriptor();
  virtual ~CompactionDescriptor();

  CompactionDescriptor(const CompactionDescriptor& from);

  inline CompactionDescriptor& operator=(const CompactionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompactionDescriptor& default_instance();

  void Swap(CompactionDescriptor* other);

  // implements Message ----------------------------------------------

  CompactionDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompactionDescriptor& from);
  void MergeFrom(const CompactionDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const void* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required bytes encoded_region_name = 2;
  inline bool has_encoded_region_name() const;
  inline void clear_encoded_region_name();
  static const int kEncodedRegionNameFieldNumber = 2;
  inline const ::std::string& encoded_region_name() const;
  inline void set_encoded_region_name(const ::std::string& value);
  inline void set_encoded_region_name(const char* value);
  inline void set_encoded_region_name(const void* value, size_t size);
  inline ::std::string* mutable_encoded_region_name();
  inline ::std::string* release_encoded_region_name();
  inline void set_allocated_encoded_region_name(::std::string* encoded_region_name);

  // required bytes family_name = 3;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 3;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const void* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // repeated string compaction_input = 4;
  inline int compaction_input_size() const;
  inline void clear_compaction_input();
  static const int kCompactionInputFieldNumber = 4;
  inline const ::std::string& compaction_input(int index) const;
  inline ::std::string* mutable_compaction_input(int index);
  inline void set_compaction_input(int index, const ::std::string& value);
  inline void set_compaction_input(int index, const char* value);
  inline void set_compaction_input(int index, const char* value, size_t size);
  inline ::std::string* add_compaction_input();
  inline void add_compaction_input(const ::std::string& value);
  inline void add_compaction_input(const char* value);
  inline void add_compaction_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& compaction_input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_compaction_input();

  // repeated string compaction_output = 5;
  inline int compaction_output_size() const;
  inline void clear_compaction_output();
  static const int kCompactionOutputFieldNumber = 5;
  inline const ::std::string& compaction_output(int index) const;
  inline ::std::string* mutable_compaction_output(int index);
  inline void set_compaction_output(int index, const ::std::string& value);
  inline void set_compaction_output(int index, const char* value);
  inline void set_compaction_output(int index, const char* value, size_t size);
  inline ::std::string* add_compaction_output();
  inline void add_compaction_output(const ::std::string& value);
  inline void add_compaction_output(const char* value);
  inline void add_compaction_output(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& compaction_output() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_compaction_output();

  // required string store_home_dir = 6;
  inline bool has_store_home_dir() const;
  inline void clear_store_home_dir();
  static const int kStoreHomeDirFieldNumber = 6;
  inline const ::std::string& store_home_dir() const;
  inline void set_store_home_dir(const ::std::string& value);
  inline void set_store_home_dir(const char* value);
  inline void set_store_home_dir(const char* value, size_t size);
  inline ::std::string* mutable_store_home_dir();
  inline ::std::string* release_store_home_dir();
  inline void set_allocated_store_home_dir(::std::string* store_home_dir);

  // optional bytes region_name = 7;
  inline bool has_region_name() const;
  inline void clear_region_name();
  static const int kRegionNameFieldNumber = 7;
  inline const ::std::string& region_name() const;
  inline void set_region_name(const ::std::string& value);
  inline void set_region_name(const char* value);
  inline void set_region_name(const void* value, size_t size);
  inline ::std::string* mutable_region_name();
  inline ::std::string* release_region_name();
  inline void set_allocated_region_name(::std::string* region_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.CompactionDescriptor)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_encoded_region_name();
  inline void clear_has_encoded_region_name();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_store_home_dir();
  inline void clear_has_store_home_dir();
  inline void set_has_region_name();
  inline void clear_has_region_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::std::string* encoded_region_name_;
  ::std::string* family_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> compaction_input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> compaction_output_;
  ::std::string* store_home_dir_;
  ::std::string* region_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static CompactionDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class FlushDescriptor_StoreFlushDescriptor : public ::google::protobuf::Message {
 public:
  FlushDescriptor_StoreFlushDescriptor();
  virtual ~FlushDescriptor_StoreFlushDescriptor();

  FlushDescriptor_StoreFlushDescriptor(const FlushDescriptor_StoreFlushDescriptor& from);

  inline FlushDescriptor_StoreFlushDescriptor& operator=(const FlushDescriptor_StoreFlushDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlushDescriptor_StoreFlushDescriptor& default_instance();

  void Swap(FlushDescriptor_StoreFlushDescriptor* other);

  // implements Message ----------------------------------------------

  FlushDescriptor_StoreFlushDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlushDescriptor_StoreFlushDescriptor& from);
  void MergeFrom(const FlushDescriptor_StoreFlushDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes family_name = 1;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 1;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const void* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // required string store_home_dir = 2;
  inline bool has_store_home_dir() const;
  inline void clear_store_home_dir();
  static const int kStoreHomeDirFieldNumber = 2;
  inline const ::std::string& store_home_dir() const;
  inline void set_store_home_dir(const ::std::string& value);
  inline void set_store_home_dir(const char* value);
  inline void set_store_home_dir(const char* value, size_t size);
  inline ::std::string* mutable_store_home_dir();
  inline ::std::string* release_store_home_dir();
  inline void set_allocated_store_home_dir(::std::string* store_home_dir);

  // repeated string flush_output = 3;
  inline int flush_output_size() const;
  inline void clear_flush_output();
  static const int kFlushOutputFieldNumber = 3;
  inline const ::std::string& flush_output(int index) const;
  inline ::std::string* mutable_flush_output(int index);
  inline void set_flush_output(int index, const ::std::string& value);
  inline void set_flush_output(int index, const char* value);
  inline void set_flush_output(int index, const char* value, size_t size);
  inline ::std::string* add_flush_output();
  inline void add_flush_output(const ::std::string& value);
  inline void add_flush_output(const char* value);
  inline void add_flush_output(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& flush_output() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_flush_output();

  // @@protoc_insertion_point(class_scope:hbase.pb.FlushDescriptor.StoreFlushDescriptor)
 private:
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_store_home_dir();
  inline void clear_has_store_home_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_name_;
  ::std::string* store_home_dir_;
  ::google::protobuf::RepeatedPtrField< ::std::string> flush_output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static FlushDescriptor_StoreFlushDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class FlushDescriptor : public ::google::protobuf::Message {
 public:
  FlushDescriptor();
  virtual ~FlushDescriptor();

  FlushDescriptor(const FlushDescriptor& from);

  inline FlushDescriptor& operator=(const FlushDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlushDescriptor& default_instance();

  void Swap(FlushDescriptor* other);

  // implements Message ----------------------------------------------

  FlushDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlushDescriptor& from);
  void MergeFrom(const FlushDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FlushDescriptor_StoreFlushDescriptor StoreFlushDescriptor;

  typedef FlushDescriptor_FlushAction FlushAction;
  static const FlushAction START_FLUSH = FlushDescriptor_FlushAction_START_FLUSH;
  static const FlushAction COMMIT_FLUSH = FlushDescriptor_FlushAction_COMMIT_FLUSH;
  static const FlushAction ABORT_FLUSH = FlushDescriptor_FlushAction_ABORT_FLUSH;
  static const FlushAction CANNOT_FLUSH = FlushDescriptor_FlushAction_CANNOT_FLUSH;
  static inline bool FlushAction_IsValid(int value) {
    return FlushDescriptor_FlushAction_IsValid(value);
  }
  static const FlushAction FlushAction_MIN =
    FlushDescriptor_FlushAction_FlushAction_MIN;
  static const FlushAction FlushAction_MAX =
    FlushDescriptor_FlushAction_FlushAction_MAX;
  static const int FlushAction_ARRAYSIZE =
    FlushDescriptor_FlushAction_FlushAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlushAction_descriptor() {
    return FlushDescriptor_FlushAction_descriptor();
  }
  static inline const ::std::string& FlushAction_Name(FlushAction value) {
    return FlushDescriptor_FlushAction_Name(value);
  }
  static inline bool FlushAction_Parse(const ::std::string& name,
      FlushAction* value) {
    return FlushDescriptor_FlushAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.FlushDescriptor.FlushAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::hbase::pb::FlushDescriptor_FlushAction action() const;
  inline void set_action(::hbase::pb::FlushDescriptor_FlushAction value);

  // required bytes table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const void* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required bytes encoded_region_name = 3;
  inline bool has_encoded_region_name() const;
  inline void clear_encoded_region_name();
  static const int kEncodedRegionNameFieldNumber = 3;
  inline const ::std::string& encoded_region_name() const;
  inline void set_encoded_region_name(const ::std::string& value);
  inline void set_encoded_region_name(const char* value);
  inline void set_encoded_region_name(const void* value, size_t size);
  inline ::std::string* mutable_encoded_region_name();
  inline ::std::string* release_encoded_region_name();
  inline void set_allocated_encoded_region_name(::std::string* encoded_region_name);

  // optional uint64 flush_sequence_number = 4;
  inline bool has_flush_sequence_number() const;
  inline void clear_flush_sequence_number();
  static const int kFlushSequenceNumberFieldNumber = 4;
  inline ::google::protobuf::uint64 flush_sequence_number() const;
  inline void set_flush_sequence_number(::google::protobuf::uint64 value);

  // repeated .hbase.pb.FlushDescriptor.StoreFlushDescriptor store_flushes = 5;
  inline int store_flushes_size() const;
  inline void clear_store_flushes();
  static const int kStoreFlushesFieldNumber = 5;
  inline const ::hbase::pb::FlushDescriptor_StoreFlushDescriptor& store_flushes(int index) const;
  inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* mutable_store_flushes(int index);
  inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* add_store_flushes();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >&
      store_flushes() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >*
      mutable_store_flushes();

  // optional bytes region_name = 6;
  inline bool has_region_name() const;
  inline void clear_region_name();
  static const int kRegionNameFieldNumber = 6;
  inline const ::std::string& region_name() const;
  inline void set_region_name(const ::std::string& value);
  inline void set_region_name(const char* value);
  inline void set_region_name(const void* value, size_t size);
  inline ::std::string* mutable_region_name();
  inline ::std::string* release_region_name();
  inline void set_allocated_region_name(::std::string* region_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.FlushDescriptor)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_encoded_region_name();
  inline void clear_has_encoded_region_name();
  inline void set_has_flush_sequence_number();
  inline void clear_has_flush_sequence_number();
  inline void set_has_region_name();
  inline void clear_has_region_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::std::string* encoded_region_name_;
  ::google::protobuf::uint64 flush_sequence_number_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor > store_flushes_;
  ::std::string* region_name_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static FlushDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class StoreDescriptor : public ::google::protobuf::Message {
 public:
  StoreDescriptor();
  virtual ~StoreDescriptor();

  StoreDescriptor(const StoreDescriptor& from);

  inline StoreDescriptor& operator=(const StoreDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreDescriptor& default_instance();

  void Swap(StoreDescriptor* other);

  // implements Message ----------------------------------------------

  StoreDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreDescriptor& from);
  void MergeFrom(const StoreDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes family_name = 1;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 1;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const void* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // required string store_home_dir = 2;
  inline bool has_store_home_dir() const;
  inline void clear_store_home_dir();
  static const int kStoreHomeDirFieldNumber = 2;
  inline const ::std::string& store_home_dir() const;
  inline void set_store_home_dir(const ::std::string& value);
  inline void set_store_home_dir(const char* value);
  inline void set_store_home_dir(const char* value, size_t size);
  inline ::std::string* mutable_store_home_dir();
  inline ::std::string* release_store_home_dir();
  inline void set_allocated_store_home_dir(::std::string* store_home_dir);

  // repeated string store_file = 3;
  inline int store_file_size() const;
  inline void clear_store_file();
  static const int kStoreFileFieldNumber = 3;
  inline const ::std::string& store_file(int index) const;
  inline ::std::string* mutable_store_file(int index);
  inline void set_store_file(int index, const ::std::string& value);
  inline void set_store_file(int index, const char* value);
  inline void set_store_file(int index, const char* value, size_t size);
  inline ::std::string* add_store_file();
  inline void add_store_file(const ::std::string& value);
  inline void add_store_file(const char* value);
  inline void add_store_file(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& store_file() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_store_file();

  // @@protoc_insertion_point(class_scope:hbase.pb.StoreDescriptor)
 private:
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_store_home_dir();
  inline void clear_has_store_home_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_name_;
  ::std::string* store_home_dir_;
  ::google::protobuf::RepeatedPtrField< ::std::string> store_file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static StoreDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class BulkLoadDescriptor : public ::google::protobuf::Message {
 public:
  BulkLoadDescriptor();
  virtual ~BulkLoadDescriptor();

  BulkLoadDescriptor(const BulkLoadDescriptor& from);

  inline BulkLoadDescriptor& operator=(const BulkLoadDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulkLoadDescriptor& default_instance();

  void Swap(BulkLoadDescriptor* other);

  // implements Message ----------------------------------------------

  BulkLoadDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulkLoadDescriptor& from);
  void MergeFrom(const BulkLoadDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.TableName table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required bytes encoded_region_name = 2;
  inline bool has_encoded_region_name() const;
  inline void clear_encoded_region_name();
  static const int kEncodedRegionNameFieldNumber = 2;
  inline const ::std::string& encoded_region_name() const;
  inline void set_encoded_region_name(const ::std::string& value);
  inline void set_encoded_region_name(const char* value);
  inline void set_encoded_region_name(const void* value, size_t size);
  inline ::std::string* mutable_encoded_region_name();
  inline ::std::string* release_encoded_region_name();
  inline void set_allocated_encoded_region_name(::std::string* encoded_region_name);

  // repeated .hbase.pb.StoreDescriptor stores = 3;
  inline int stores_size() const;
  inline void clear_stores();
  static const int kStoresFieldNumber = 3;
  inline const ::hbase::pb::StoreDescriptor& stores(int index) const;
  inline ::hbase::pb::StoreDescriptor* mutable_stores(int index);
  inline ::hbase::pb::StoreDescriptor* add_stores();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
      stores() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
      mutable_stores();

  // required int64 bulkload_seq_num = 4;
  inline bool has_bulkload_seq_num() const;
  inline void clear_bulkload_seq_num();
  static const int kBulkloadSeqNumFieldNumber = 4;
  inline ::google::protobuf::int64 bulkload_seq_num() const;
  inline void set_bulkload_seq_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadDescriptor)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_encoded_region_name();
  inline void clear_has_encoded_region_name();
  inline void set_has_bulkload_seq_num();
  inline void clear_has_bulkload_seq_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;
  ::std::string* encoded_region_name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor > stores_;
  ::google::protobuf::int64 bulkload_seq_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static BulkLoadDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class RegionEventDescriptor : public ::google::protobuf::Message {
 public:
  RegionEventDescriptor();
  virtual ~RegionEventDescriptor();

  RegionEventDescriptor(const RegionEventDescriptor& from);

  inline RegionEventDescriptor& operator=(const RegionEventDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionEventDescriptor& default_instance();

  void Swap(RegionEventDescriptor* other);

  // implements Message ----------------------------------------------

  RegionEventDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionEventDescriptor& from);
  void MergeFrom(const RegionEventDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegionEventDescriptor_EventType EventType;
  static const EventType REGION_OPEN = RegionEventDescriptor_EventType_REGION_OPEN;
  static const EventType REGION_CLOSE = RegionEventDescriptor_EventType_REGION_CLOSE;
  static inline bool EventType_IsValid(int value) {
    return RegionEventDescriptor_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    RegionEventDescriptor_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    RegionEventDescriptor_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    RegionEventDescriptor_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return RegionEventDescriptor_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return RegionEventDescriptor_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return RegionEventDescriptor_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionEventDescriptor.EventType event_type = 1;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 1;
  inline ::hbase::pb::RegionEventDescriptor_EventType event_type() const;
  inline void set_event_type(::hbase::pb::RegionEventDescriptor_EventType value);

  // required bytes table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const void* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required bytes encoded_region_name = 3;
  inline bool has_encoded_region_name() const;
  inline void clear_encoded_region_name();
  static const int kEncodedRegionNameFieldNumber = 3;
  inline const ::std::string& encoded_region_name() const;
  inline void set_encoded_region_name(const ::std::string& value);
  inline void set_encoded_region_name(const char* value);
  inline void set_encoded_region_name(const void* value, size_t size);
  inline ::std::string* mutable_encoded_region_name();
  inline ::std::string* release_encoded_region_name();
  inline void set_allocated_encoded_region_name(::std::string* encoded_region_name);

  // optional uint64 log_sequence_number = 4;
  inline bool has_log_sequence_number() const;
  inline void clear_log_sequence_number();
  static const int kLogSequenceNumberFieldNumber = 4;
  inline ::google::protobuf::uint64 log_sequence_number() const;
  inline void set_log_sequence_number(::google::protobuf::uint64 value);

  // repeated .hbase.pb.StoreDescriptor stores = 5;
  inline int stores_size() const;
  inline void clear_stores();
  static const int kStoresFieldNumber = 5;
  inline const ::hbase::pb::StoreDescriptor& stores(int index) const;
  inline ::hbase::pb::StoreDescriptor* mutable_stores(int index);
  inline ::hbase::pb::StoreDescriptor* add_stores();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
      stores() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
      mutable_stores();

  // optional .hbase.pb.ServerName server = 6;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 6;
  inline const ::hbase::pb::ServerName& server() const;
  inline ::hbase::pb::ServerName* mutable_server();
  inline ::hbase::pb::ServerName* release_server();
  inline void set_allocated_server(::hbase::pb::ServerName* server);

  // optional bytes region_name = 7;
  inline bool has_region_name() const;
  inline void clear_region_name();
  static const int kRegionNameFieldNumber = 7;
  inline const ::std::string& region_name() const;
  inline void set_region_name(const ::std::string& value);
  inline void set_region_name(const char* value);
  inline void set_region_name(const void* value, size_t size);
  inline ::std::string* mutable_region_name();
  inline ::std::string* release_region_name();
  inline void set_allocated_region_name(::std::string* region_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionEventDescriptor)
 private:
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_encoded_region_name();
  inline void clear_has_encoded_region_name();
  inline void set_has_log_sequence_number();
  inline void clear_has_log_sequence_number();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_region_name();
  inline void clear_has_region_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::std::string* encoded_region_name_;
  ::google::protobuf::uint64 log_sequence_number_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor > stores_;
  ::hbase::pb::ServerName* server_;
  ::std::string* region_name_;
  int event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static RegionEventDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class WALTrailer : public ::google::protobuf::Message {
 public:
  WALTrailer();
  virtual ~WALTrailer();

  WALTrailer(const WALTrailer& from);

  inline WALTrailer& operator=(const WALTrailer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WALTrailer& default_instance();

  void Swap(WALTrailer* other);

  // implements Message ----------------------------------------------

  WALTrailer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WALTrailer& from);
  void MergeFrom(const WALTrailer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.WALTrailer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_WAL_2eproto();
  friend void protobuf_AssignDesc_WAL_2eproto();
  friend void protobuf_ShutdownFile_WAL_2eproto();

  void InitAsDefaultInstance();
  static WALTrailer* default_instance_;
};
// ===================================================================


// ===================================================================

// WALHeader

// optional bool has_compression = 1;
inline bool WALHeader::has_has_compression() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WALHeader::set_has_has_compression() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WALHeader::clear_has_has_compression() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WALHeader::clear_has_compression() {
  has_compression_ = false;
  clear_has_has_compression();
}
inline bool WALHeader::has_compression() const {
  return has_compression_;
}
inline void WALHeader::set_has_compression(bool value) {
  set_has_has_compression();
  has_compression_ = value;
}

// optional bytes encryption_key = 2;
inline bool WALHeader::has_encryption_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WALHeader::set_has_encryption_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WALHeader::clear_has_encryption_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WALHeader::clear_encryption_key() {
  if (encryption_key_ != &::google::protobuf::internal::kEmptyString) {
    encryption_key_->clear();
  }
  clear_has_encryption_key();
}
inline const ::std::string& WALHeader::encryption_key() const {
  return *encryption_key_;
}
inline void WALHeader::set_encryption_key(const ::std::string& value) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(value);
}
inline void WALHeader::set_encryption_key(const char* value) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(value);
}
inline void WALHeader::set_encryption_key(const void* value, size_t size) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WALHeader::mutable_encryption_key() {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    encryption_key_ = new ::std::string;
  }
  return encryption_key_;
}
inline ::std::string* WALHeader::release_encryption_key() {
  clear_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryption_key_;
    encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WALHeader::set_allocated_encryption_key(::std::string* encryption_key) {
  if (encryption_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encryption_key_;
  }
  if (encryption_key) {
    set_has_encryption_key();
    encryption_key_ = encryption_key;
  } else {
    clear_has_encryption_key();
    encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_tag_compression = 3;
inline bool WALHeader::has_has_tag_compression() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WALHeader::set_has_has_tag_compression() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WALHeader::clear_has_has_tag_compression() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WALHeader::clear_has_tag_compression() {
  has_tag_compression_ = false;
  clear_has_has_tag_compression();
}
inline bool WALHeader::has_tag_compression() const {
  return has_tag_compression_;
}
inline void WALHeader::set_has_tag_compression(bool value) {
  set_has_has_tag_compression();
  has_tag_compression_ = value;
}

// optional string writer_cls_name = 4;
inline bool WALHeader::has_writer_cls_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WALHeader::set_has_writer_cls_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WALHeader::clear_has_writer_cls_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WALHeader::clear_writer_cls_name() {
  if (writer_cls_name_ != &::google::protobuf::internal::kEmptyString) {
    writer_cls_name_->clear();
  }
  clear_has_writer_cls_name();
}
inline const ::std::string& WALHeader::writer_cls_name() const {
  return *writer_cls_name_;
}
inline void WALHeader::set_writer_cls_name(const ::std::string& value) {
  set_has_writer_cls_name();
  if (writer_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    writer_cls_name_ = new ::std::string;
  }
  writer_cls_name_->assign(value);
}
inline void WALHeader::set_writer_cls_name(const char* value) {
  set_has_writer_cls_name();
  if (writer_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    writer_cls_name_ = new ::std::string;
  }
  writer_cls_name_->assign(value);
}
inline void WALHeader::set_writer_cls_name(const char* value, size_t size) {
  set_has_writer_cls_name();
  if (writer_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    writer_cls_name_ = new ::std::string;
  }
  writer_cls_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WALHeader::mutable_writer_cls_name() {
  set_has_writer_cls_name();
  if (writer_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    writer_cls_name_ = new ::std::string;
  }
  return writer_cls_name_;
}
inline ::std::string* WALHeader::release_writer_cls_name() {
  clear_has_writer_cls_name();
  if (writer_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = writer_cls_name_;
    writer_cls_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WALHeader::set_allocated_writer_cls_name(::std::string* writer_cls_name) {
  if (writer_cls_name_ != &::google::protobuf::internal::kEmptyString) {
    delete writer_cls_name_;
  }
  if (writer_cls_name) {
    set_has_writer_cls_name();
    writer_cls_name_ = writer_cls_name;
  } else {
    clear_has_writer_cls_name();
    writer_cls_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cell_codec_cls_name = 5;
inline bool WALHeader::has_cell_codec_cls_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WALHeader::set_has_cell_codec_cls_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WALHeader::clear_has_cell_codec_cls_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WALHeader::clear_cell_codec_cls_name() {
  if (cell_codec_cls_name_ != &::google::protobuf::internal::kEmptyString) {
    cell_codec_cls_name_->clear();
  }
  clear_has_cell_codec_cls_name();
}
inline const ::std::string& WALHeader::cell_codec_cls_name() const {
  return *cell_codec_cls_name_;
}
inline void WALHeader::set_cell_codec_cls_name(const ::std::string& value) {
  set_has_cell_codec_cls_name();
  if (cell_codec_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    cell_codec_cls_name_ = new ::std::string;
  }
  cell_codec_cls_name_->assign(value);
}
inline void WALHeader::set_cell_codec_cls_name(const char* value) {
  set_has_cell_codec_cls_name();
  if (cell_codec_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    cell_codec_cls_name_ = new ::std::string;
  }
  cell_codec_cls_name_->assign(value);
}
inline void WALHeader::set_cell_codec_cls_name(const char* value, size_t size) {
  set_has_cell_codec_cls_name();
  if (cell_codec_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    cell_codec_cls_name_ = new ::std::string;
  }
  cell_codec_cls_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WALHeader::mutable_cell_codec_cls_name() {
  set_has_cell_codec_cls_name();
  if (cell_codec_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    cell_codec_cls_name_ = new ::std::string;
  }
  return cell_codec_cls_name_;
}
inline ::std::string* WALHeader::release_cell_codec_cls_name() {
  clear_has_cell_codec_cls_name();
  if (cell_codec_cls_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cell_codec_cls_name_;
    cell_codec_cls_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WALHeader::set_allocated_cell_codec_cls_name(::std::string* cell_codec_cls_name) {
  if (cell_codec_cls_name_ != &::google::protobuf::internal::kEmptyString) {
    delete cell_codec_cls_name_;
  }
  if (cell_codec_cls_name) {
    set_has_cell_codec_cls_name();
    cell_codec_cls_name_ = cell_codec_cls_name;
  } else {
    clear_has_cell_codec_cls_name();
    cell_codec_cls_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WALKey

// required bytes encoded_region_name = 1;
inline bool WALKey::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WALKey::set_has_encoded_region_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WALKey::clear_has_encoded_region_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WALKey::clear_encoded_region_name() {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_->clear();
  }
  clear_has_encoded_region_name();
}
inline const ::std::string& WALKey::encoded_region_name() const {
  return *encoded_region_name_;
}
inline void WALKey::set_encoded_region_name(const ::std::string& value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void WALKey::set_encoded_region_name(const char* value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void WALKey::set_encoded_region_name(const void* value, size_t size) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WALKey::mutable_encoded_region_name() {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  return encoded_region_name_;
}
inline ::std::string* WALKey::release_encoded_region_name() {
  clear_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_region_name_;
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WALKey::set_allocated_encoded_region_name(::std::string* encoded_region_name) {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_region_name_;
  }
  if (encoded_region_name) {
    set_has_encoded_region_name();
    encoded_region_name_ = encoded_region_name;
  } else {
    clear_has_encoded_region_name();
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes table_name = 2;
inline bool WALKey::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WALKey::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WALKey::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WALKey::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& WALKey::table_name() const {
  return *table_name_;
}
inline void WALKey::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void WALKey::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void WALKey::set_table_name(const void* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WALKey::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* WALKey::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WALKey::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 log_sequence_number = 3;
inline bool WALKey::has_log_sequence_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WALKey::set_has_log_sequence_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WALKey::clear_has_log_sequence_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WALKey::clear_log_sequence_number() {
  log_sequence_number_ = GOOGLE_ULONGLONG(0);
  clear_has_log_sequence_number();
}
inline ::google::protobuf::uint64 WALKey::log_sequence_number() const {
  return log_sequence_number_;
}
inline void WALKey::set_log_sequence_number(::google::protobuf::uint64 value) {
  set_has_log_sequence_number();
  log_sequence_number_ = value;
}

// required uint64 write_time = 4;
inline bool WALKey::has_write_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WALKey::set_has_write_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WALKey::clear_has_write_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WALKey::clear_write_time() {
  write_time_ = GOOGLE_ULONGLONG(0);
  clear_has_write_time();
}
inline ::google::protobuf::uint64 WALKey::write_time() const {
  return write_time_;
}
inline void WALKey::set_write_time(::google::protobuf::uint64 value) {
  set_has_write_time();
  write_time_ = value;
}

// optional .hbase.pb.UUID cluster_id = 5 [deprecated = true];
inline bool WALKey::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WALKey::set_has_cluster_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WALKey::clear_has_cluster_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WALKey::clear_cluster_id() {
  if (cluster_id_ != NULL) cluster_id_->::hbase::pb::UUID::Clear();
  clear_has_cluster_id();
}
inline const ::hbase::pb::UUID& WALKey::cluster_id() const {
  return cluster_id_ != NULL ? *cluster_id_ : *default_instance_->cluster_id_;
}
inline ::hbase::pb::UUID* WALKey::mutable_cluster_id() {
  set_has_cluster_id();
  if (cluster_id_ == NULL) cluster_id_ = new ::hbase::pb::UUID;
  return cluster_id_;
}
inline ::hbase::pb::UUID* WALKey::release_cluster_id() {
  clear_has_cluster_id();
  ::hbase::pb::UUID* temp = cluster_id_;
  cluster_id_ = NULL;
  return temp;
}
inline void WALKey::set_allocated_cluster_id(::hbase::pb::UUID* cluster_id) {
  delete cluster_id_;
  cluster_id_ = cluster_id;
  if (cluster_id) {
    set_has_cluster_id();
  } else {
    clear_has_cluster_id();
  }
}

// repeated .hbase.pb.FamilyScope scopes = 6;
inline int WALKey::scopes_size() const {
  return scopes_.size();
}
inline void WALKey::clear_scopes() {
  scopes_.Clear();
}
inline const ::hbase::pb::FamilyScope& WALKey::scopes(int index) const {
  return scopes_.Get(index);
}
inline ::hbase::pb::FamilyScope* WALKey::mutable_scopes(int index) {
  return scopes_.Mutable(index);
}
inline ::hbase::pb::FamilyScope* WALKey::add_scopes() {
  return scopes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::FamilyScope >&
WALKey::scopes() const {
  return scopes_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::FamilyScope >*
WALKey::mutable_scopes() {
  return &scopes_;
}

// optional uint32 following_kv_count = 7;
inline bool WALKey::has_following_kv_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WALKey::set_has_following_kv_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WALKey::clear_has_following_kv_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WALKey::clear_following_kv_count() {
  following_kv_count_ = 0u;
  clear_has_following_kv_count();
}
inline ::google::protobuf::uint32 WALKey::following_kv_count() const {
  return following_kv_count_;
}
inline void WALKey::set_following_kv_count(::google::protobuf::uint32 value) {
  set_has_following_kv_count();
  following_kv_count_ = value;
}

// repeated .hbase.pb.UUID cluster_ids = 8;
inline int WALKey::cluster_ids_size() const {
  return cluster_ids_.size();
}
inline void WALKey::clear_cluster_ids() {
  cluster_ids_.Clear();
}
inline const ::hbase::pb::UUID& WALKey::cluster_ids(int index) const {
  return cluster_ids_.Get(index);
}
inline ::hbase::pb::UUID* WALKey::mutable_cluster_ids(int index) {
  return cluster_ids_.Mutable(index);
}
inline ::hbase::pb::UUID* WALKey::add_cluster_ids() {
  return cluster_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UUID >&
WALKey::cluster_ids() const {
  return cluster_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UUID >*
WALKey::mutable_cluster_ids() {
  return &cluster_ids_;
}

// optional uint64 nonceGroup = 9;
inline bool WALKey::has_noncegroup() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WALKey::set_has_noncegroup() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WALKey::clear_has_noncegroup() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WALKey::clear_noncegroup() {
  noncegroup_ = GOOGLE_ULONGLONG(0);
  clear_has_noncegroup();
}
inline ::google::protobuf::uint64 WALKey::noncegroup() const {
  return noncegroup_;
}
inline void WALKey::set_noncegroup(::google::protobuf::uint64 value) {
  set_has_noncegroup();
  noncegroup_ = value;
}

// optional uint64 nonce = 10;
inline bool WALKey::has_nonce() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WALKey::set_has_nonce() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WALKey::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WALKey::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 WALKey::nonce() const {
  return nonce_;
}
inline void WALKey::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
}

// optional uint64 orig_sequence_number = 11;
inline bool WALKey::has_orig_sequence_number() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WALKey::set_has_orig_sequence_number() {
  _has_bits_[0] |= 0x00000400u;
}
inline void WALKey::clear_has_orig_sequence_number() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void WALKey::clear_orig_sequence_number() {
  orig_sequence_number_ = GOOGLE_ULONGLONG(0);
  clear_has_orig_sequence_number();
}
inline ::google::protobuf::uint64 WALKey::orig_sequence_number() const {
  return orig_sequence_number_;
}
inline void WALKey::set_orig_sequence_number(::google::protobuf::uint64 value) {
  set_has_orig_sequence_number();
  orig_sequence_number_ = value;
}

// -------------------------------------------------------------------

// FamilyScope

// required bytes family = 1;
inline bool FamilyScope::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FamilyScope::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FamilyScope::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FamilyScope::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& FamilyScope::family() const {
  return *family_;
}
inline void FamilyScope::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void FamilyScope::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void FamilyScope::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FamilyScope::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* FamilyScope::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FamilyScope::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hbase.pb.ScopeType scope_type = 2;
inline bool FamilyScope::has_scope_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FamilyScope::set_has_scope_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FamilyScope::clear_has_scope_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FamilyScope::clear_scope_type() {
  scope_type_ = 0;
  clear_has_scope_type();
}
inline ::hbase::pb::ScopeType FamilyScope::scope_type() const {
  return static_cast< ::hbase::pb::ScopeType >(scope_type_);
}
inline void FamilyScope::set_scope_type(::hbase::pb::ScopeType value) {
  assert(::hbase::pb::ScopeType_IsValid(value));
  set_has_scope_type();
  scope_type_ = value;
}

// -------------------------------------------------------------------

// CompactionDescriptor

// required bytes table_name = 1;
inline bool CompactionDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompactionDescriptor::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompactionDescriptor::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompactionDescriptor::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& CompactionDescriptor::table_name() const {
  return *table_name_;
}
inline void CompactionDescriptor::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void CompactionDescriptor::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void CompactionDescriptor::set_table_name(const void* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* CompactionDescriptor::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompactionDescriptor::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes encoded_region_name = 2;
inline bool CompactionDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompactionDescriptor::set_has_encoded_region_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompactionDescriptor::clear_has_encoded_region_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompactionDescriptor::clear_encoded_region_name() {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_->clear();
  }
  clear_has_encoded_region_name();
}
inline const ::std::string& CompactionDescriptor::encoded_region_name() const {
  return *encoded_region_name_;
}
inline void CompactionDescriptor::set_encoded_region_name(const ::std::string& value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void CompactionDescriptor::set_encoded_region_name(const char* value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void CompactionDescriptor::set_encoded_region_name(const void* value, size_t size) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::mutable_encoded_region_name() {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  return encoded_region_name_;
}
inline ::std::string* CompactionDescriptor::release_encoded_region_name() {
  clear_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_region_name_;
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompactionDescriptor::set_allocated_encoded_region_name(::std::string* encoded_region_name) {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_region_name_;
  }
  if (encoded_region_name) {
    set_has_encoded_region_name();
    encoded_region_name_ = encoded_region_name;
  } else {
    clear_has_encoded_region_name();
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes family_name = 3;
inline bool CompactionDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompactionDescriptor::set_has_family_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompactionDescriptor::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompactionDescriptor::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& CompactionDescriptor::family_name() const {
  return *family_name_;
}
inline void CompactionDescriptor::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void CompactionDescriptor::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void CompactionDescriptor::set_family_name(const void* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* CompactionDescriptor::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompactionDescriptor::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string compaction_input = 4;
inline int CompactionDescriptor::compaction_input_size() const {
  return compaction_input_.size();
}
inline void CompactionDescriptor::clear_compaction_input() {
  compaction_input_.Clear();
}
inline const ::std::string& CompactionDescriptor::compaction_input(int index) const {
  return compaction_input_.Get(index);
}
inline ::std::string* CompactionDescriptor::mutable_compaction_input(int index) {
  return compaction_input_.Mutable(index);
}
inline void CompactionDescriptor::set_compaction_input(int index, const ::std::string& value) {
  compaction_input_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_input(int index, const char* value) {
  compaction_input_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_input(int index, const char* value, size_t size) {
  compaction_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::add_compaction_input() {
  return compaction_input_.Add();
}
inline void CompactionDescriptor::add_compaction_input(const ::std::string& value) {
  compaction_input_.Add()->assign(value);
}
inline void CompactionDescriptor::add_compaction_input(const char* value) {
  compaction_input_.Add()->assign(value);
}
inline void CompactionDescriptor::add_compaction_input(const char* value, size_t size) {
  compaction_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CompactionDescriptor::compaction_input() const {
  return compaction_input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CompactionDescriptor::mutable_compaction_input() {
  return &compaction_input_;
}

// repeated string compaction_output = 5;
inline int CompactionDescriptor::compaction_output_size() const {
  return compaction_output_.size();
}
inline void CompactionDescriptor::clear_compaction_output() {
  compaction_output_.Clear();
}
inline const ::std::string& CompactionDescriptor::compaction_output(int index) const {
  return compaction_output_.Get(index);
}
inline ::std::string* CompactionDescriptor::mutable_compaction_output(int index) {
  return compaction_output_.Mutable(index);
}
inline void CompactionDescriptor::set_compaction_output(int index, const ::std::string& value) {
  compaction_output_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_output(int index, const char* value) {
  compaction_output_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_output(int index, const char* value, size_t size) {
  compaction_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::add_compaction_output() {
  return compaction_output_.Add();
}
inline void CompactionDescriptor::add_compaction_output(const ::std::string& value) {
  compaction_output_.Add()->assign(value);
}
inline void CompactionDescriptor::add_compaction_output(const char* value) {
  compaction_output_.Add()->assign(value);
}
inline void CompactionDescriptor::add_compaction_output(const char* value, size_t size) {
  compaction_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CompactionDescriptor::compaction_output() const {
  return compaction_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CompactionDescriptor::mutable_compaction_output() {
  return &compaction_output_;
}

// required string store_home_dir = 6;
inline bool CompactionDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CompactionDescriptor::set_has_store_home_dir() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CompactionDescriptor::clear_has_store_home_dir() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CompactionDescriptor::clear_store_home_dir() {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    store_home_dir_->clear();
  }
  clear_has_store_home_dir();
}
inline const ::std::string& CompactionDescriptor::store_home_dir() const {
  return *store_home_dir_;
}
inline void CompactionDescriptor::set_store_home_dir(const ::std::string& value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void CompactionDescriptor::set_store_home_dir(const char* value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void CompactionDescriptor::set_store_home_dir(const char* value, size_t size) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::mutable_store_home_dir() {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  return store_home_dir_;
}
inline ::std::string* CompactionDescriptor::release_store_home_dir() {
  clear_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = store_home_dir_;
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompactionDescriptor::set_allocated_store_home_dir(::std::string* store_home_dir) {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete store_home_dir_;
  }
  if (store_home_dir) {
    set_has_store_home_dir();
    store_home_dir_ = store_home_dir;
  } else {
    clear_has_store_home_dir();
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes region_name = 7;
inline bool CompactionDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CompactionDescriptor::set_has_region_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CompactionDescriptor::clear_has_region_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CompactionDescriptor::clear_region_name() {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    region_name_->clear();
  }
  clear_has_region_name();
}
inline const ::std::string& CompactionDescriptor::region_name() const {
  return *region_name_;
}
inline void CompactionDescriptor::set_region_name(const ::std::string& value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void CompactionDescriptor::set_region_name(const char* value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void CompactionDescriptor::set_region_name(const void* value, size_t size) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompactionDescriptor::mutable_region_name() {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  return region_name_;
}
inline ::std::string* CompactionDescriptor::release_region_name() {
  clear_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_name_;
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompactionDescriptor::set_allocated_region_name(::std::string* region_name) {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete region_name_;
  }
  if (region_name) {
    set_has_region_name();
    region_name_ = region_name;
  } else {
    clear_has_region_name();
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FlushDescriptor_StoreFlushDescriptor

// required bytes family_name = 1;
inline bool FlushDescriptor_StoreFlushDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushDescriptor_StoreFlushDescriptor::set_has_family_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& FlushDescriptor_StoreFlushDescriptor::family_name() const {
  return *family_name_;
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const void* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushDescriptor_StoreFlushDescriptor::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string store_home_dir = 2;
inline bool FlushDescriptor_StoreFlushDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlushDescriptor_StoreFlushDescriptor::set_has_store_home_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_has_store_home_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_store_home_dir() {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    store_home_dir_->clear();
  }
  clear_has_store_home_dir();
}
inline const ::std::string& FlushDescriptor_StoreFlushDescriptor::store_home_dir() const {
  return *store_home_dir_;
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const ::std::string& value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const char* value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const char* value, size_t size) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::mutable_store_home_dir() {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  return store_home_dir_;
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::release_store_home_dir() {
  clear_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = store_home_dir_;
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushDescriptor_StoreFlushDescriptor::set_allocated_store_home_dir(::std::string* store_home_dir) {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete store_home_dir_;
  }
  if (store_home_dir) {
    set_has_store_home_dir();
    store_home_dir_ = store_home_dir;
  } else {
    clear_has_store_home_dir();
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string flush_output = 3;
inline int FlushDescriptor_StoreFlushDescriptor::flush_output_size() const {
  return flush_output_.size();
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_flush_output() {
  flush_output_.Clear();
}
inline const ::std::string& FlushDescriptor_StoreFlushDescriptor::flush_output(int index) const {
  return flush_output_.Get(index);
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::mutable_flush_output(int index) {
  return flush_output_.Mutable(index);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const ::std::string& value) {
  flush_output_.Mutable(index)->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const char* value) {
  flush_output_.Mutable(index)->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const char* value, size_t size) {
  flush_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor_StoreFlushDescriptor::add_flush_output() {
  return flush_output_.Add();
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const ::std::string& value) {
  flush_output_.Add()->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const char* value) {
  flush_output_.Add()->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const char* value, size_t size) {
  flush_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FlushDescriptor_StoreFlushDescriptor::flush_output() const {
  return flush_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FlushDescriptor_StoreFlushDescriptor::mutable_flush_output() {
  return &flush_output_;
}

// -------------------------------------------------------------------

// FlushDescriptor

// required .hbase.pb.FlushDescriptor.FlushAction action = 1;
inline bool FlushDescriptor::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushDescriptor::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushDescriptor::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushDescriptor::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::hbase::pb::FlushDescriptor_FlushAction FlushDescriptor::action() const {
  return static_cast< ::hbase::pb::FlushDescriptor_FlushAction >(action_);
}
inline void FlushDescriptor::set_action(::hbase::pb::FlushDescriptor_FlushAction value) {
  assert(::hbase::pb::FlushDescriptor_FlushAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// required bytes table_name = 2;
inline bool FlushDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlushDescriptor::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlushDescriptor::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlushDescriptor::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& FlushDescriptor::table_name() const {
  return *table_name_;
}
inline void FlushDescriptor::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void FlushDescriptor::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void FlushDescriptor::set_table_name(const void* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* FlushDescriptor::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushDescriptor::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes encoded_region_name = 3;
inline bool FlushDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlushDescriptor::set_has_encoded_region_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlushDescriptor::clear_has_encoded_region_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlushDescriptor::clear_encoded_region_name() {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_->clear();
  }
  clear_has_encoded_region_name();
}
inline const ::std::string& FlushDescriptor::encoded_region_name() const {
  return *encoded_region_name_;
}
inline void FlushDescriptor::set_encoded_region_name(const ::std::string& value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void FlushDescriptor::set_encoded_region_name(const char* value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void FlushDescriptor::set_encoded_region_name(const void* value, size_t size) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor::mutable_encoded_region_name() {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  return encoded_region_name_;
}
inline ::std::string* FlushDescriptor::release_encoded_region_name() {
  clear_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_region_name_;
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushDescriptor::set_allocated_encoded_region_name(::std::string* encoded_region_name) {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_region_name_;
  }
  if (encoded_region_name) {
    set_has_encoded_region_name();
    encoded_region_name_ = encoded_region_name;
  } else {
    clear_has_encoded_region_name();
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 flush_sequence_number = 4;
inline bool FlushDescriptor::has_flush_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlushDescriptor::set_has_flush_sequence_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlushDescriptor::clear_has_flush_sequence_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlushDescriptor::clear_flush_sequence_number() {
  flush_sequence_number_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_sequence_number();
}
inline ::google::protobuf::uint64 FlushDescriptor::flush_sequence_number() const {
  return flush_sequence_number_;
}
inline void FlushDescriptor::set_flush_sequence_number(::google::protobuf::uint64 value) {
  set_has_flush_sequence_number();
  flush_sequence_number_ = value;
}

// repeated .hbase.pb.FlushDescriptor.StoreFlushDescriptor store_flushes = 5;
inline int FlushDescriptor::store_flushes_size() const {
  return store_flushes_.size();
}
inline void FlushDescriptor::clear_store_flushes() {
  store_flushes_.Clear();
}
inline const ::hbase::pb::FlushDescriptor_StoreFlushDescriptor& FlushDescriptor::store_flushes(int index) const {
  return store_flushes_.Get(index);
}
inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* FlushDescriptor::mutable_store_flushes(int index) {
  return store_flushes_.Mutable(index);
}
inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* FlushDescriptor::add_store_flushes() {
  return store_flushes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >&
FlushDescriptor::store_flushes() const {
  return store_flushes_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >*
FlushDescriptor::mutable_store_flushes() {
  return &store_flushes_;
}

// optional bytes region_name = 6;
inline bool FlushDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FlushDescriptor::set_has_region_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FlushDescriptor::clear_has_region_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FlushDescriptor::clear_region_name() {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    region_name_->clear();
  }
  clear_has_region_name();
}
inline const ::std::string& FlushDescriptor::region_name() const {
  return *region_name_;
}
inline void FlushDescriptor::set_region_name(const ::std::string& value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void FlushDescriptor::set_region_name(const char* value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void FlushDescriptor::set_region_name(const void* value, size_t size) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushDescriptor::mutable_region_name() {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  return region_name_;
}
inline ::std::string* FlushDescriptor::release_region_name() {
  clear_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_name_;
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushDescriptor::set_allocated_region_name(::std::string* region_name) {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete region_name_;
  }
  if (region_name) {
    set_has_region_name();
    region_name_ = region_name;
  } else {
    clear_has_region_name();
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StoreDescriptor

// required bytes family_name = 1;
inline bool StoreDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreDescriptor::set_has_family_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreDescriptor::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreDescriptor::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& StoreDescriptor::family_name() const {
  return *family_name_;
}
inline void StoreDescriptor::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void StoreDescriptor::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void StoreDescriptor::set_family_name(const void* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreDescriptor::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* StoreDescriptor::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreDescriptor::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string store_home_dir = 2;
inline bool StoreDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreDescriptor::set_has_store_home_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreDescriptor::clear_has_store_home_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreDescriptor::clear_store_home_dir() {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    store_home_dir_->clear();
  }
  clear_has_store_home_dir();
}
inline const ::std::string& StoreDescriptor::store_home_dir() const {
  return *store_home_dir_;
}
inline void StoreDescriptor::set_store_home_dir(const ::std::string& value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void StoreDescriptor::set_store_home_dir(const char* value) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(value);
}
inline void StoreDescriptor::set_store_home_dir(const char* value, size_t size) {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  store_home_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreDescriptor::mutable_store_home_dir() {
  set_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    store_home_dir_ = new ::std::string;
  }
  return store_home_dir_;
}
inline ::std::string* StoreDescriptor::release_store_home_dir() {
  clear_has_store_home_dir();
  if (store_home_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = store_home_dir_;
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreDescriptor::set_allocated_store_home_dir(::std::string* store_home_dir) {
  if (store_home_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete store_home_dir_;
  }
  if (store_home_dir) {
    set_has_store_home_dir();
    store_home_dir_ = store_home_dir;
  } else {
    clear_has_store_home_dir();
    store_home_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string store_file = 3;
inline int StoreDescriptor::store_file_size() const {
  return store_file_.size();
}
inline void StoreDescriptor::clear_store_file() {
  store_file_.Clear();
}
inline const ::std::string& StoreDescriptor::store_file(int index) const {
  return store_file_.Get(index);
}
inline ::std::string* StoreDescriptor::mutable_store_file(int index) {
  return store_file_.Mutable(index);
}
inline void StoreDescriptor::set_store_file(int index, const ::std::string& value) {
  store_file_.Mutable(index)->assign(value);
}
inline void StoreDescriptor::set_store_file(int index, const char* value) {
  store_file_.Mutable(index)->assign(value);
}
inline void StoreDescriptor::set_store_file(int index, const char* value, size_t size) {
  store_file_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreDescriptor::add_store_file() {
  return store_file_.Add();
}
inline void StoreDescriptor::add_store_file(const ::std::string& value) {
  store_file_.Add()->assign(value);
}
inline void StoreDescriptor::add_store_file(const char* value) {
  store_file_.Add()->assign(value);
}
inline void StoreDescriptor::add_store_file(const char* value, size_t size) {
  store_file_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StoreDescriptor::store_file() const {
  return store_file_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StoreDescriptor::mutable_store_file() {
  return &store_file_;
}

// -------------------------------------------------------------------

// BulkLoadDescriptor

// required .hbase.pb.TableName table_name = 1;
inline bool BulkLoadDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadDescriptor::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulkLoadDescriptor::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulkLoadDescriptor::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& BulkLoadDescriptor::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* BulkLoadDescriptor::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* BulkLoadDescriptor::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void BulkLoadDescriptor::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required bytes encoded_region_name = 2;
inline bool BulkLoadDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulkLoadDescriptor::set_has_encoded_region_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulkLoadDescriptor::clear_has_encoded_region_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulkLoadDescriptor::clear_encoded_region_name() {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_->clear();
  }
  clear_has_encoded_region_name();
}
inline const ::std::string& BulkLoadDescriptor::encoded_region_name() const {
  return *encoded_region_name_;
}
inline void BulkLoadDescriptor::set_encoded_region_name(const ::std::string& value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void BulkLoadDescriptor::set_encoded_region_name(const char* value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void BulkLoadDescriptor::set_encoded_region_name(const void* value, size_t size) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulkLoadDescriptor::mutable_encoded_region_name() {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  return encoded_region_name_;
}
inline ::std::string* BulkLoadDescriptor::release_encoded_region_name() {
  clear_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_region_name_;
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulkLoadDescriptor::set_allocated_encoded_region_name(::std::string* encoded_region_name) {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_region_name_;
  }
  if (encoded_region_name) {
    set_has_encoded_region_name();
    encoded_region_name_ = encoded_region_name;
  } else {
    clear_has_encoded_region_name();
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.StoreDescriptor stores = 3;
inline int BulkLoadDescriptor::stores_size() const {
  return stores_.size();
}
inline void BulkLoadDescriptor::clear_stores() {
  stores_.Clear();
}
inline const ::hbase::pb::StoreDescriptor& BulkLoadDescriptor::stores(int index) const {
  return stores_.Get(index);
}
inline ::hbase::pb::StoreDescriptor* BulkLoadDescriptor::mutable_stores(int index) {
  return stores_.Mutable(index);
}
inline ::hbase::pb::StoreDescriptor* BulkLoadDescriptor::add_stores() {
  return stores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
BulkLoadDescriptor::stores() const {
  return stores_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
BulkLoadDescriptor::mutable_stores() {
  return &stores_;
}

// required int64 bulkload_seq_num = 4;
inline bool BulkLoadDescriptor::has_bulkload_seq_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulkLoadDescriptor::set_has_bulkload_seq_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BulkLoadDescriptor::clear_has_bulkload_seq_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BulkLoadDescriptor::clear_bulkload_seq_num() {
  bulkload_seq_num_ = GOOGLE_LONGLONG(0);
  clear_has_bulkload_seq_num();
}
inline ::google::protobuf::int64 BulkLoadDescriptor::bulkload_seq_num() const {
  return bulkload_seq_num_;
}
inline void BulkLoadDescriptor::set_bulkload_seq_num(::google::protobuf::int64 value) {
  set_has_bulkload_seq_num();
  bulkload_seq_num_ = value;
}

// -------------------------------------------------------------------

// RegionEventDescriptor

// required .hbase.pb.RegionEventDescriptor.EventType event_type = 1;
inline bool RegionEventDescriptor::has_event_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionEventDescriptor::set_has_event_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionEventDescriptor::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionEventDescriptor::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::hbase::pb::RegionEventDescriptor_EventType RegionEventDescriptor::event_type() const {
  return static_cast< ::hbase::pb::RegionEventDescriptor_EventType >(event_type_);
}
inline void RegionEventDescriptor::set_event_type(::hbase::pb::RegionEventDescriptor_EventType value) {
  assert(::hbase::pb::RegionEventDescriptor_EventType_IsValid(value));
  set_has_event_type();
  event_type_ = value;
}

// required bytes table_name = 2;
inline bool RegionEventDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionEventDescriptor::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionEventDescriptor::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionEventDescriptor::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& RegionEventDescriptor::table_name() const {
  return *table_name_;
}
inline void RegionEventDescriptor::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void RegionEventDescriptor::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void RegionEventDescriptor::set_table_name(const void* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionEventDescriptor::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* RegionEventDescriptor::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionEventDescriptor::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes encoded_region_name = 3;
inline bool RegionEventDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionEventDescriptor::set_has_encoded_region_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionEventDescriptor::clear_has_encoded_region_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionEventDescriptor::clear_encoded_region_name() {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_->clear();
  }
  clear_has_encoded_region_name();
}
inline const ::std::string& RegionEventDescriptor::encoded_region_name() const {
  return *encoded_region_name_;
}
inline void RegionEventDescriptor::set_encoded_region_name(const ::std::string& value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void RegionEventDescriptor::set_encoded_region_name(const char* value) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(value);
}
inline void RegionEventDescriptor::set_encoded_region_name(const void* value, size_t size) {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  encoded_region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionEventDescriptor::mutable_encoded_region_name() {
  set_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    encoded_region_name_ = new ::std::string;
  }
  return encoded_region_name_;
}
inline ::std::string* RegionEventDescriptor::release_encoded_region_name() {
  clear_has_encoded_region_name();
  if (encoded_region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_region_name_;
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionEventDescriptor::set_allocated_encoded_region_name(::std::string* encoded_region_name) {
  if (encoded_region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_region_name_;
  }
  if (encoded_region_name) {
    set_has_encoded_region_name();
    encoded_region_name_ = encoded_region_name;
  } else {
    clear_has_encoded_region_name();
    encoded_region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 log_sequence_number = 4;
inline bool RegionEventDescriptor::has_log_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionEventDescriptor::set_has_log_sequence_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegionEventDescriptor::clear_has_log_sequence_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegionEventDescriptor::clear_log_sequence_number() {
  log_sequence_number_ = GOOGLE_ULONGLONG(0);
  clear_has_log_sequence_number();
}
inline ::google::protobuf::uint64 RegionEventDescriptor::log_sequence_number() const {
  return log_sequence_number_;
}
inline void RegionEventDescriptor::set_log_sequence_number(::google::protobuf::uint64 value) {
  set_has_log_sequence_number();
  log_sequence_number_ = value;
}

// repeated .hbase.pb.StoreDescriptor stores = 5;
inline int RegionEventDescriptor::stores_size() const {
  return stores_.size();
}
inline void RegionEventDescriptor::clear_stores() {
  stores_.Clear();
}
inline const ::hbase::pb::StoreDescriptor& RegionEventDescriptor::stores(int index) const {
  return stores_.Get(index);
}
inline ::hbase::pb::StoreDescriptor* RegionEventDescriptor::mutable_stores(int index) {
  return stores_.Mutable(index);
}
inline ::hbase::pb::StoreDescriptor* RegionEventDescriptor::add_stores() {
  return stores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
RegionEventDescriptor::stores() const {
  return stores_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
RegionEventDescriptor::mutable_stores() {
  return &stores_;
}

// optional .hbase.pb.ServerName server = 6;
inline bool RegionEventDescriptor::has_server() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionEventDescriptor::set_has_server() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegionEventDescriptor::clear_has_server() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegionEventDescriptor::clear_server() {
  if (server_ != NULL) server_->::hbase::pb::ServerName::Clear();
  clear_has_server();
}
inline const ::hbase::pb::ServerName& RegionEventDescriptor::server() const {
  return server_ != NULL ? *server_ : *default_instance_->server_;
}
inline ::hbase::pb::ServerName* RegionEventDescriptor::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::hbase::pb::ServerName;
  return server_;
}
inline ::hbase::pb::ServerName* RegionEventDescriptor::release_server() {
  clear_has_server();
  ::hbase::pb::ServerName* temp = server_;
  server_ = NULL;
  return temp;
}
inline void RegionEventDescriptor::set_allocated_server(::hbase::pb::ServerName* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional bytes region_name = 7;
inline bool RegionEventDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionEventDescriptor::set_has_region_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegionEventDescriptor::clear_has_region_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegionEventDescriptor::clear_region_name() {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    region_name_->clear();
  }
  clear_has_region_name();
}
inline const ::std::string& RegionEventDescriptor::region_name() const {
  return *region_name_;
}
inline void RegionEventDescriptor::set_region_name(const ::std::string& value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void RegionEventDescriptor::set_region_name(const char* value) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(value);
}
inline void RegionEventDescriptor::set_region_name(const void* value, size_t size) {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  region_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionEventDescriptor::mutable_region_name() {
  set_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    region_name_ = new ::std::string;
  }
  return region_name_;
}
inline ::std::string* RegionEventDescriptor::release_region_name() {
  clear_has_region_name();
  if (region_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_name_;
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionEventDescriptor::set_allocated_region_name(::std::string* region_name) {
  if (region_name_ != &::google::protobuf::internal::kEmptyString) {
    delete region_name_;
  }
  if (region_name) {
    set_has_region_name();
    region_name_ = region_name;
  } else {
    clear_has_region_name();
    region_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WALTrailer


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::FlushDescriptor_FlushAction>() {
  return ::hbase::pb::FlushDescriptor_FlushAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::RegionEventDescriptor_EventType>() {
  return ::hbase::pb::RegionEventDescriptor_EventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ScopeType>() {
  return ::hbase::pb::ScopeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WAL_2eproto__INCLUDED
