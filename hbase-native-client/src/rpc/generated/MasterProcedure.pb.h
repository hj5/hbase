// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MasterProcedure.proto

#ifndef PROTOBUF_MasterProcedure_2eproto__INCLUDED
#define PROTOBUF_MasterProcedure_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "RPC.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MasterProcedure_2eproto();
void protobuf_AssignDesc_MasterProcedure_2eproto();
void protobuf_ShutdownFile_MasterProcedure_2eproto();

class CreateTableStateData;
class ModifyTableStateData;
class TruncateTableStateData;
class DeleteTableStateData;
class CreateNamespaceStateData;
class ModifyNamespaceStateData;
class DeleteNamespaceStateData;
class AddColumnFamilyStateData;
class ModifyColumnFamilyStateData;
class DeleteColumnFamilyStateData;
class EnableTableStateData;
class DisableTableStateData;
class ServerCrashStateData;

enum CreateTableState {
  CREATE_TABLE_PRE_OPERATION = 1,
  CREATE_TABLE_WRITE_FS_LAYOUT = 2,
  CREATE_TABLE_ADD_TO_META = 3,
  CREATE_TABLE_ASSIGN_REGIONS = 4,
  CREATE_TABLE_UPDATE_DESC_CACHE = 5,
  CREATE_TABLE_POST_OPERATION = 6
};
bool CreateTableState_IsValid(int value);
const CreateTableState CreateTableState_MIN = CREATE_TABLE_PRE_OPERATION;
const CreateTableState CreateTableState_MAX = CREATE_TABLE_POST_OPERATION;
const int CreateTableState_ARRAYSIZE = CreateTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreateTableState_descriptor();
inline const ::std::string& CreateTableState_Name(CreateTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreateTableState_descriptor(), value);
}
inline bool CreateTableState_Parse(
    const ::std::string& name, CreateTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreateTableState>(
    CreateTableState_descriptor(), name, value);
}
enum ModifyTableState {
  MODIFY_TABLE_PREPARE = 1,
  MODIFY_TABLE_PRE_OPERATION = 2,
  MODIFY_TABLE_UPDATE_TABLE_DESCRIPTOR = 3,
  MODIFY_TABLE_REMOVE_REPLICA_COLUMN = 4,
  MODIFY_TABLE_DELETE_FS_LAYOUT = 5,
  MODIFY_TABLE_POST_OPERATION = 6,
  MODIFY_TABLE_REOPEN_ALL_REGIONS = 7
};
bool ModifyTableState_IsValid(int value);
const ModifyTableState ModifyTableState_MIN = MODIFY_TABLE_PREPARE;
const ModifyTableState ModifyTableState_MAX = MODIFY_TABLE_REOPEN_ALL_REGIONS;
const int ModifyTableState_ARRAYSIZE = ModifyTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModifyTableState_descriptor();
inline const ::std::string& ModifyTableState_Name(ModifyTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModifyTableState_descriptor(), value);
}
inline bool ModifyTableState_Parse(
    const ::std::string& name, ModifyTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModifyTableState>(
    ModifyTableState_descriptor(), name, value);
}
enum TruncateTableState {
  TRUNCATE_TABLE_PRE_OPERATION = 1,
  TRUNCATE_TABLE_REMOVE_FROM_META = 2,
  TRUNCATE_TABLE_CLEAR_FS_LAYOUT = 3,
  TRUNCATE_TABLE_CREATE_FS_LAYOUT = 4,
  TRUNCATE_TABLE_ADD_TO_META = 5,
  TRUNCATE_TABLE_ASSIGN_REGIONS = 6,
  TRUNCATE_TABLE_POST_OPERATION = 7
};
bool TruncateTableState_IsValid(int value);
const TruncateTableState TruncateTableState_MIN = TRUNCATE_TABLE_PRE_OPERATION;
const TruncateTableState TruncateTableState_MAX = TRUNCATE_TABLE_POST_OPERATION;
const int TruncateTableState_ARRAYSIZE = TruncateTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TruncateTableState_descriptor();
inline const ::std::string& TruncateTableState_Name(TruncateTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TruncateTableState_descriptor(), value);
}
inline bool TruncateTableState_Parse(
    const ::std::string& name, TruncateTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TruncateTableState>(
    TruncateTableState_descriptor(), name, value);
}
enum DeleteTableState {
  DELETE_TABLE_PRE_OPERATION = 1,
  DELETE_TABLE_REMOVE_FROM_META = 2,
  DELETE_TABLE_CLEAR_FS_LAYOUT = 3,
  DELETE_TABLE_UPDATE_DESC_CACHE = 4,
  DELETE_TABLE_UNASSIGN_REGIONS = 5,
  DELETE_TABLE_POST_OPERATION = 6
};
bool DeleteTableState_IsValid(int value);
const DeleteTableState DeleteTableState_MIN = DELETE_TABLE_PRE_OPERATION;
const DeleteTableState DeleteTableState_MAX = DELETE_TABLE_POST_OPERATION;
const int DeleteTableState_ARRAYSIZE = DeleteTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeleteTableState_descriptor();
inline const ::std::string& DeleteTableState_Name(DeleteTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeleteTableState_descriptor(), value);
}
inline bool DeleteTableState_Parse(
    const ::std::string& name, DeleteTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeleteTableState>(
    DeleteTableState_descriptor(), name, value);
}
enum CreateNamespaceState {
  CREATE_NAMESPACE_PREPARE = 1,
  CREATE_NAMESPACE_CREATE_DIRECTORY = 2,
  CREATE_NAMESPACE_INSERT_INTO_NS_TABLE = 3,
  CREATE_NAMESPACE_UPDATE_ZK = 4,
  CREATE_NAMESPACE_SET_NAMESPACE_QUOTA = 5
};
bool CreateNamespaceState_IsValid(int value);
const CreateNamespaceState CreateNamespaceState_MIN = CREATE_NAMESPACE_PREPARE;
const CreateNamespaceState CreateNamespaceState_MAX = CREATE_NAMESPACE_SET_NAMESPACE_QUOTA;
const int CreateNamespaceState_ARRAYSIZE = CreateNamespaceState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreateNamespaceState_descriptor();
inline const ::std::string& CreateNamespaceState_Name(CreateNamespaceState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreateNamespaceState_descriptor(), value);
}
inline bool CreateNamespaceState_Parse(
    const ::std::string& name, CreateNamespaceState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreateNamespaceState>(
    CreateNamespaceState_descriptor(), name, value);
}
enum ModifyNamespaceState {
  MODIFY_NAMESPACE_PREPARE = 1,
  MODIFY_NAMESPACE_UPDATE_NS_TABLE = 2,
  MODIFY_NAMESPACE_UPDATE_ZK = 3
};
bool ModifyNamespaceState_IsValid(int value);
const ModifyNamespaceState ModifyNamespaceState_MIN = MODIFY_NAMESPACE_PREPARE;
const ModifyNamespaceState ModifyNamespaceState_MAX = MODIFY_NAMESPACE_UPDATE_ZK;
const int ModifyNamespaceState_ARRAYSIZE = ModifyNamespaceState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModifyNamespaceState_descriptor();
inline const ::std::string& ModifyNamespaceState_Name(ModifyNamespaceState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModifyNamespaceState_descriptor(), value);
}
inline bool ModifyNamespaceState_Parse(
    const ::std::string& name, ModifyNamespaceState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModifyNamespaceState>(
    ModifyNamespaceState_descriptor(), name, value);
}
enum DeleteNamespaceState {
  DELETE_NAMESPACE_PREPARE = 1,
  DELETE_NAMESPACE_DELETE_FROM_NS_TABLE = 2,
  DELETE_NAMESPACE_REMOVE_FROM_ZK = 3,
  DELETE_NAMESPACE_DELETE_DIRECTORIES = 4,
  DELETE_NAMESPACE_REMOVE_NAMESPACE_QUOTA = 5
};
bool DeleteNamespaceState_IsValid(int value);
const DeleteNamespaceState DeleteNamespaceState_MIN = DELETE_NAMESPACE_PREPARE;
const DeleteNamespaceState DeleteNamespaceState_MAX = DELETE_NAMESPACE_REMOVE_NAMESPACE_QUOTA;
const int DeleteNamespaceState_ARRAYSIZE = DeleteNamespaceState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeleteNamespaceState_descriptor();
inline const ::std::string& DeleteNamespaceState_Name(DeleteNamespaceState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeleteNamespaceState_descriptor(), value);
}
inline bool DeleteNamespaceState_Parse(
    const ::std::string& name, DeleteNamespaceState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeleteNamespaceState>(
    DeleteNamespaceState_descriptor(), name, value);
}
enum AddColumnFamilyState {
  ADD_COLUMN_FAMILY_PREPARE = 1,
  ADD_COLUMN_FAMILY_PRE_OPERATION = 2,
  ADD_COLUMN_FAMILY_UPDATE_TABLE_DESCRIPTOR = 3,
  ADD_COLUMN_FAMILY_POST_OPERATION = 4,
  ADD_COLUMN_FAMILY_REOPEN_ALL_REGIONS = 5
};
bool AddColumnFamilyState_IsValid(int value);
const AddColumnFamilyState AddColumnFamilyState_MIN = ADD_COLUMN_FAMILY_PREPARE;
const AddColumnFamilyState AddColumnFamilyState_MAX = ADD_COLUMN_FAMILY_REOPEN_ALL_REGIONS;
const int AddColumnFamilyState_ARRAYSIZE = AddColumnFamilyState_MAX + 1;

const ::google::protobuf::EnumDescriptor* AddColumnFamilyState_descriptor();
inline const ::std::string& AddColumnFamilyState_Name(AddColumnFamilyState value) {
  return ::google::protobuf::internal::NameOfEnum(
    AddColumnFamilyState_descriptor(), value);
}
inline bool AddColumnFamilyState_Parse(
    const ::std::string& name, AddColumnFamilyState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddColumnFamilyState>(
    AddColumnFamilyState_descriptor(), name, value);
}
enum ModifyColumnFamilyState {
  MODIFY_COLUMN_FAMILY_PREPARE = 1,
  MODIFY_COLUMN_FAMILY_PRE_OPERATION = 2,
  MODIFY_COLUMN_FAMILY_UPDATE_TABLE_DESCRIPTOR = 3,
  MODIFY_COLUMN_FAMILY_POST_OPERATION = 4,
  MODIFY_COLUMN_FAMILY_REOPEN_ALL_REGIONS = 5
};
bool ModifyColumnFamilyState_IsValid(int value);
const ModifyColumnFamilyState ModifyColumnFamilyState_MIN = MODIFY_COLUMN_FAMILY_PREPARE;
const ModifyColumnFamilyState ModifyColumnFamilyState_MAX = MODIFY_COLUMN_FAMILY_REOPEN_ALL_REGIONS;
const int ModifyColumnFamilyState_ARRAYSIZE = ModifyColumnFamilyState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModifyColumnFamilyState_descriptor();
inline const ::std::string& ModifyColumnFamilyState_Name(ModifyColumnFamilyState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModifyColumnFamilyState_descriptor(), value);
}
inline bool ModifyColumnFamilyState_Parse(
    const ::std::string& name, ModifyColumnFamilyState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModifyColumnFamilyState>(
    ModifyColumnFamilyState_descriptor(), name, value);
}
enum DeleteColumnFamilyState {
  DELETE_COLUMN_FAMILY_PREPARE = 1,
  DELETE_COLUMN_FAMILY_PRE_OPERATION = 2,
  DELETE_COLUMN_FAMILY_UPDATE_TABLE_DESCRIPTOR = 3,
  DELETE_COLUMN_FAMILY_DELETE_FS_LAYOUT = 4,
  DELETE_COLUMN_FAMILY_POST_OPERATION = 5,
  DELETE_COLUMN_FAMILY_REOPEN_ALL_REGIONS = 6
};
bool DeleteColumnFamilyState_IsValid(int value);
const DeleteColumnFamilyState DeleteColumnFamilyState_MIN = DELETE_COLUMN_FAMILY_PREPARE;
const DeleteColumnFamilyState DeleteColumnFamilyState_MAX = DELETE_COLUMN_FAMILY_REOPEN_ALL_REGIONS;
const int DeleteColumnFamilyState_ARRAYSIZE = DeleteColumnFamilyState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeleteColumnFamilyState_descriptor();
inline const ::std::string& DeleteColumnFamilyState_Name(DeleteColumnFamilyState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeleteColumnFamilyState_descriptor(), value);
}
inline bool DeleteColumnFamilyState_Parse(
    const ::std::string& name, DeleteColumnFamilyState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeleteColumnFamilyState>(
    DeleteColumnFamilyState_descriptor(), name, value);
}
enum EnableTableState {
  ENABLE_TABLE_PREPARE = 1,
  ENABLE_TABLE_PRE_OPERATION = 2,
  ENABLE_TABLE_SET_ENABLING_TABLE_STATE = 3,
  ENABLE_TABLE_MARK_REGIONS_ONLINE = 4,
  ENABLE_TABLE_SET_ENABLED_TABLE_STATE = 5,
  ENABLE_TABLE_POST_OPERATION = 6
};
bool EnableTableState_IsValid(int value);
const EnableTableState EnableTableState_MIN = ENABLE_TABLE_PREPARE;
const EnableTableState EnableTableState_MAX = ENABLE_TABLE_POST_OPERATION;
const int EnableTableState_ARRAYSIZE = EnableTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnableTableState_descriptor();
inline const ::std::string& EnableTableState_Name(EnableTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnableTableState_descriptor(), value);
}
inline bool EnableTableState_Parse(
    const ::std::string& name, EnableTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnableTableState>(
    EnableTableState_descriptor(), name, value);
}
enum DisableTableState {
  DISABLE_TABLE_PREPARE = 1,
  DISABLE_TABLE_PRE_OPERATION = 2,
  DISABLE_TABLE_SET_DISABLING_TABLE_STATE = 3,
  DISABLE_TABLE_MARK_REGIONS_OFFLINE = 4,
  DISABLE_TABLE_SET_DISABLED_TABLE_STATE = 5,
  DISABLE_TABLE_POST_OPERATION = 6
};
bool DisableTableState_IsValid(int value);
const DisableTableState DisableTableState_MIN = DISABLE_TABLE_PREPARE;
const DisableTableState DisableTableState_MAX = DISABLE_TABLE_POST_OPERATION;
const int DisableTableState_ARRAYSIZE = DisableTableState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisableTableState_descriptor();
inline const ::std::string& DisableTableState_Name(DisableTableState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisableTableState_descriptor(), value);
}
inline bool DisableTableState_Parse(
    const ::std::string& name, DisableTableState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisableTableState>(
    DisableTableState_descriptor(), name, value);
}
enum ServerCrashState {
  SERVER_CRASH_START = 1,
  SERVER_CRASH_PROCESS_META = 2,
  SERVER_CRASH_GET_REGIONS = 3,
  SERVER_CRASH_NO_SPLIT_LOGS = 4,
  SERVER_CRASH_SPLIT_LOGS = 5,
  SERVER_CRASH_PREPARE_LOG_REPLAY = 6,
  SERVER_CRASH_ASSIGN = 8,
  SERVER_CRASH_WAIT_ON_ASSIGN = 9,
  SERVER_CRASH_FINISH = 100
};
bool ServerCrashState_IsValid(int value);
const ServerCrashState ServerCrashState_MIN = SERVER_CRASH_START;
const ServerCrashState ServerCrashState_MAX = SERVER_CRASH_FINISH;
const int ServerCrashState_ARRAYSIZE = ServerCrashState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerCrashState_descriptor();
inline const ::std::string& ServerCrashState_Name(ServerCrashState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerCrashState_descriptor(), value);
}
inline bool ServerCrashState_Parse(
    const ::std::string& name, ServerCrashState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerCrashState>(
    ServerCrashState_descriptor(), name, value);
}
// ===================================================================

class CreateTableStateData : public ::google::protobuf::Message {
 public:
  CreateTableStateData();
  virtual ~CreateTableStateData();

  CreateTableStateData(const CreateTableStateData& from);

  inline CreateTableStateData& operator=(const CreateTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableStateData& default_instance();

  void Swap(CreateTableStateData* other);

  // implements Message ----------------------------------------------

  CreateTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTableStateData& from);
  void MergeFrom(const CreateTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableSchema table_schema = 2;
  inline bool has_table_schema() const;
  inline void clear_table_schema();
  static const int kTableSchemaFieldNumber = 2;
  inline const ::hbase::pb::TableSchema& table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_table_schema();
  inline ::hbase::pb::TableSchema* release_table_schema();
  inline void set_allocated_table_schema(::hbase::pb::TableSchema* table_schema);

  // repeated .hbase.pb.RegionInfo region_info = 3;
  inline int region_info_size() const;
  inline void clear_region_info();
  static const int kRegionInfoFieldNumber = 3;
  inline const ::hbase::pb::RegionInfo& region_info(int index) const;
  inline ::hbase::pb::RegionInfo* mutable_region_info(int index);
  inline ::hbase::pb::RegionInfo* add_region_info();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
      region_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
      mutable_region_info();

  // @@protoc_insertion_point(class_scope:hbase.pb.CreateTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_schema();
  inline void clear_has_table_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableSchema* table_schema_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo > region_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static CreateTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class ModifyTableStateData : public ::google::protobuf::Message {
 public:
  ModifyTableStateData();
  virtual ~ModifyTableStateData();

  ModifyTableStateData(const ModifyTableStateData& from);

  inline ModifyTableStateData& operator=(const ModifyTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyTableStateData& default_instance();

  void Swap(ModifyTableStateData* other);

  // implements Message ----------------------------------------------

  ModifyTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyTableStateData& from);
  void MergeFrom(const ModifyTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // optional .hbase.pb.TableSchema unmodified_table_schema = 2;
  inline bool has_unmodified_table_schema() const;
  inline void clear_unmodified_table_schema();
  static const int kUnmodifiedTableSchemaFieldNumber = 2;
  inline const ::hbase::pb::TableSchema& unmodified_table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_unmodified_table_schema();
  inline ::hbase::pb::TableSchema* release_unmodified_table_schema();
  inline void set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema);

  // required .hbase.pb.TableSchema modified_table_schema = 3;
  inline bool has_modified_table_schema() const;
  inline void clear_modified_table_schema();
  static const int kModifiedTableSchemaFieldNumber = 3;
  inline const ::hbase::pb::TableSchema& modified_table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_modified_table_schema();
  inline ::hbase::pb::TableSchema* release_modified_table_schema();
  inline void set_allocated_modified_table_schema(::hbase::pb::TableSchema* modified_table_schema);

  // required bool delete_column_family_in_modify = 4;
  inline bool has_delete_column_family_in_modify() const;
  inline void clear_delete_column_family_in_modify();
  static const int kDeleteColumnFamilyInModifyFieldNumber = 4;
  inline bool delete_column_family_in_modify() const;
  inline void set_delete_column_family_in_modify(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ModifyTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_unmodified_table_schema();
  inline void clear_has_unmodified_table_schema();
  inline void set_has_modified_table_schema();
  inline void clear_has_modified_table_schema();
  inline void set_has_delete_column_family_in_modify();
  inline void clear_has_delete_column_family_in_modify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableSchema* unmodified_table_schema_;
  ::hbase::pb::TableSchema* modified_table_schema_;
  bool delete_column_family_in_modify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static ModifyTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class TruncateTableStateData : public ::google::protobuf::Message {
 public:
  TruncateTableStateData();
  virtual ~TruncateTableStateData();

  TruncateTableStateData(const TruncateTableStateData& from);

  inline TruncateTableStateData& operator=(const TruncateTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateTableStateData& default_instance();

  void Swap(TruncateTableStateData* other);

  // implements Message ----------------------------------------------

  TruncateTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateTableStateData& from);
  void MergeFrom(const TruncateTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required bool preserve_splits = 2;
  inline bool has_preserve_splits() const;
  inline void clear_preserve_splits();
  static const int kPreserveSplitsFieldNumber = 2;
  inline bool preserve_splits() const;
  inline void set_preserve_splits(bool value);

  // optional .hbase.pb.TableName table_name = 3;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional .hbase.pb.TableSchema table_schema = 4;
  inline bool has_table_schema() const;
  inline void clear_table_schema();
  static const int kTableSchemaFieldNumber = 4;
  inline const ::hbase::pb::TableSchema& table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_table_schema();
  inline ::hbase::pb::TableSchema* release_table_schema();
  inline void set_allocated_table_schema(::hbase::pb::TableSchema* table_schema);

  // repeated .hbase.pb.RegionInfo region_info = 5;
  inline int region_info_size() const;
  inline void clear_region_info();
  static const int kRegionInfoFieldNumber = 5;
  inline const ::hbase::pb::RegionInfo& region_info(int index) const;
  inline ::hbase::pb::RegionInfo* mutable_region_info(int index);
  inline ::hbase::pb::RegionInfo* add_region_info();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
      region_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
      mutable_region_info();

  // @@protoc_insertion_point(class_scope:hbase.pb.TruncateTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_preserve_splits();
  inline void clear_has_preserve_splits();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_table_schema();
  inline void clear_has_table_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  ::hbase::pb::TableSchema* table_schema_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo > region_info_;
  bool preserve_splits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static TruncateTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class DeleteTableStateData : public ::google::protobuf::Message {
 public:
  DeleteTableStateData();
  virtual ~DeleteTableStateData();

  DeleteTableStateData(const DeleteTableStateData& from);

  inline DeleteTableStateData& operator=(const DeleteTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteTableStateData& default_instance();

  void Swap(DeleteTableStateData* other);

  // implements Message ----------------------------------------------

  DeleteTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteTableStateData& from);
  void MergeFrom(const DeleteTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // repeated .hbase.pb.RegionInfo region_info = 3;
  inline int region_info_size() const;
  inline void clear_region_info();
  static const int kRegionInfoFieldNumber = 3;
  inline const ::hbase::pb::RegionInfo& region_info(int index) const;
  inline ::hbase::pb::RegionInfo* mutable_region_info(int index);
  inline ::hbase::pb::RegionInfo* add_region_info();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
      region_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
      mutable_region_info();

  // @@protoc_insertion_point(class_scope:hbase.pb.DeleteTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo > region_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static DeleteTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class CreateNamespaceStateData : public ::google::protobuf::Message {
 public:
  CreateNamespaceStateData();
  virtual ~CreateNamespaceStateData();

  CreateNamespaceStateData(const CreateNamespaceStateData& from);

  inline CreateNamespaceStateData& operator=(const CreateNamespaceStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNamespaceStateData& default_instance();

  void Swap(CreateNamespaceStateData* other);

  // implements Message ----------------------------------------------

  CreateNamespaceStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNamespaceStateData& from);
  void MergeFrom(const CreateNamespaceStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.NamespaceDescriptor namespace_descriptor = 1;
  inline bool has_namespace_descriptor() const;
  inline void clear_namespace_descriptor();
  static const int kNamespaceDescriptorFieldNumber = 1;
  inline const ::hbase::pb::NamespaceDescriptor& namespace_descriptor() const;
  inline ::hbase::pb::NamespaceDescriptor* mutable_namespace_descriptor();
  inline ::hbase::pb::NamespaceDescriptor* release_namespace_descriptor();
  inline void set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor);

  // @@protoc_insertion_point(class_scope:hbase.pb.CreateNamespaceStateData)
 private:
  inline void set_has_namespace_descriptor();
  inline void clear_has_namespace_descriptor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::NamespaceDescriptor* namespace_descriptor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static CreateNamespaceStateData* default_instance_;
};
// -------------------------------------------------------------------

class ModifyNamespaceStateData : public ::google::protobuf::Message {
 public:
  ModifyNamespaceStateData();
  virtual ~ModifyNamespaceStateData();

  ModifyNamespaceStateData(const ModifyNamespaceStateData& from);

  inline ModifyNamespaceStateData& operator=(const ModifyNamespaceStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyNamespaceStateData& default_instance();

  void Swap(ModifyNamespaceStateData* other);

  // implements Message ----------------------------------------------

  ModifyNamespaceStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyNamespaceStateData& from);
  void MergeFrom(const ModifyNamespaceStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.NamespaceDescriptor namespace_descriptor = 1;
  inline bool has_namespace_descriptor() const;
  inline void clear_namespace_descriptor();
  static const int kNamespaceDescriptorFieldNumber = 1;
  inline const ::hbase::pb::NamespaceDescriptor& namespace_descriptor() const;
  inline ::hbase::pb::NamespaceDescriptor* mutable_namespace_descriptor();
  inline ::hbase::pb::NamespaceDescriptor* release_namespace_descriptor();
  inline void set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor);

  // optional .hbase.pb.NamespaceDescriptor unmodified_namespace_descriptor = 2;
  inline bool has_unmodified_namespace_descriptor() const;
  inline void clear_unmodified_namespace_descriptor();
  static const int kUnmodifiedNamespaceDescriptorFieldNumber = 2;
  inline const ::hbase::pb::NamespaceDescriptor& unmodified_namespace_descriptor() const;
  inline ::hbase::pb::NamespaceDescriptor* mutable_unmodified_namespace_descriptor();
  inline ::hbase::pb::NamespaceDescriptor* release_unmodified_namespace_descriptor();
  inline void set_allocated_unmodified_namespace_descriptor(::hbase::pb::NamespaceDescriptor* unmodified_namespace_descriptor);

  // @@protoc_insertion_point(class_scope:hbase.pb.ModifyNamespaceStateData)
 private:
  inline void set_has_namespace_descriptor();
  inline void clear_has_namespace_descriptor();
  inline void set_has_unmodified_namespace_descriptor();
  inline void clear_has_unmodified_namespace_descriptor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::NamespaceDescriptor* namespace_descriptor_;
  ::hbase::pb::NamespaceDescriptor* unmodified_namespace_descriptor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static ModifyNamespaceStateData* default_instance_;
};
// -------------------------------------------------------------------

class DeleteNamespaceStateData : public ::google::protobuf::Message {
 public:
  DeleteNamespaceStateData();
  virtual ~DeleteNamespaceStateData();

  DeleteNamespaceStateData(const DeleteNamespaceStateData& from);

  inline DeleteNamespaceStateData& operator=(const DeleteNamespaceStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteNamespaceStateData& default_instance();

  void Swap(DeleteNamespaceStateData* other);

  // implements Message ----------------------------------------------

  DeleteNamespaceStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteNamespaceStateData& from);
  void MergeFrom(const DeleteNamespaceStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string namespace_name = 1;
  inline bool has_namespace_name() const;
  inline void clear_namespace_name();
  static const int kNamespaceNameFieldNumber = 1;
  inline const ::std::string& namespace_name() const;
  inline void set_namespace_name(const ::std::string& value);
  inline void set_namespace_name(const char* value);
  inline void set_namespace_name(const char* value, size_t size);
  inline ::std::string* mutable_namespace_name();
  inline ::std::string* release_namespace_name();
  inline void set_allocated_namespace_name(::std::string* namespace_name);

  // optional .hbase.pb.NamespaceDescriptor namespace_descriptor = 2;
  inline bool has_namespace_descriptor() const;
  inline void clear_namespace_descriptor();
  static const int kNamespaceDescriptorFieldNumber = 2;
  inline const ::hbase::pb::NamespaceDescriptor& namespace_descriptor() const;
  inline ::hbase::pb::NamespaceDescriptor* mutable_namespace_descriptor();
  inline ::hbase::pb::NamespaceDescriptor* release_namespace_descriptor();
  inline void set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor);

  // @@protoc_insertion_point(class_scope:hbase.pb.DeleteNamespaceStateData)
 private:
  inline void set_has_namespace_name();
  inline void clear_has_namespace_name();
  inline void set_has_namespace_descriptor();
  inline void clear_has_namespace_descriptor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* namespace_name_;
  ::hbase::pb::NamespaceDescriptor* namespace_descriptor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static DeleteNamespaceStateData* default_instance_;
};
// -------------------------------------------------------------------

class AddColumnFamilyStateData : public ::google::protobuf::Message {
 public:
  AddColumnFamilyStateData();
  virtual ~AddColumnFamilyStateData();

  AddColumnFamilyStateData(const AddColumnFamilyStateData& from);

  inline AddColumnFamilyStateData& operator=(const AddColumnFamilyStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddColumnFamilyStateData& default_instance();

  void Swap(AddColumnFamilyStateData* other);

  // implements Message ----------------------------------------------

  AddColumnFamilyStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddColumnFamilyStateData& from);
  void MergeFrom(const AddColumnFamilyStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required .hbase.pb.ColumnFamilySchema columnfamily_schema = 3;
  inline bool has_columnfamily_schema() const;
  inline void clear_columnfamily_schema();
  static const int kColumnfamilySchemaFieldNumber = 3;
  inline const ::hbase::pb::ColumnFamilySchema& columnfamily_schema() const;
  inline ::hbase::pb::ColumnFamilySchema* mutable_columnfamily_schema();
  inline ::hbase::pb::ColumnFamilySchema* release_columnfamily_schema();
  inline void set_allocated_columnfamily_schema(::hbase::pb::ColumnFamilySchema* columnfamily_schema);

  // optional .hbase.pb.TableSchema unmodified_table_schema = 4;
  inline bool has_unmodified_table_schema() const;
  inline void clear_unmodified_table_schema();
  static const int kUnmodifiedTableSchemaFieldNumber = 4;
  inline const ::hbase::pb::TableSchema& unmodified_table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_unmodified_table_schema();
  inline ::hbase::pb::TableSchema* release_unmodified_table_schema();
  inline void set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema);

  // @@protoc_insertion_point(class_scope:hbase.pb.AddColumnFamilyStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_columnfamily_schema();
  inline void clear_has_columnfamily_schema();
  inline void set_has_unmodified_table_schema();
  inline void clear_has_unmodified_table_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  ::hbase::pb::ColumnFamilySchema* columnfamily_schema_;
  ::hbase::pb::TableSchema* unmodified_table_schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static AddColumnFamilyStateData* default_instance_;
};
// -------------------------------------------------------------------

class ModifyColumnFamilyStateData : public ::google::protobuf::Message {
 public:
  ModifyColumnFamilyStateData();
  virtual ~ModifyColumnFamilyStateData();

  ModifyColumnFamilyStateData(const ModifyColumnFamilyStateData& from);

  inline ModifyColumnFamilyStateData& operator=(const ModifyColumnFamilyStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyColumnFamilyStateData& default_instance();

  void Swap(ModifyColumnFamilyStateData* other);

  // implements Message ----------------------------------------------

  ModifyColumnFamilyStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyColumnFamilyStateData& from);
  void MergeFrom(const ModifyColumnFamilyStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required .hbase.pb.ColumnFamilySchema columnfamily_schema = 3;
  inline bool has_columnfamily_schema() const;
  inline void clear_columnfamily_schema();
  static const int kColumnfamilySchemaFieldNumber = 3;
  inline const ::hbase::pb::ColumnFamilySchema& columnfamily_schema() const;
  inline ::hbase::pb::ColumnFamilySchema* mutable_columnfamily_schema();
  inline ::hbase::pb::ColumnFamilySchema* release_columnfamily_schema();
  inline void set_allocated_columnfamily_schema(::hbase::pb::ColumnFamilySchema* columnfamily_schema);

  // optional .hbase.pb.TableSchema unmodified_table_schema = 4;
  inline bool has_unmodified_table_schema() const;
  inline void clear_unmodified_table_schema();
  static const int kUnmodifiedTableSchemaFieldNumber = 4;
  inline const ::hbase::pb::TableSchema& unmodified_table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_unmodified_table_schema();
  inline ::hbase::pb::TableSchema* release_unmodified_table_schema();
  inline void set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema);

  // @@protoc_insertion_point(class_scope:hbase.pb.ModifyColumnFamilyStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_columnfamily_schema();
  inline void clear_has_columnfamily_schema();
  inline void set_has_unmodified_table_schema();
  inline void clear_has_unmodified_table_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  ::hbase::pb::ColumnFamilySchema* columnfamily_schema_;
  ::hbase::pb::TableSchema* unmodified_table_schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static ModifyColumnFamilyStateData* default_instance_;
};
// -------------------------------------------------------------------

class DeleteColumnFamilyStateData : public ::google::protobuf::Message {
 public:
  DeleteColumnFamilyStateData();
  virtual ~DeleteColumnFamilyStateData();

  DeleteColumnFamilyStateData(const DeleteColumnFamilyStateData& from);

  inline DeleteColumnFamilyStateData& operator=(const DeleteColumnFamilyStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteColumnFamilyStateData& default_instance();

  void Swap(DeleteColumnFamilyStateData* other);

  // implements Message ----------------------------------------------

  DeleteColumnFamilyStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteColumnFamilyStateData& from);
  void MergeFrom(const DeleteColumnFamilyStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required bytes columnfamily_name = 3;
  inline bool has_columnfamily_name() const;
  inline void clear_columnfamily_name();
  static const int kColumnfamilyNameFieldNumber = 3;
  inline const ::std::string& columnfamily_name() const;
  inline void set_columnfamily_name(const ::std::string& value);
  inline void set_columnfamily_name(const char* value);
  inline void set_columnfamily_name(const void* value, size_t size);
  inline ::std::string* mutable_columnfamily_name();
  inline ::std::string* release_columnfamily_name();
  inline void set_allocated_columnfamily_name(::std::string* columnfamily_name);

  // optional .hbase.pb.TableSchema unmodified_table_schema = 4;
  inline bool has_unmodified_table_schema() const;
  inline void clear_unmodified_table_schema();
  static const int kUnmodifiedTableSchemaFieldNumber = 4;
  inline const ::hbase::pb::TableSchema& unmodified_table_schema() const;
  inline ::hbase::pb::TableSchema* mutable_unmodified_table_schema();
  inline ::hbase::pb::TableSchema* release_unmodified_table_schema();
  inline void set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema);

  // @@protoc_insertion_point(class_scope:hbase.pb.DeleteColumnFamilyStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_columnfamily_name();
  inline void clear_has_columnfamily_name();
  inline void set_has_unmodified_table_schema();
  inline void clear_has_unmodified_table_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  ::std::string* columnfamily_name_;
  ::hbase::pb::TableSchema* unmodified_table_schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static DeleteColumnFamilyStateData* default_instance_;
};
// -------------------------------------------------------------------

class EnableTableStateData : public ::google::protobuf::Message {
 public:
  EnableTableStateData();
  virtual ~EnableTableStateData();

  EnableTableStateData(const EnableTableStateData& from);

  inline EnableTableStateData& operator=(const EnableTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableTableStateData& default_instance();

  void Swap(EnableTableStateData* other);

  // implements Message ----------------------------------------------

  EnableTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableTableStateData& from);
  void MergeFrom(const EnableTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required bool skip_table_state_check = 3;
  inline bool has_skip_table_state_check() const;
  inline void clear_skip_table_state_check();
  static const int kSkipTableStateCheckFieldNumber = 3;
  inline bool skip_table_state_check() const;
  inline void set_skip_table_state_check(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.EnableTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_skip_table_state_check();
  inline void clear_has_skip_table_state_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  bool skip_table_state_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static EnableTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class DisableTableStateData : public ::google::protobuf::Message {
 public:
  DisableTableStateData();
  virtual ~DisableTableStateData();

  DisableTableStateData(const DisableTableStateData& from);

  inline DisableTableStateData& operator=(const DisableTableStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisableTableStateData& default_instance();

  void Swap(DisableTableStateData* other);

  // implements Message ----------------------------------------------

  DisableTableStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisableTableStateData& from);
  void MergeFrom(const DisableTableStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserInformation user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::hbase::pb::UserInformation& user_info() const;
  inline ::hbase::pb::UserInformation* mutable_user_info();
  inline ::hbase::pb::UserInformation* release_user_info();
  inline void set_allocated_user_info(::hbase::pb::UserInformation* user_info);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required bool skip_table_state_check = 3;
  inline bool has_skip_table_state_check() const;
  inline void clear_skip_table_state_check();
  static const int kSkipTableStateCheckFieldNumber = 3;
  inline bool skip_table_state_check() const;
  inline void set_skip_table_state_check(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DisableTableStateData)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_skip_table_state_check();
  inline void clear_has_skip_table_state_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserInformation* user_info_;
  ::hbase::pb::TableName* table_name_;
  bool skip_table_state_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static DisableTableStateData* default_instance_;
};
// -------------------------------------------------------------------

class ServerCrashStateData : public ::google::protobuf::Message {
 public:
  ServerCrashStateData();
  virtual ~ServerCrashStateData();

  ServerCrashStateData(const ServerCrashStateData& from);

  inline ServerCrashStateData& operator=(const ServerCrashStateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerCrashStateData& default_instance();

  void Swap(ServerCrashStateData* other);

  // implements Message ----------------------------------------------

  ServerCrashStateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerCrashStateData& from);
  void MergeFrom(const ServerCrashStateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.ServerName server_name = 1;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 1;
  inline const ::hbase::pb::ServerName& server_name() const;
  inline ::hbase::pb::ServerName* mutable_server_name();
  inline ::hbase::pb::ServerName* release_server_name();
  inline void set_allocated_server_name(::hbase::pb::ServerName* server_name);

  // optional bool distributed_log_replay = 2;
  inline bool has_distributed_log_replay() const;
  inline void clear_distributed_log_replay();
  static const int kDistributedLogReplayFieldNumber = 2;
  inline bool distributed_log_replay() const;
  inline void set_distributed_log_replay(bool value);

  // repeated .hbase.pb.RegionInfo regions_on_crashed_server = 3;
  inline int regions_on_crashed_server_size() const;
  inline void clear_regions_on_crashed_server();
  static const int kRegionsOnCrashedServerFieldNumber = 3;
  inline const ::hbase::pb::RegionInfo& regions_on_crashed_server(int index) const;
  inline ::hbase::pb::RegionInfo* mutable_regions_on_crashed_server(int index);
  inline ::hbase::pb::RegionInfo* add_regions_on_crashed_server();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
      regions_on_crashed_server() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
      mutable_regions_on_crashed_server();

  // repeated .hbase.pb.RegionInfo regions_assigned = 4;
  inline int regions_assigned_size() const;
  inline void clear_regions_assigned();
  static const int kRegionsAssignedFieldNumber = 4;
  inline const ::hbase::pb::RegionInfo& regions_assigned(int index) const;
  inline ::hbase::pb::RegionInfo* mutable_regions_assigned(int index);
  inline ::hbase::pb::RegionInfo* add_regions_assigned();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
      regions_assigned() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
      mutable_regions_assigned();

  // optional bool carrying_meta = 5;
  inline bool has_carrying_meta() const;
  inline void clear_carrying_meta();
  static const int kCarryingMetaFieldNumber = 5;
  inline bool carrying_meta() const;
  inline void set_carrying_meta(bool value);

  // optional bool should_split_wal = 6 [default = true];
  inline bool has_should_split_wal() const;
  inline void clear_should_split_wal();
  static const int kShouldSplitWalFieldNumber = 6;
  inline bool should_split_wal() const;
  inline void set_should_split_wal(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ServerCrashStateData)
 private:
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_distributed_log_replay();
  inline void clear_has_distributed_log_replay();
  inline void set_has_carrying_meta();
  inline void clear_has_carrying_meta();
  inline void set_has_should_split_wal();
  inline void clear_has_should_split_wal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::ServerName* server_name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo > regions_on_crashed_server_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo > regions_assigned_;
  bool distributed_log_replay_;
  bool carrying_meta_;
  bool should_split_wal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MasterProcedure_2eproto();
  friend void protobuf_AssignDesc_MasterProcedure_2eproto();
  friend void protobuf_ShutdownFile_MasterProcedure_2eproto();

  void InitAsDefaultInstance();
  static ServerCrashStateData* default_instance_;
};
// ===================================================================


// ===================================================================

// CreateTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool CreateTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& CreateTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* CreateTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* CreateTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void CreateTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableSchema table_schema = 2;
inline bool CreateTableStateData::has_table_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTableStateData::set_has_table_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTableStateData::clear_has_table_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTableStateData::clear_table_schema() {
  if (table_schema_ != NULL) table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_table_schema();
}
inline const ::hbase::pb::TableSchema& CreateTableStateData::table_schema() const {
  return table_schema_ != NULL ? *table_schema_ : *default_instance_->table_schema_;
}
inline ::hbase::pb::TableSchema* CreateTableStateData::mutable_table_schema() {
  set_has_table_schema();
  if (table_schema_ == NULL) table_schema_ = new ::hbase::pb::TableSchema;
  return table_schema_;
}
inline ::hbase::pb::TableSchema* CreateTableStateData::release_table_schema() {
  clear_has_table_schema();
  ::hbase::pb::TableSchema* temp = table_schema_;
  table_schema_ = NULL;
  return temp;
}
inline void CreateTableStateData::set_allocated_table_schema(::hbase::pb::TableSchema* table_schema) {
  delete table_schema_;
  table_schema_ = table_schema;
  if (table_schema) {
    set_has_table_schema();
  } else {
    clear_has_table_schema();
  }
}

// repeated .hbase.pb.RegionInfo region_info = 3;
inline int CreateTableStateData::region_info_size() const {
  return region_info_.size();
}
inline void CreateTableStateData::clear_region_info() {
  region_info_.Clear();
}
inline const ::hbase::pb::RegionInfo& CreateTableStateData::region_info(int index) const {
  return region_info_.Get(index);
}
inline ::hbase::pb::RegionInfo* CreateTableStateData::mutable_region_info(int index) {
  return region_info_.Mutable(index);
}
inline ::hbase::pb::RegionInfo* CreateTableStateData::add_region_info() {
  return region_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
CreateTableStateData::region_info() const {
  return region_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
CreateTableStateData::mutable_region_info() {
  return &region_info_;
}

// -------------------------------------------------------------------

// ModifyTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool ModifyTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& ModifyTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* ModifyTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* ModifyTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void ModifyTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// optional .hbase.pb.TableSchema unmodified_table_schema = 2;
inline bool ModifyTableStateData::has_unmodified_table_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyTableStateData::set_has_unmodified_table_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyTableStateData::clear_has_unmodified_table_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyTableStateData::clear_unmodified_table_schema() {
  if (unmodified_table_schema_ != NULL) unmodified_table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_unmodified_table_schema();
}
inline const ::hbase::pb::TableSchema& ModifyTableStateData::unmodified_table_schema() const {
  return unmodified_table_schema_ != NULL ? *unmodified_table_schema_ : *default_instance_->unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyTableStateData::mutable_unmodified_table_schema() {
  set_has_unmodified_table_schema();
  if (unmodified_table_schema_ == NULL) unmodified_table_schema_ = new ::hbase::pb::TableSchema;
  return unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyTableStateData::release_unmodified_table_schema() {
  clear_has_unmodified_table_schema();
  ::hbase::pb::TableSchema* temp = unmodified_table_schema_;
  unmodified_table_schema_ = NULL;
  return temp;
}
inline void ModifyTableStateData::set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema) {
  delete unmodified_table_schema_;
  unmodified_table_schema_ = unmodified_table_schema;
  if (unmodified_table_schema) {
    set_has_unmodified_table_schema();
  } else {
    clear_has_unmodified_table_schema();
  }
}

// required .hbase.pb.TableSchema modified_table_schema = 3;
inline bool ModifyTableStateData::has_modified_table_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyTableStateData::set_has_modified_table_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyTableStateData::clear_has_modified_table_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyTableStateData::clear_modified_table_schema() {
  if (modified_table_schema_ != NULL) modified_table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_modified_table_schema();
}
inline const ::hbase::pb::TableSchema& ModifyTableStateData::modified_table_schema() const {
  return modified_table_schema_ != NULL ? *modified_table_schema_ : *default_instance_->modified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyTableStateData::mutable_modified_table_schema() {
  set_has_modified_table_schema();
  if (modified_table_schema_ == NULL) modified_table_schema_ = new ::hbase::pb::TableSchema;
  return modified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyTableStateData::release_modified_table_schema() {
  clear_has_modified_table_schema();
  ::hbase::pb::TableSchema* temp = modified_table_schema_;
  modified_table_schema_ = NULL;
  return temp;
}
inline void ModifyTableStateData::set_allocated_modified_table_schema(::hbase::pb::TableSchema* modified_table_schema) {
  delete modified_table_schema_;
  modified_table_schema_ = modified_table_schema;
  if (modified_table_schema) {
    set_has_modified_table_schema();
  } else {
    clear_has_modified_table_schema();
  }
}

// required bool delete_column_family_in_modify = 4;
inline bool ModifyTableStateData::has_delete_column_family_in_modify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyTableStateData::set_has_delete_column_family_in_modify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyTableStateData::clear_has_delete_column_family_in_modify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyTableStateData::clear_delete_column_family_in_modify() {
  delete_column_family_in_modify_ = false;
  clear_has_delete_column_family_in_modify();
}
inline bool ModifyTableStateData::delete_column_family_in_modify() const {
  return delete_column_family_in_modify_;
}
inline void ModifyTableStateData::set_delete_column_family_in_modify(bool value) {
  set_has_delete_column_family_in_modify();
  delete_column_family_in_modify_ = value;
}

// -------------------------------------------------------------------

// TruncateTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool TruncateTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& TruncateTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* TruncateTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* TruncateTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void TruncateTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required bool preserve_splits = 2;
inline bool TruncateTableStateData::has_preserve_splits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TruncateTableStateData::set_has_preserve_splits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TruncateTableStateData::clear_has_preserve_splits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TruncateTableStateData::clear_preserve_splits() {
  preserve_splits_ = false;
  clear_has_preserve_splits();
}
inline bool TruncateTableStateData::preserve_splits() const {
  return preserve_splits_;
}
inline void TruncateTableStateData::set_preserve_splits(bool value) {
  set_has_preserve_splits();
  preserve_splits_ = value;
}

// optional .hbase.pb.TableName table_name = 3;
inline bool TruncateTableStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TruncateTableStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TruncateTableStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TruncateTableStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& TruncateTableStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* TruncateTableStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* TruncateTableStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void TruncateTableStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// optional .hbase.pb.TableSchema table_schema = 4;
inline bool TruncateTableStateData::has_table_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TruncateTableStateData::set_has_table_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TruncateTableStateData::clear_has_table_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TruncateTableStateData::clear_table_schema() {
  if (table_schema_ != NULL) table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_table_schema();
}
inline const ::hbase::pb::TableSchema& TruncateTableStateData::table_schema() const {
  return table_schema_ != NULL ? *table_schema_ : *default_instance_->table_schema_;
}
inline ::hbase::pb::TableSchema* TruncateTableStateData::mutable_table_schema() {
  set_has_table_schema();
  if (table_schema_ == NULL) table_schema_ = new ::hbase::pb::TableSchema;
  return table_schema_;
}
inline ::hbase::pb::TableSchema* TruncateTableStateData::release_table_schema() {
  clear_has_table_schema();
  ::hbase::pb::TableSchema* temp = table_schema_;
  table_schema_ = NULL;
  return temp;
}
inline void TruncateTableStateData::set_allocated_table_schema(::hbase::pb::TableSchema* table_schema) {
  delete table_schema_;
  table_schema_ = table_schema;
  if (table_schema) {
    set_has_table_schema();
  } else {
    clear_has_table_schema();
  }
}

// repeated .hbase.pb.RegionInfo region_info = 5;
inline int TruncateTableStateData::region_info_size() const {
  return region_info_.size();
}
inline void TruncateTableStateData::clear_region_info() {
  region_info_.Clear();
}
inline const ::hbase::pb::RegionInfo& TruncateTableStateData::region_info(int index) const {
  return region_info_.Get(index);
}
inline ::hbase::pb::RegionInfo* TruncateTableStateData::mutable_region_info(int index) {
  return region_info_.Mutable(index);
}
inline ::hbase::pb::RegionInfo* TruncateTableStateData::add_region_info() {
  return region_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
TruncateTableStateData::region_info() const {
  return region_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
TruncateTableStateData::mutable_region_info() {
  return &region_info_;
}

// -------------------------------------------------------------------

// DeleteTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool DeleteTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& DeleteTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* DeleteTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* DeleteTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void DeleteTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool DeleteTableStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteTableStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteTableStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteTableStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& DeleteTableStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* DeleteTableStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* DeleteTableStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void DeleteTableStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// repeated .hbase.pb.RegionInfo region_info = 3;
inline int DeleteTableStateData::region_info_size() const {
  return region_info_.size();
}
inline void DeleteTableStateData::clear_region_info() {
  region_info_.Clear();
}
inline const ::hbase::pb::RegionInfo& DeleteTableStateData::region_info(int index) const {
  return region_info_.Get(index);
}
inline ::hbase::pb::RegionInfo* DeleteTableStateData::mutable_region_info(int index) {
  return region_info_.Mutable(index);
}
inline ::hbase::pb::RegionInfo* DeleteTableStateData::add_region_info() {
  return region_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
DeleteTableStateData::region_info() const {
  return region_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
DeleteTableStateData::mutable_region_info() {
  return &region_info_;
}

// -------------------------------------------------------------------

// CreateNamespaceStateData

// required .hbase.pb.NamespaceDescriptor namespace_descriptor = 1;
inline bool CreateNamespaceStateData::has_namespace_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNamespaceStateData::set_has_namespace_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNamespaceStateData::clear_has_namespace_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNamespaceStateData::clear_namespace_descriptor() {
  if (namespace_descriptor_ != NULL) namespace_descriptor_->::hbase::pb::NamespaceDescriptor::Clear();
  clear_has_namespace_descriptor();
}
inline const ::hbase::pb::NamespaceDescriptor& CreateNamespaceStateData::namespace_descriptor() const {
  return namespace_descriptor_ != NULL ? *namespace_descriptor_ : *default_instance_->namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* CreateNamespaceStateData::mutable_namespace_descriptor() {
  set_has_namespace_descriptor();
  if (namespace_descriptor_ == NULL) namespace_descriptor_ = new ::hbase::pb::NamespaceDescriptor;
  return namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* CreateNamespaceStateData::release_namespace_descriptor() {
  clear_has_namespace_descriptor();
  ::hbase::pb::NamespaceDescriptor* temp = namespace_descriptor_;
  namespace_descriptor_ = NULL;
  return temp;
}
inline void CreateNamespaceStateData::set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor) {
  delete namespace_descriptor_;
  namespace_descriptor_ = namespace_descriptor;
  if (namespace_descriptor) {
    set_has_namespace_descriptor();
  } else {
    clear_has_namespace_descriptor();
  }
}

// -------------------------------------------------------------------

// ModifyNamespaceStateData

// required .hbase.pb.NamespaceDescriptor namespace_descriptor = 1;
inline bool ModifyNamespaceStateData::has_namespace_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyNamespaceStateData::set_has_namespace_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyNamespaceStateData::clear_has_namespace_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyNamespaceStateData::clear_namespace_descriptor() {
  if (namespace_descriptor_ != NULL) namespace_descriptor_->::hbase::pb::NamespaceDescriptor::Clear();
  clear_has_namespace_descriptor();
}
inline const ::hbase::pb::NamespaceDescriptor& ModifyNamespaceStateData::namespace_descriptor() const {
  return namespace_descriptor_ != NULL ? *namespace_descriptor_ : *default_instance_->namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* ModifyNamespaceStateData::mutable_namespace_descriptor() {
  set_has_namespace_descriptor();
  if (namespace_descriptor_ == NULL) namespace_descriptor_ = new ::hbase::pb::NamespaceDescriptor;
  return namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* ModifyNamespaceStateData::release_namespace_descriptor() {
  clear_has_namespace_descriptor();
  ::hbase::pb::NamespaceDescriptor* temp = namespace_descriptor_;
  namespace_descriptor_ = NULL;
  return temp;
}
inline void ModifyNamespaceStateData::set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor) {
  delete namespace_descriptor_;
  namespace_descriptor_ = namespace_descriptor;
  if (namespace_descriptor) {
    set_has_namespace_descriptor();
  } else {
    clear_has_namespace_descriptor();
  }
}

// optional .hbase.pb.NamespaceDescriptor unmodified_namespace_descriptor = 2;
inline bool ModifyNamespaceStateData::has_unmodified_namespace_descriptor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyNamespaceStateData::set_has_unmodified_namespace_descriptor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyNamespaceStateData::clear_has_unmodified_namespace_descriptor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyNamespaceStateData::clear_unmodified_namespace_descriptor() {
  if (unmodified_namespace_descriptor_ != NULL) unmodified_namespace_descriptor_->::hbase::pb::NamespaceDescriptor::Clear();
  clear_has_unmodified_namespace_descriptor();
}
inline const ::hbase::pb::NamespaceDescriptor& ModifyNamespaceStateData::unmodified_namespace_descriptor() const {
  return unmodified_namespace_descriptor_ != NULL ? *unmodified_namespace_descriptor_ : *default_instance_->unmodified_namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* ModifyNamespaceStateData::mutable_unmodified_namespace_descriptor() {
  set_has_unmodified_namespace_descriptor();
  if (unmodified_namespace_descriptor_ == NULL) unmodified_namespace_descriptor_ = new ::hbase::pb::NamespaceDescriptor;
  return unmodified_namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* ModifyNamespaceStateData::release_unmodified_namespace_descriptor() {
  clear_has_unmodified_namespace_descriptor();
  ::hbase::pb::NamespaceDescriptor* temp = unmodified_namespace_descriptor_;
  unmodified_namespace_descriptor_ = NULL;
  return temp;
}
inline void ModifyNamespaceStateData::set_allocated_unmodified_namespace_descriptor(::hbase::pb::NamespaceDescriptor* unmodified_namespace_descriptor) {
  delete unmodified_namespace_descriptor_;
  unmodified_namespace_descriptor_ = unmodified_namespace_descriptor;
  if (unmodified_namespace_descriptor) {
    set_has_unmodified_namespace_descriptor();
  } else {
    clear_has_unmodified_namespace_descriptor();
  }
}

// -------------------------------------------------------------------

// DeleteNamespaceStateData

// required string namespace_name = 1;
inline bool DeleteNamespaceStateData::has_namespace_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteNamespaceStateData::set_has_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteNamespaceStateData::clear_has_namespace_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteNamespaceStateData::clear_namespace_name() {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    namespace_name_->clear();
  }
  clear_has_namespace_name();
}
inline const ::std::string& DeleteNamespaceStateData::namespace_name() const {
  return *namespace_name_;
}
inline void DeleteNamespaceStateData::set_namespace_name(const ::std::string& value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void DeleteNamespaceStateData::set_namespace_name(const char* value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void DeleteNamespaceStateData::set_namespace_name(const char* value, size_t size) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteNamespaceStateData::mutable_namespace_name() {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  return namespace_name_;
}
inline ::std::string* DeleteNamespaceStateData::release_namespace_name() {
  clear_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace_name_;
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteNamespaceStateData::set_allocated_namespace_name(::std::string* namespace_name) {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    delete namespace_name_;
  }
  if (namespace_name) {
    set_has_namespace_name();
    namespace_name_ = namespace_name;
  } else {
    clear_has_namespace_name();
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .hbase.pb.NamespaceDescriptor namespace_descriptor = 2;
inline bool DeleteNamespaceStateData::has_namespace_descriptor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteNamespaceStateData::set_has_namespace_descriptor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteNamespaceStateData::clear_has_namespace_descriptor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteNamespaceStateData::clear_namespace_descriptor() {
  if (namespace_descriptor_ != NULL) namespace_descriptor_->::hbase::pb::NamespaceDescriptor::Clear();
  clear_has_namespace_descriptor();
}
inline const ::hbase::pb::NamespaceDescriptor& DeleteNamespaceStateData::namespace_descriptor() const {
  return namespace_descriptor_ != NULL ? *namespace_descriptor_ : *default_instance_->namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* DeleteNamespaceStateData::mutable_namespace_descriptor() {
  set_has_namespace_descriptor();
  if (namespace_descriptor_ == NULL) namespace_descriptor_ = new ::hbase::pb::NamespaceDescriptor;
  return namespace_descriptor_;
}
inline ::hbase::pb::NamespaceDescriptor* DeleteNamespaceStateData::release_namespace_descriptor() {
  clear_has_namespace_descriptor();
  ::hbase::pb::NamespaceDescriptor* temp = namespace_descriptor_;
  namespace_descriptor_ = NULL;
  return temp;
}
inline void DeleteNamespaceStateData::set_allocated_namespace_descriptor(::hbase::pb::NamespaceDescriptor* namespace_descriptor) {
  delete namespace_descriptor_;
  namespace_descriptor_ = namespace_descriptor;
  if (namespace_descriptor) {
    set_has_namespace_descriptor();
  } else {
    clear_has_namespace_descriptor();
  }
}

// -------------------------------------------------------------------

// AddColumnFamilyStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool AddColumnFamilyStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddColumnFamilyStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddColumnFamilyStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddColumnFamilyStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& AddColumnFamilyStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* AddColumnFamilyStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* AddColumnFamilyStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void AddColumnFamilyStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool AddColumnFamilyStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddColumnFamilyStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddColumnFamilyStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddColumnFamilyStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& AddColumnFamilyStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* AddColumnFamilyStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* AddColumnFamilyStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void AddColumnFamilyStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required .hbase.pb.ColumnFamilySchema columnfamily_schema = 3;
inline bool AddColumnFamilyStateData::has_columnfamily_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddColumnFamilyStateData::set_has_columnfamily_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddColumnFamilyStateData::clear_has_columnfamily_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddColumnFamilyStateData::clear_columnfamily_schema() {
  if (columnfamily_schema_ != NULL) columnfamily_schema_->::hbase::pb::ColumnFamilySchema::Clear();
  clear_has_columnfamily_schema();
}
inline const ::hbase::pb::ColumnFamilySchema& AddColumnFamilyStateData::columnfamily_schema() const {
  return columnfamily_schema_ != NULL ? *columnfamily_schema_ : *default_instance_->columnfamily_schema_;
}
inline ::hbase::pb::ColumnFamilySchema* AddColumnFamilyStateData::mutable_columnfamily_schema() {
  set_has_columnfamily_schema();
  if (columnfamily_schema_ == NULL) columnfamily_schema_ = new ::hbase::pb::ColumnFamilySchema;
  return columnfamily_schema_;
}
inline ::hbase::pb::ColumnFamilySchema* AddColumnFamilyStateData::release_columnfamily_schema() {
  clear_has_columnfamily_schema();
  ::hbase::pb::ColumnFamilySchema* temp = columnfamily_schema_;
  columnfamily_schema_ = NULL;
  return temp;
}
inline void AddColumnFamilyStateData::set_allocated_columnfamily_schema(::hbase::pb::ColumnFamilySchema* columnfamily_schema) {
  delete columnfamily_schema_;
  columnfamily_schema_ = columnfamily_schema;
  if (columnfamily_schema) {
    set_has_columnfamily_schema();
  } else {
    clear_has_columnfamily_schema();
  }
}

// optional .hbase.pb.TableSchema unmodified_table_schema = 4;
inline bool AddColumnFamilyStateData::has_unmodified_table_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddColumnFamilyStateData::set_has_unmodified_table_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddColumnFamilyStateData::clear_has_unmodified_table_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddColumnFamilyStateData::clear_unmodified_table_schema() {
  if (unmodified_table_schema_ != NULL) unmodified_table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_unmodified_table_schema();
}
inline const ::hbase::pb::TableSchema& AddColumnFamilyStateData::unmodified_table_schema() const {
  return unmodified_table_schema_ != NULL ? *unmodified_table_schema_ : *default_instance_->unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* AddColumnFamilyStateData::mutable_unmodified_table_schema() {
  set_has_unmodified_table_schema();
  if (unmodified_table_schema_ == NULL) unmodified_table_schema_ = new ::hbase::pb::TableSchema;
  return unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* AddColumnFamilyStateData::release_unmodified_table_schema() {
  clear_has_unmodified_table_schema();
  ::hbase::pb::TableSchema* temp = unmodified_table_schema_;
  unmodified_table_schema_ = NULL;
  return temp;
}
inline void AddColumnFamilyStateData::set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema) {
  delete unmodified_table_schema_;
  unmodified_table_schema_ = unmodified_table_schema;
  if (unmodified_table_schema) {
    set_has_unmodified_table_schema();
  } else {
    clear_has_unmodified_table_schema();
  }
}

// -------------------------------------------------------------------

// ModifyColumnFamilyStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool ModifyColumnFamilyStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyColumnFamilyStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyColumnFamilyStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyColumnFamilyStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& ModifyColumnFamilyStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* ModifyColumnFamilyStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* ModifyColumnFamilyStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void ModifyColumnFamilyStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool ModifyColumnFamilyStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyColumnFamilyStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyColumnFamilyStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyColumnFamilyStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& ModifyColumnFamilyStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* ModifyColumnFamilyStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* ModifyColumnFamilyStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ModifyColumnFamilyStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required .hbase.pb.ColumnFamilySchema columnfamily_schema = 3;
inline bool ModifyColumnFamilyStateData::has_columnfamily_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyColumnFamilyStateData::set_has_columnfamily_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyColumnFamilyStateData::clear_has_columnfamily_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyColumnFamilyStateData::clear_columnfamily_schema() {
  if (columnfamily_schema_ != NULL) columnfamily_schema_->::hbase::pb::ColumnFamilySchema::Clear();
  clear_has_columnfamily_schema();
}
inline const ::hbase::pb::ColumnFamilySchema& ModifyColumnFamilyStateData::columnfamily_schema() const {
  return columnfamily_schema_ != NULL ? *columnfamily_schema_ : *default_instance_->columnfamily_schema_;
}
inline ::hbase::pb::ColumnFamilySchema* ModifyColumnFamilyStateData::mutable_columnfamily_schema() {
  set_has_columnfamily_schema();
  if (columnfamily_schema_ == NULL) columnfamily_schema_ = new ::hbase::pb::ColumnFamilySchema;
  return columnfamily_schema_;
}
inline ::hbase::pb::ColumnFamilySchema* ModifyColumnFamilyStateData::release_columnfamily_schema() {
  clear_has_columnfamily_schema();
  ::hbase::pb::ColumnFamilySchema* temp = columnfamily_schema_;
  columnfamily_schema_ = NULL;
  return temp;
}
inline void ModifyColumnFamilyStateData::set_allocated_columnfamily_schema(::hbase::pb::ColumnFamilySchema* columnfamily_schema) {
  delete columnfamily_schema_;
  columnfamily_schema_ = columnfamily_schema;
  if (columnfamily_schema) {
    set_has_columnfamily_schema();
  } else {
    clear_has_columnfamily_schema();
  }
}

// optional .hbase.pb.TableSchema unmodified_table_schema = 4;
inline bool ModifyColumnFamilyStateData::has_unmodified_table_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyColumnFamilyStateData::set_has_unmodified_table_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyColumnFamilyStateData::clear_has_unmodified_table_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyColumnFamilyStateData::clear_unmodified_table_schema() {
  if (unmodified_table_schema_ != NULL) unmodified_table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_unmodified_table_schema();
}
inline const ::hbase::pb::TableSchema& ModifyColumnFamilyStateData::unmodified_table_schema() const {
  return unmodified_table_schema_ != NULL ? *unmodified_table_schema_ : *default_instance_->unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyColumnFamilyStateData::mutable_unmodified_table_schema() {
  set_has_unmodified_table_schema();
  if (unmodified_table_schema_ == NULL) unmodified_table_schema_ = new ::hbase::pb::TableSchema;
  return unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* ModifyColumnFamilyStateData::release_unmodified_table_schema() {
  clear_has_unmodified_table_schema();
  ::hbase::pb::TableSchema* temp = unmodified_table_schema_;
  unmodified_table_schema_ = NULL;
  return temp;
}
inline void ModifyColumnFamilyStateData::set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema) {
  delete unmodified_table_schema_;
  unmodified_table_schema_ = unmodified_table_schema;
  if (unmodified_table_schema) {
    set_has_unmodified_table_schema();
  } else {
    clear_has_unmodified_table_schema();
  }
}

// -------------------------------------------------------------------

// DeleteColumnFamilyStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool DeleteColumnFamilyStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteColumnFamilyStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteColumnFamilyStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteColumnFamilyStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& DeleteColumnFamilyStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* DeleteColumnFamilyStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* DeleteColumnFamilyStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void DeleteColumnFamilyStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool DeleteColumnFamilyStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteColumnFamilyStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteColumnFamilyStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteColumnFamilyStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& DeleteColumnFamilyStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* DeleteColumnFamilyStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* DeleteColumnFamilyStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void DeleteColumnFamilyStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required bytes columnfamily_name = 3;
inline bool DeleteColumnFamilyStateData::has_columnfamily_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteColumnFamilyStateData::set_has_columnfamily_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteColumnFamilyStateData::clear_has_columnfamily_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteColumnFamilyStateData::clear_columnfamily_name() {
  if (columnfamily_name_ != &::google::protobuf::internal::kEmptyString) {
    columnfamily_name_->clear();
  }
  clear_has_columnfamily_name();
}
inline const ::std::string& DeleteColumnFamilyStateData::columnfamily_name() const {
  return *columnfamily_name_;
}
inline void DeleteColumnFamilyStateData::set_columnfamily_name(const ::std::string& value) {
  set_has_columnfamily_name();
  if (columnfamily_name_ == &::google::protobuf::internal::kEmptyString) {
    columnfamily_name_ = new ::std::string;
  }
  columnfamily_name_->assign(value);
}
inline void DeleteColumnFamilyStateData::set_columnfamily_name(const char* value) {
  set_has_columnfamily_name();
  if (columnfamily_name_ == &::google::protobuf::internal::kEmptyString) {
    columnfamily_name_ = new ::std::string;
  }
  columnfamily_name_->assign(value);
}
inline void DeleteColumnFamilyStateData::set_columnfamily_name(const void* value, size_t size) {
  set_has_columnfamily_name();
  if (columnfamily_name_ == &::google::protobuf::internal::kEmptyString) {
    columnfamily_name_ = new ::std::string;
  }
  columnfamily_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteColumnFamilyStateData::mutable_columnfamily_name() {
  set_has_columnfamily_name();
  if (columnfamily_name_ == &::google::protobuf::internal::kEmptyString) {
    columnfamily_name_ = new ::std::string;
  }
  return columnfamily_name_;
}
inline ::std::string* DeleteColumnFamilyStateData::release_columnfamily_name() {
  clear_has_columnfamily_name();
  if (columnfamily_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = columnfamily_name_;
    columnfamily_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteColumnFamilyStateData::set_allocated_columnfamily_name(::std::string* columnfamily_name) {
  if (columnfamily_name_ != &::google::protobuf::internal::kEmptyString) {
    delete columnfamily_name_;
  }
  if (columnfamily_name) {
    set_has_columnfamily_name();
    columnfamily_name_ = columnfamily_name;
  } else {
    clear_has_columnfamily_name();
    columnfamily_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .hbase.pb.TableSchema unmodified_table_schema = 4;
inline bool DeleteColumnFamilyStateData::has_unmodified_table_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteColumnFamilyStateData::set_has_unmodified_table_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteColumnFamilyStateData::clear_has_unmodified_table_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteColumnFamilyStateData::clear_unmodified_table_schema() {
  if (unmodified_table_schema_ != NULL) unmodified_table_schema_->::hbase::pb::TableSchema::Clear();
  clear_has_unmodified_table_schema();
}
inline const ::hbase::pb::TableSchema& DeleteColumnFamilyStateData::unmodified_table_schema() const {
  return unmodified_table_schema_ != NULL ? *unmodified_table_schema_ : *default_instance_->unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* DeleteColumnFamilyStateData::mutable_unmodified_table_schema() {
  set_has_unmodified_table_schema();
  if (unmodified_table_schema_ == NULL) unmodified_table_schema_ = new ::hbase::pb::TableSchema;
  return unmodified_table_schema_;
}
inline ::hbase::pb::TableSchema* DeleteColumnFamilyStateData::release_unmodified_table_schema() {
  clear_has_unmodified_table_schema();
  ::hbase::pb::TableSchema* temp = unmodified_table_schema_;
  unmodified_table_schema_ = NULL;
  return temp;
}
inline void DeleteColumnFamilyStateData::set_allocated_unmodified_table_schema(::hbase::pb::TableSchema* unmodified_table_schema) {
  delete unmodified_table_schema_;
  unmodified_table_schema_ = unmodified_table_schema;
  if (unmodified_table_schema) {
    set_has_unmodified_table_schema();
  } else {
    clear_has_unmodified_table_schema();
  }
}

// -------------------------------------------------------------------

// EnableTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool EnableTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& EnableTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* EnableTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* EnableTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void EnableTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool EnableTableStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableTableStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableTableStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableTableStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& EnableTableStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* EnableTableStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* EnableTableStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void EnableTableStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required bool skip_table_state_check = 3;
inline bool EnableTableStateData::has_skip_table_state_check() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnableTableStateData::set_has_skip_table_state_check() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnableTableStateData::clear_has_skip_table_state_check() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnableTableStateData::clear_skip_table_state_check() {
  skip_table_state_check_ = false;
  clear_has_skip_table_state_check();
}
inline bool EnableTableStateData::skip_table_state_check() const {
  return skip_table_state_check_;
}
inline void EnableTableStateData::set_skip_table_state_check(bool value) {
  set_has_skip_table_state_check();
  skip_table_state_check_ = value;
}

// -------------------------------------------------------------------

// DisableTableStateData

// required .hbase.pb.UserInformation user_info = 1;
inline bool DisableTableStateData::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisableTableStateData::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisableTableStateData::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisableTableStateData::clear_user_info() {
  if (user_info_ != NULL) user_info_->::hbase::pb::UserInformation::Clear();
  clear_has_user_info();
}
inline const ::hbase::pb::UserInformation& DisableTableStateData::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::hbase::pb::UserInformation* DisableTableStateData::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::hbase::pb::UserInformation;
  return user_info_;
}
inline ::hbase::pb::UserInformation* DisableTableStateData::release_user_info() {
  clear_has_user_info();
  ::hbase::pb::UserInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void DisableTableStateData::set_allocated_user_info(::hbase::pb::UserInformation* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// required .hbase.pb.TableName table_name = 2;
inline bool DisableTableStateData::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisableTableStateData::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisableTableStateData::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisableTableStateData::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& DisableTableStateData::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* DisableTableStateData::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* DisableTableStateData::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void DisableTableStateData::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// required bool skip_table_state_check = 3;
inline bool DisableTableStateData::has_skip_table_state_check() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisableTableStateData::set_has_skip_table_state_check() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisableTableStateData::clear_has_skip_table_state_check() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisableTableStateData::clear_skip_table_state_check() {
  skip_table_state_check_ = false;
  clear_has_skip_table_state_check();
}
inline bool DisableTableStateData::skip_table_state_check() const {
  return skip_table_state_check_;
}
inline void DisableTableStateData::set_skip_table_state_check(bool value) {
  set_has_skip_table_state_check();
  skip_table_state_check_ = value;
}

// -------------------------------------------------------------------

// ServerCrashStateData

// required .hbase.pb.ServerName server_name = 1;
inline bool ServerCrashStateData::has_server_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerCrashStateData::set_has_server_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerCrashStateData::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerCrashStateData::clear_server_name() {
  if (server_name_ != NULL) server_name_->::hbase::pb::ServerName::Clear();
  clear_has_server_name();
}
inline const ::hbase::pb::ServerName& ServerCrashStateData::server_name() const {
  return server_name_ != NULL ? *server_name_ : *default_instance_->server_name_;
}
inline ::hbase::pb::ServerName* ServerCrashStateData::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == NULL) server_name_ = new ::hbase::pb::ServerName;
  return server_name_;
}
inline ::hbase::pb::ServerName* ServerCrashStateData::release_server_name() {
  clear_has_server_name();
  ::hbase::pb::ServerName* temp = server_name_;
  server_name_ = NULL;
  return temp;
}
inline void ServerCrashStateData::set_allocated_server_name(::hbase::pb::ServerName* server_name) {
  delete server_name_;
  server_name_ = server_name;
  if (server_name) {
    set_has_server_name();
  } else {
    clear_has_server_name();
  }
}

// optional bool distributed_log_replay = 2;
inline bool ServerCrashStateData::has_distributed_log_replay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerCrashStateData::set_has_distributed_log_replay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerCrashStateData::clear_has_distributed_log_replay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerCrashStateData::clear_distributed_log_replay() {
  distributed_log_replay_ = false;
  clear_has_distributed_log_replay();
}
inline bool ServerCrashStateData::distributed_log_replay() const {
  return distributed_log_replay_;
}
inline void ServerCrashStateData::set_distributed_log_replay(bool value) {
  set_has_distributed_log_replay();
  distributed_log_replay_ = value;
}

// repeated .hbase.pb.RegionInfo regions_on_crashed_server = 3;
inline int ServerCrashStateData::regions_on_crashed_server_size() const {
  return regions_on_crashed_server_.size();
}
inline void ServerCrashStateData::clear_regions_on_crashed_server() {
  regions_on_crashed_server_.Clear();
}
inline const ::hbase::pb::RegionInfo& ServerCrashStateData::regions_on_crashed_server(int index) const {
  return regions_on_crashed_server_.Get(index);
}
inline ::hbase::pb::RegionInfo* ServerCrashStateData::mutable_regions_on_crashed_server(int index) {
  return regions_on_crashed_server_.Mutable(index);
}
inline ::hbase::pb::RegionInfo* ServerCrashStateData::add_regions_on_crashed_server() {
  return regions_on_crashed_server_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
ServerCrashStateData::regions_on_crashed_server() const {
  return regions_on_crashed_server_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
ServerCrashStateData::mutable_regions_on_crashed_server() {
  return &regions_on_crashed_server_;
}

// repeated .hbase.pb.RegionInfo regions_assigned = 4;
inline int ServerCrashStateData::regions_assigned_size() const {
  return regions_assigned_.size();
}
inline void ServerCrashStateData::clear_regions_assigned() {
  regions_assigned_.Clear();
}
inline const ::hbase::pb::RegionInfo& ServerCrashStateData::regions_assigned(int index) const {
  return regions_assigned_.Get(index);
}
inline ::hbase::pb::RegionInfo* ServerCrashStateData::mutable_regions_assigned(int index) {
  return regions_assigned_.Mutable(index);
}
inline ::hbase::pb::RegionInfo* ServerCrashStateData::add_regions_assigned() {
  return regions_assigned_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >&
ServerCrashStateData::regions_assigned() const {
  return regions_assigned_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionInfo >*
ServerCrashStateData::mutable_regions_assigned() {
  return &regions_assigned_;
}

// optional bool carrying_meta = 5;
inline bool ServerCrashStateData::has_carrying_meta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerCrashStateData::set_has_carrying_meta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerCrashStateData::clear_has_carrying_meta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerCrashStateData::clear_carrying_meta() {
  carrying_meta_ = false;
  clear_has_carrying_meta();
}
inline bool ServerCrashStateData::carrying_meta() const {
  return carrying_meta_;
}
inline void ServerCrashStateData::set_carrying_meta(bool value) {
  set_has_carrying_meta();
  carrying_meta_ = value;
}

// optional bool should_split_wal = 6 [default = true];
inline bool ServerCrashStateData::has_should_split_wal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerCrashStateData::set_has_should_split_wal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerCrashStateData::clear_has_should_split_wal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerCrashStateData::clear_should_split_wal() {
  should_split_wal_ = true;
  clear_has_should_split_wal();
}
inline bool ServerCrashStateData::should_split_wal() const {
  return should_split_wal_;
}
inline void ServerCrashStateData::set_should_split_wal(bool value) {
  set_has_should_split_wal();
  should_split_wal_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::CreateTableState>() {
  return ::hbase::pb::CreateTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ModifyTableState>() {
  return ::hbase::pb::ModifyTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::TruncateTableState>() {
  return ::hbase::pb::TruncateTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DeleteTableState>() {
  return ::hbase::pb::DeleteTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::CreateNamespaceState>() {
  return ::hbase::pb::CreateNamespaceState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ModifyNamespaceState>() {
  return ::hbase::pb::ModifyNamespaceState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DeleteNamespaceState>() {
  return ::hbase::pb::DeleteNamespaceState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::AddColumnFamilyState>() {
  return ::hbase::pb::AddColumnFamilyState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ModifyColumnFamilyState>() {
  return ::hbase::pb::ModifyColumnFamilyState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DeleteColumnFamilyState>() {
  return ::hbase::pb::DeleteColumnFamilyState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::EnableTableState>() {
  return ::hbase::pb::EnableTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DisableTableState>() {
  return ::hbase::pb::DisableTableState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ServerCrashState>() {
  return ::hbase::pb::ServerCrashState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MasterProcedure_2eproto__INCLUDED
