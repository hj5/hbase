// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AccessControl.proto

#ifndef PROTOBUF_AccessControl_2eproto__INCLUDED
#define PROTOBUF_AccessControl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AccessControl_2eproto();
void protobuf_AssignDesc_AccessControl_2eproto();
void protobuf_ShutdownFile_AccessControl_2eproto();

class Permission;
class TablePermission;
class NamespacePermission;
class GlobalPermission;
class UserPermission;
class UsersAndPermissions;
class UsersAndPermissions_UserPermissions;
class GrantRequest;
class GrantResponse;
class RevokeRequest;
class RevokeResponse;
class GetUserPermissionsRequest;
class GetUserPermissionsResponse;
class CheckPermissionsRequest;
class CheckPermissionsResponse;

enum Permission_Action {
  Permission_Action_READ = 0,
  Permission_Action_WRITE = 1,
  Permission_Action_EXEC = 2,
  Permission_Action_CREATE = 3,
  Permission_Action_ADMIN = 4
};
bool Permission_Action_IsValid(int value);
const Permission_Action Permission_Action_Action_MIN = Permission_Action_READ;
const Permission_Action Permission_Action_Action_MAX = Permission_Action_ADMIN;
const int Permission_Action_Action_ARRAYSIZE = Permission_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Permission_Action_descriptor();
inline const ::std::string& Permission_Action_Name(Permission_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Permission_Action_descriptor(), value);
}
inline bool Permission_Action_Parse(
    const ::std::string& name, Permission_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Permission_Action>(
    Permission_Action_descriptor(), name, value);
}
enum Permission_Type {
  Permission_Type_Global = 1,
  Permission_Type_Namespace = 2,
  Permission_Type_Table = 3
};
bool Permission_Type_IsValid(int value);
const Permission_Type Permission_Type_Type_MIN = Permission_Type_Global;
const Permission_Type Permission_Type_Type_MAX = Permission_Type_Table;
const int Permission_Type_Type_ARRAYSIZE = Permission_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Permission_Type_descriptor();
inline const ::std::string& Permission_Type_Name(Permission_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Permission_Type_descriptor(), value);
}
inline bool Permission_Type_Parse(
    const ::std::string& name, Permission_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Permission_Type>(
    Permission_Type_descriptor(), name, value);
}
// ===================================================================

class Permission : public ::google::protobuf::Message {
 public:
  Permission();
  virtual ~Permission();

  Permission(const Permission& from);

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Permission& default_instance();

  void Swap(Permission* other);

  // implements Message ----------------------------------------------

  Permission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Permission& from);
  void MergeFrom(const Permission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Permission_Action Action;
  static const Action READ = Permission_Action_READ;
  static const Action WRITE = Permission_Action_WRITE;
  static const Action EXEC = Permission_Action_EXEC;
  static const Action CREATE = Permission_Action_CREATE;
  static const Action ADMIN = Permission_Action_ADMIN;
  static inline bool Action_IsValid(int value) {
    return Permission_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Permission_Action_Action_MIN;
  static const Action Action_MAX =
    Permission_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Permission_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return Permission_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return Permission_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return Permission_Action_Parse(name, value);
  }

  typedef Permission_Type Type;
  static const Type Global = Permission_Type_Global;
  static const Type Namespace = Permission_Type_Namespace;
  static const Type Table = Permission_Type_Table;
  static inline bool Type_IsValid(int value) {
    return Permission_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Permission_Type_Type_MIN;
  static const Type Type_MAX =
    Permission_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Permission_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Permission_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Permission_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Permission_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.Permission.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::hbase::pb::Permission_Type type() const;
  inline void set_type(::hbase::pb::Permission_Type value);

  // optional .hbase.pb.GlobalPermission global_permission = 2;
  inline bool has_global_permission() const;
  inline void clear_global_permission();
  static const int kGlobalPermissionFieldNumber = 2;
  inline const ::hbase::pb::GlobalPermission& global_permission() const;
  inline ::hbase::pb::GlobalPermission* mutable_global_permission();
  inline ::hbase::pb::GlobalPermission* release_global_permission();
  inline void set_allocated_global_permission(::hbase::pb::GlobalPermission* global_permission);

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  inline bool has_namespace_permission() const;
  inline void clear_namespace_permission();
  static const int kNamespacePermissionFieldNumber = 3;
  inline const ::hbase::pb::NamespacePermission& namespace_permission() const;
  inline ::hbase::pb::NamespacePermission* mutable_namespace_permission();
  inline ::hbase::pb::NamespacePermission* release_namespace_permission();
  inline void set_allocated_namespace_permission(::hbase::pb::NamespacePermission* namespace_permission);

  // optional .hbase.pb.TablePermission table_permission = 4;
  inline bool has_table_permission() const;
  inline void clear_table_permission();
  static const int kTablePermissionFieldNumber = 4;
  inline const ::hbase::pb::TablePermission& table_permission() const;
  inline ::hbase::pb::TablePermission* mutable_table_permission();
  inline ::hbase::pb::TablePermission* release_table_permission();
  inline void set_allocated_table_permission(::hbase::pb::TablePermission* table_permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.Permission)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_global_permission();
  inline void clear_has_global_permission();
  inline void set_has_namespace_permission();
  inline void clear_has_namespace_permission();
  inline void set_has_table_permission();
  inline void clear_has_table_permission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::GlobalPermission* global_permission_;
  ::hbase::pb::NamespacePermission* namespace_permission_;
  ::hbase::pb::TablePermission* table_permission_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static Permission* default_instance_;
};
// -------------------------------------------------------------------

class TablePermission : public ::google::protobuf::Message {
 public:
  TablePermission();
  virtual ~TablePermission();

  TablePermission(const TablePermission& from);

  inline TablePermission& operator=(const TablePermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TablePermission& default_instance();

  void Swap(TablePermission* other);

  // implements Message ----------------------------------------------

  TablePermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TablePermission& from);
  void MergeFrom(const TablePermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.TableName table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional bytes family = 2;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 2;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // optional bytes qualifier = 3;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 3;
  inline const ::std::string& qualifier() const;
  inline void set_qualifier(const ::std::string& value);
  inline void set_qualifier(const char* value);
  inline void set_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_qualifier();
  inline ::std::string* release_qualifier();
  inline void set_allocated_qualifier(::std::string* qualifier);

  // repeated .hbase.pb.Permission.Action action = 4;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::hbase::pb::Permission_Action action(int index) const;
  inline void set_action(int index, ::hbase::pb::Permission_Action value);
  inline void add_action(::hbase::pb::Permission_Action value);
  inline const ::google::protobuf::RepeatedField<int>& action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_action();

  // @@protoc_insertion_point(class_scope:hbase.pb.TablePermission)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;
  ::std::string* family_;
  ::std::string* qualifier_;
  ::google::protobuf::RepeatedField<int> action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static TablePermission* default_instance_;
};
// -------------------------------------------------------------------

class NamespacePermission : public ::google::protobuf::Message {
 public:
  NamespacePermission();
  virtual ~NamespacePermission();

  NamespacePermission(const NamespacePermission& from);

  inline NamespacePermission& operator=(const NamespacePermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamespacePermission& default_instance();

  void Swap(NamespacePermission* other);

  // implements Message ----------------------------------------------

  NamespacePermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamespacePermission& from);
  void MergeFrom(const NamespacePermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes namespace_name = 1;
  inline bool has_namespace_name() const;
  inline void clear_namespace_name();
  static const int kNamespaceNameFieldNumber = 1;
  inline const ::std::string& namespace_name() const;
  inline void set_namespace_name(const ::std::string& value);
  inline void set_namespace_name(const char* value);
  inline void set_namespace_name(const void* value, size_t size);
  inline ::std::string* mutable_namespace_name();
  inline ::std::string* release_namespace_name();
  inline void set_allocated_namespace_name(::std::string* namespace_name);

  // repeated .hbase.pb.Permission.Action action = 2;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::hbase::pb::Permission_Action action(int index) const;
  inline void set_action(int index, ::hbase::pb::Permission_Action value);
  inline void add_action(::hbase::pb::Permission_Action value);
  inline const ::google::protobuf::RepeatedField<int>& action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_action();

  // @@protoc_insertion_point(class_scope:hbase.pb.NamespacePermission)
 private:
  inline void set_has_namespace_name();
  inline void clear_has_namespace_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* namespace_name_;
  ::google::protobuf::RepeatedField<int> action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static NamespacePermission* default_instance_;
};
// -------------------------------------------------------------------

class GlobalPermission : public ::google::protobuf::Message {
 public:
  GlobalPermission();
  virtual ~GlobalPermission();

  GlobalPermission(const GlobalPermission& from);

  inline GlobalPermission& operator=(const GlobalPermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalPermission& default_instance();

  void Swap(GlobalPermission* other);

  // implements Message ----------------------------------------------

  GlobalPermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalPermission& from);
  void MergeFrom(const GlobalPermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.Permission.Action action = 1;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::hbase::pb::Permission_Action action(int index) const;
  inline void set_action(int index, ::hbase::pb::Permission_Action value);
  inline void add_action(::hbase::pb::Permission_Action value);
  inline const ::google::protobuf::RepeatedField<int>& action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_action();

  // @@protoc_insertion_point(class_scope:hbase.pb.GlobalPermission)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static GlobalPermission* default_instance_;
};
// -------------------------------------------------------------------

class UserPermission : public ::google::protobuf::Message {
 public:
  UserPermission();
  virtual ~UserPermission();

  UserPermission(const UserPermission& from);

  inline UserPermission& operator=(const UserPermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPermission& default_instance();

  void Swap(UserPermission* other);

  // implements Message ----------------------------------------------

  UserPermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPermission& from);
  void MergeFrom(const UserPermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required .hbase.pb.Permission permission = 3;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 3;
  inline const ::hbase::pb::Permission& permission() const;
  inline ::hbase::pb::Permission* mutable_permission();
  inline ::hbase::pb::Permission* release_permission();
  inline void set_allocated_permission(::hbase::pb::Permission* permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.UserPermission)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_permission();
  inline void clear_has_permission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::hbase::pb::Permission* permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static UserPermission* default_instance_;
};
// -------------------------------------------------------------------

class UsersAndPermissions_UserPermissions : public ::google::protobuf::Message {
 public:
  UsersAndPermissions_UserPermissions();
  virtual ~UsersAndPermissions_UserPermissions();

  UsersAndPermissions_UserPermissions(const UsersAndPermissions_UserPermissions& from);

  inline UsersAndPermissions_UserPermissions& operator=(const UsersAndPermissions_UserPermissions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UsersAndPermissions_UserPermissions& default_instance();

  void Swap(UsersAndPermissions_UserPermissions* other);

  // implements Message ----------------------------------------------

  UsersAndPermissions_UserPermissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UsersAndPermissions_UserPermissions& from);
  void MergeFrom(const UsersAndPermissions_UserPermissions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // repeated .hbase.pb.Permission permissions = 2;
  inline int permissions_size() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 2;
  inline const ::hbase::pb::Permission& permissions(int index) const;
  inline ::hbase::pb::Permission* mutable_permissions(int index);
  inline ::hbase::pb::Permission* add_permissions();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >&
      permissions() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >*
      mutable_permissions();

  // @@protoc_insertion_point(class_scope:hbase.pb.UsersAndPermissions.UserPermissions)
 private:
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission > permissions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static UsersAndPermissions_UserPermissions* default_instance_;
};
// -------------------------------------------------------------------

class UsersAndPermissions : public ::google::protobuf::Message {
 public:
  UsersAndPermissions();
  virtual ~UsersAndPermissions();

  UsersAndPermissions(const UsersAndPermissions& from);

  inline UsersAndPermissions& operator=(const UsersAndPermissions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UsersAndPermissions& default_instance();

  void Swap(UsersAndPermissions* other);

  // implements Message ----------------------------------------------

  UsersAndPermissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UsersAndPermissions& from);
  void MergeFrom(const UsersAndPermissions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UsersAndPermissions_UserPermissions UserPermissions;

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  inline int user_permissions_size() const;
  inline void clear_user_permissions();
  static const int kUserPermissionsFieldNumber = 1;
  inline const ::hbase::pb::UsersAndPermissions_UserPermissions& user_permissions(int index) const;
  inline ::hbase::pb::UsersAndPermissions_UserPermissions* mutable_user_permissions(int index);
  inline ::hbase::pb::UsersAndPermissions_UserPermissions* add_user_permissions();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >&
      user_permissions() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >*
      mutable_user_permissions();

  // @@protoc_insertion_point(class_scope:hbase.pb.UsersAndPermissions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions > user_permissions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static UsersAndPermissions* default_instance_;
};
// -------------------------------------------------------------------

class GrantRequest : public ::google::protobuf::Message {
 public:
  GrantRequest();
  virtual ~GrantRequest();

  GrantRequest(const GrantRequest& from);

  inline GrantRequest& operator=(const GrantRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GrantRequest& default_instance();

  void Swap(GrantRequest* other);

  // implements Message ----------------------------------------------

  GrantRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GrantRequest& from);
  void MergeFrom(const GrantRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserPermission user_permission = 1;
  inline bool has_user_permission() const;
  inline void clear_user_permission();
  static const int kUserPermissionFieldNumber = 1;
  inline const ::hbase::pb::UserPermission& user_permission() const;
  inline ::hbase::pb::UserPermission* mutable_user_permission();
  inline ::hbase::pb::UserPermission* release_user_permission();
  inline void set_allocated_user_permission(::hbase::pb::UserPermission* user_permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.GrantRequest)
 private:
  inline void set_has_user_permission();
  inline void clear_has_user_permission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserPermission* user_permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static GrantRequest* default_instance_;
};
// -------------------------------------------------------------------

class GrantResponse : public ::google::protobuf::Message {
 public:
  GrantResponse();
  virtual ~GrantResponse();

  GrantResponse(const GrantResponse& from);

  inline GrantResponse& operator=(const GrantResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GrantResponse& default_instance();

  void Swap(GrantResponse* other);

  // implements Message ----------------------------------------------

  GrantResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GrantResponse& from);
  void MergeFrom(const GrantResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.GrantResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static GrantResponse* default_instance_;
};
// -------------------------------------------------------------------

class RevokeRequest : public ::google::protobuf::Message {
 public:
  RevokeRequest();
  virtual ~RevokeRequest();

  RevokeRequest(const RevokeRequest& from);

  inline RevokeRequest& operator=(const RevokeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevokeRequest& default_instance();

  void Swap(RevokeRequest* other);

  // implements Message ----------------------------------------------

  RevokeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevokeRequest& from);
  void MergeFrom(const RevokeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.UserPermission user_permission = 1;
  inline bool has_user_permission() const;
  inline void clear_user_permission();
  static const int kUserPermissionFieldNumber = 1;
  inline const ::hbase::pb::UserPermission& user_permission() const;
  inline ::hbase::pb::UserPermission* mutable_user_permission();
  inline ::hbase::pb::UserPermission* release_user_permission();
  inline void set_allocated_user_permission(::hbase::pb::UserPermission* user_permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.RevokeRequest)
 private:
  inline void set_has_user_permission();
  inline void clear_has_user_permission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::UserPermission* user_permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static RevokeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RevokeResponse : public ::google::protobuf::Message {
 public:
  RevokeResponse();
  virtual ~RevokeResponse();

  RevokeResponse(const RevokeResponse& from);

  inline RevokeResponse& operator=(const RevokeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevokeResponse& default_instance();

  void Swap(RevokeResponse* other);

  // implements Message ----------------------------------------------

  RevokeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevokeResponse& from);
  void MergeFrom(const RevokeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.RevokeResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static RevokeResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetUserPermissionsRequest : public ::google::protobuf::Message {
 public:
  GetUserPermissionsRequest();
  virtual ~GetUserPermissionsRequest();

  GetUserPermissionsRequest(const GetUserPermissionsRequest& from);

  inline GetUserPermissionsRequest& operator=(const GetUserPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserPermissionsRequest& default_instance();

  void Swap(GetUserPermissionsRequest* other);

  // implements Message ----------------------------------------------

  GetUserPermissionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserPermissionsRequest& from);
  void MergeFrom(const GetUserPermissionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.Permission.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::hbase::pb::Permission_Type type() const;
  inline void set_type(::hbase::pb::Permission_Type value);

  // optional .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional bytes namespace_name = 3;
  inline bool has_namespace_name() const;
  inline void clear_namespace_name();
  static const int kNamespaceNameFieldNumber = 3;
  inline const ::std::string& namespace_name() const;
  inline void set_namespace_name(const ::std::string& value);
  inline void set_namespace_name(const char* value);
  inline void set_namespace_name(const void* value, size_t size);
  inline ::std::string* mutable_namespace_name();
  inline ::std::string* release_namespace_name();
  inline void set_allocated_namespace_name(::std::string* namespace_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetUserPermissionsRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_namespace_name();
  inline void clear_has_namespace_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;
  ::std::string* namespace_name_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static GetUserPermissionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserPermissionsResponse : public ::google::protobuf::Message {
 public:
  GetUserPermissionsResponse();
  virtual ~GetUserPermissionsResponse();

  GetUserPermissionsResponse(const GetUserPermissionsResponse& from);

  inline GetUserPermissionsResponse& operator=(const GetUserPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserPermissionsResponse& default_instance();

  void Swap(GetUserPermissionsResponse* other);

  // implements Message ----------------------------------------------

  GetUserPermissionsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserPermissionsResponse& from);
  void MergeFrom(const GetUserPermissionsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.UserPermission user_permission = 1;
  inline int user_permission_size() const;
  inline void clear_user_permission();
  static const int kUserPermissionFieldNumber = 1;
  inline const ::hbase::pb::UserPermission& user_permission(int index) const;
  inline ::hbase::pb::UserPermission* mutable_user_permission(int index);
  inline ::hbase::pb::UserPermission* add_user_permission();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UserPermission >&
      user_permission() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UserPermission >*
      mutable_user_permission();

  // @@protoc_insertion_point(class_scope:hbase.pb.GetUserPermissionsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::UserPermission > user_permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static GetUserPermissionsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckPermissionsRequest : public ::google::protobuf::Message {
 public:
  CheckPermissionsRequest();
  virtual ~CheckPermissionsRequest();

  CheckPermissionsRequest(const CheckPermissionsRequest& from);

  inline CheckPermissionsRequest& operator=(const CheckPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckPermissionsRequest& default_instance();

  void Swap(CheckPermissionsRequest* other);

  // implements Message ----------------------------------------------

  CheckPermissionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckPermissionsRequest& from);
  void MergeFrom(const CheckPermissionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.Permission permission = 1;
  inline int permission_size() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 1;
  inline const ::hbase::pb::Permission& permission(int index) const;
  inline ::hbase::pb::Permission* mutable_permission(int index);
  inline ::hbase::pb::Permission* add_permission();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >&
      permission() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >*
      mutable_permission();

  // @@protoc_insertion_point(class_scope:hbase.pb.CheckPermissionsRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission > permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static CheckPermissionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckPermissionsResponse : public ::google::protobuf::Message {
 public:
  CheckPermissionsResponse();
  virtual ~CheckPermissionsResponse();

  CheckPermissionsResponse(const CheckPermissionsResponse& from);

  inline CheckPermissionsResponse& operator=(const CheckPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckPermissionsResponse& default_instance();

  void Swap(CheckPermissionsResponse* other);

  // implements Message ----------------------------------------------

  CheckPermissionsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckPermissionsResponse& from);
  void MergeFrom(const CheckPermissionsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.CheckPermissionsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AccessControl_2eproto();
  friend void protobuf_AssignDesc_AccessControl_2eproto();
  friend void protobuf_ShutdownFile_AccessControl_2eproto();

  void InitAsDefaultInstance();
  static CheckPermissionsResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Permission

// required .hbase.pb.Permission.Type type = 1;
inline bool Permission::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Permission::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Permission::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Permission::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hbase::pb::Permission_Type Permission::type() const {
  return static_cast< ::hbase::pb::Permission_Type >(type_);
}
inline void Permission::set_type(::hbase::pb::Permission_Type value) {
  assert(::hbase::pb::Permission_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .hbase.pb.GlobalPermission global_permission = 2;
inline bool Permission::has_global_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Permission::set_has_global_permission() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Permission::clear_has_global_permission() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Permission::clear_global_permission() {
  if (global_permission_ != NULL) global_permission_->::hbase::pb::GlobalPermission::Clear();
  clear_has_global_permission();
}
inline const ::hbase::pb::GlobalPermission& Permission::global_permission() const {
  return global_permission_ != NULL ? *global_permission_ : *default_instance_->global_permission_;
}
inline ::hbase::pb::GlobalPermission* Permission::mutable_global_permission() {
  set_has_global_permission();
  if (global_permission_ == NULL) global_permission_ = new ::hbase::pb::GlobalPermission;
  return global_permission_;
}
inline ::hbase::pb::GlobalPermission* Permission::release_global_permission() {
  clear_has_global_permission();
  ::hbase::pb::GlobalPermission* temp = global_permission_;
  global_permission_ = NULL;
  return temp;
}
inline void Permission::set_allocated_global_permission(::hbase::pb::GlobalPermission* global_permission) {
  delete global_permission_;
  global_permission_ = global_permission;
  if (global_permission) {
    set_has_global_permission();
  } else {
    clear_has_global_permission();
  }
}

// optional .hbase.pb.NamespacePermission namespace_permission = 3;
inline bool Permission::has_namespace_permission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Permission::set_has_namespace_permission() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Permission::clear_has_namespace_permission() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Permission::clear_namespace_permission() {
  if (namespace_permission_ != NULL) namespace_permission_->::hbase::pb::NamespacePermission::Clear();
  clear_has_namespace_permission();
}
inline const ::hbase::pb::NamespacePermission& Permission::namespace_permission() const {
  return namespace_permission_ != NULL ? *namespace_permission_ : *default_instance_->namespace_permission_;
}
inline ::hbase::pb::NamespacePermission* Permission::mutable_namespace_permission() {
  set_has_namespace_permission();
  if (namespace_permission_ == NULL) namespace_permission_ = new ::hbase::pb::NamespacePermission;
  return namespace_permission_;
}
inline ::hbase::pb::NamespacePermission* Permission::release_namespace_permission() {
  clear_has_namespace_permission();
  ::hbase::pb::NamespacePermission* temp = namespace_permission_;
  namespace_permission_ = NULL;
  return temp;
}
inline void Permission::set_allocated_namespace_permission(::hbase::pb::NamespacePermission* namespace_permission) {
  delete namespace_permission_;
  namespace_permission_ = namespace_permission;
  if (namespace_permission) {
    set_has_namespace_permission();
  } else {
    clear_has_namespace_permission();
  }
}

// optional .hbase.pb.TablePermission table_permission = 4;
inline bool Permission::has_table_permission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Permission::set_has_table_permission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Permission::clear_has_table_permission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Permission::clear_table_permission() {
  if (table_permission_ != NULL) table_permission_->::hbase::pb::TablePermission::Clear();
  clear_has_table_permission();
}
inline const ::hbase::pb::TablePermission& Permission::table_permission() const {
  return table_permission_ != NULL ? *table_permission_ : *default_instance_->table_permission_;
}
inline ::hbase::pb::TablePermission* Permission::mutable_table_permission() {
  set_has_table_permission();
  if (table_permission_ == NULL) table_permission_ = new ::hbase::pb::TablePermission;
  return table_permission_;
}
inline ::hbase::pb::TablePermission* Permission::release_table_permission() {
  clear_has_table_permission();
  ::hbase::pb::TablePermission* temp = table_permission_;
  table_permission_ = NULL;
  return temp;
}
inline void Permission::set_allocated_table_permission(::hbase::pb::TablePermission* table_permission) {
  delete table_permission_;
  table_permission_ = table_permission;
  if (table_permission) {
    set_has_table_permission();
  } else {
    clear_has_table_permission();
  }
}

// -------------------------------------------------------------------

// TablePermission

// optional .hbase.pb.TableName table_name = 1;
inline bool TablePermission::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TablePermission::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TablePermission::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TablePermission::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& TablePermission::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* TablePermission::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* TablePermission::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void TablePermission::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// optional bytes family = 2;
inline bool TablePermission::has_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TablePermission::set_has_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TablePermission::clear_has_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TablePermission::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& TablePermission::family() const {
  return *family_;
}
inline void TablePermission::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void TablePermission::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void TablePermission::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TablePermission::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* TablePermission::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TablePermission::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes qualifier = 3;
inline bool TablePermission::has_qualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TablePermission::set_has_qualifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TablePermission::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TablePermission::clear_qualifier() {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    qualifier_->clear();
  }
  clear_has_qualifier();
}
inline const ::std::string& TablePermission::qualifier() const {
  return *qualifier_;
}
inline void TablePermission::set_qualifier(const ::std::string& value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void TablePermission::set_qualifier(const char* value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void TablePermission::set_qualifier(const void* value, size_t size) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TablePermission::mutable_qualifier() {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  return qualifier_;
}
inline ::std::string* TablePermission::release_qualifier() {
  clear_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualifier_;
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TablePermission::set_allocated_qualifier(::std::string* qualifier) {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (qualifier) {
    set_has_qualifier();
    qualifier_ = qualifier;
  } else {
    clear_has_qualifier();
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.Permission.Action action = 4;
inline int TablePermission::action_size() const {
  return action_.size();
}
inline void TablePermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action TablePermission::action(int index) const {
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void TablePermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
}
inline void TablePermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TablePermission::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedField<int>*
TablePermission::mutable_action() {
  return &action_;
}

// -------------------------------------------------------------------

// NamespacePermission

// optional bytes namespace_name = 1;
inline bool NamespacePermission::has_namespace_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamespacePermission::set_has_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamespacePermission::clear_has_namespace_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamespacePermission::clear_namespace_name() {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    namespace_name_->clear();
  }
  clear_has_namespace_name();
}
inline const ::std::string& NamespacePermission::namespace_name() const {
  return *namespace_name_;
}
inline void NamespacePermission::set_namespace_name(const ::std::string& value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void NamespacePermission::set_namespace_name(const char* value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void NamespacePermission::set_namespace_name(const void* value, size_t size) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NamespacePermission::mutable_namespace_name() {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  return namespace_name_;
}
inline ::std::string* NamespacePermission::release_namespace_name() {
  clear_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace_name_;
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NamespacePermission::set_allocated_namespace_name(::std::string* namespace_name) {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    delete namespace_name_;
  }
  if (namespace_name) {
    set_has_namespace_name();
    namespace_name_ = namespace_name;
  } else {
    clear_has_namespace_name();
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.Permission.Action action = 2;
inline int NamespacePermission::action_size() const {
  return action_.size();
}
inline void NamespacePermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action NamespacePermission::action(int index) const {
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void NamespacePermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
}
inline void NamespacePermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
NamespacePermission::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedField<int>*
NamespacePermission::mutable_action() {
  return &action_;
}

// -------------------------------------------------------------------

// GlobalPermission

// repeated .hbase.pb.Permission.Action action = 1;
inline int GlobalPermission::action_size() const {
  return action_.size();
}
inline void GlobalPermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action GlobalPermission::action(int index) const {
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void GlobalPermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
}
inline void GlobalPermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GlobalPermission::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedField<int>*
GlobalPermission::mutable_action() {
  return &action_;
}

// -------------------------------------------------------------------

// UserPermission

// required bytes user = 1;
inline bool UserPermission::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPermission::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPermission::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPermission::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UserPermission::user() const {
  return *user_;
}
inline void UserPermission::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UserPermission::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UserPermission::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPermission::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UserPermission::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPermission::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hbase.pb.Permission permission = 3;
inline bool UserPermission::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPermission::set_has_permission() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPermission::clear_has_permission() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPermission::clear_permission() {
  if (permission_ != NULL) permission_->::hbase::pb::Permission::Clear();
  clear_has_permission();
}
inline const ::hbase::pb::Permission& UserPermission::permission() const {
  return permission_ != NULL ? *permission_ : *default_instance_->permission_;
}
inline ::hbase::pb::Permission* UserPermission::mutable_permission() {
  set_has_permission();
  if (permission_ == NULL) permission_ = new ::hbase::pb::Permission;
  return permission_;
}
inline ::hbase::pb::Permission* UserPermission::release_permission() {
  clear_has_permission();
  ::hbase::pb::Permission* temp = permission_;
  permission_ = NULL;
  return temp;
}
inline void UserPermission::set_allocated_permission(::hbase::pb::Permission* permission) {
  delete permission_;
  permission_ = permission;
  if (permission) {
    set_has_permission();
  } else {
    clear_has_permission();
  }
}

// -------------------------------------------------------------------

// UsersAndPermissions_UserPermissions

// required bytes user = 1;
inline bool UsersAndPermissions_UserPermissions::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsersAndPermissions_UserPermissions::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UsersAndPermissions_UserPermissions::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UsersAndPermissions_UserPermissions::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UsersAndPermissions_UserPermissions::user() const {
  return *user_;
}
inline void UsersAndPermissions_UserPermissions::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UsersAndPermissions_UserPermissions::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UsersAndPermissions_UserPermissions::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsersAndPermissions_UserPermissions::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UsersAndPermissions_UserPermissions::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsersAndPermissions_UserPermissions::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.Permission permissions = 2;
inline int UsersAndPermissions_UserPermissions::permissions_size() const {
  return permissions_.size();
}
inline void UsersAndPermissions_UserPermissions::clear_permissions() {
  permissions_.Clear();
}
inline const ::hbase::pb::Permission& UsersAndPermissions_UserPermissions::permissions(int index) const {
  return permissions_.Get(index);
}
inline ::hbase::pb::Permission* UsersAndPermissions_UserPermissions::mutable_permissions(int index) {
  return permissions_.Mutable(index);
}
inline ::hbase::pb::Permission* UsersAndPermissions_UserPermissions::add_permissions() {
  return permissions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >&
UsersAndPermissions_UserPermissions::permissions() const {
  return permissions_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >*
UsersAndPermissions_UserPermissions::mutable_permissions() {
  return &permissions_;
}

// -------------------------------------------------------------------

// UsersAndPermissions

// repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
inline int UsersAndPermissions::user_permissions_size() const {
  return user_permissions_.size();
}
inline void UsersAndPermissions::clear_user_permissions() {
  user_permissions_.Clear();
}
inline const ::hbase::pb::UsersAndPermissions_UserPermissions& UsersAndPermissions::user_permissions(int index) const {
  return user_permissions_.Get(index);
}
inline ::hbase::pb::UsersAndPermissions_UserPermissions* UsersAndPermissions::mutable_user_permissions(int index) {
  return user_permissions_.Mutable(index);
}
inline ::hbase::pb::UsersAndPermissions_UserPermissions* UsersAndPermissions::add_user_permissions() {
  return user_permissions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >&
UsersAndPermissions::user_permissions() const {
  return user_permissions_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >*
UsersAndPermissions::mutable_user_permissions() {
  return &user_permissions_;
}

// -------------------------------------------------------------------

// GrantRequest

// required .hbase.pb.UserPermission user_permission = 1;
inline bool GrantRequest::has_user_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GrantRequest::set_has_user_permission() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GrantRequest::clear_has_user_permission() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GrantRequest::clear_user_permission() {
  if (user_permission_ != NULL) user_permission_->::hbase::pb::UserPermission::Clear();
  clear_has_user_permission();
}
inline const ::hbase::pb::UserPermission& GrantRequest::user_permission() const {
  return user_permission_ != NULL ? *user_permission_ : *default_instance_->user_permission_;
}
inline ::hbase::pb::UserPermission* GrantRequest::mutable_user_permission() {
  set_has_user_permission();
  if (user_permission_ == NULL) user_permission_ = new ::hbase::pb::UserPermission;
  return user_permission_;
}
inline ::hbase::pb::UserPermission* GrantRequest::release_user_permission() {
  clear_has_user_permission();
  ::hbase::pb::UserPermission* temp = user_permission_;
  user_permission_ = NULL;
  return temp;
}
inline void GrantRequest::set_allocated_user_permission(::hbase::pb::UserPermission* user_permission) {
  delete user_permission_;
  user_permission_ = user_permission;
  if (user_permission) {
    set_has_user_permission();
  } else {
    clear_has_user_permission();
  }
}

// -------------------------------------------------------------------

// GrantResponse

// -------------------------------------------------------------------

// RevokeRequest

// required .hbase.pb.UserPermission user_permission = 1;
inline bool RevokeRequest::has_user_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RevokeRequest::set_has_user_permission() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RevokeRequest::clear_has_user_permission() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RevokeRequest::clear_user_permission() {
  if (user_permission_ != NULL) user_permission_->::hbase::pb::UserPermission::Clear();
  clear_has_user_permission();
}
inline const ::hbase::pb::UserPermission& RevokeRequest::user_permission() const {
  return user_permission_ != NULL ? *user_permission_ : *default_instance_->user_permission_;
}
inline ::hbase::pb::UserPermission* RevokeRequest::mutable_user_permission() {
  set_has_user_permission();
  if (user_permission_ == NULL) user_permission_ = new ::hbase::pb::UserPermission;
  return user_permission_;
}
inline ::hbase::pb::UserPermission* RevokeRequest::release_user_permission() {
  clear_has_user_permission();
  ::hbase::pb::UserPermission* temp = user_permission_;
  user_permission_ = NULL;
  return temp;
}
inline void RevokeRequest::set_allocated_user_permission(::hbase::pb::UserPermission* user_permission) {
  delete user_permission_;
  user_permission_ = user_permission;
  if (user_permission) {
    set_has_user_permission();
  } else {
    clear_has_user_permission();
  }
}

// -------------------------------------------------------------------

// RevokeResponse

// -------------------------------------------------------------------

// GetUserPermissionsRequest

// optional .hbase.pb.Permission.Type type = 1;
inline bool GetUserPermissionsRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserPermissionsRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserPermissionsRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserPermissionsRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hbase::pb::Permission_Type GetUserPermissionsRequest::type() const {
  return static_cast< ::hbase::pb::Permission_Type >(type_);
}
inline void GetUserPermissionsRequest::set_type(::hbase::pb::Permission_Type value) {
  assert(::hbase::pb::Permission_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .hbase.pb.TableName table_name = 2;
inline bool GetUserPermissionsRequest::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserPermissionsRequest::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserPermissionsRequest::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserPermissionsRequest::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& GetUserPermissionsRequest::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* GetUserPermissionsRequest::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* GetUserPermissionsRequest::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void GetUserPermissionsRequest::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// optional bytes namespace_name = 3;
inline bool GetUserPermissionsRequest::has_namespace_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserPermissionsRequest::set_has_namespace_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserPermissionsRequest::clear_has_namespace_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserPermissionsRequest::clear_namespace_name() {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    namespace_name_->clear();
  }
  clear_has_namespace_name();
}
inline const ::std::string& GetUserPermissionsRequest::namespace_name() const {
  return *namespace_name_;
}
inline void GetUserPermissionsRequest::set_namespace_name(const ::std::string& value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void GetUserPermissionsRequest::set_namespace_name(const char* value) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(value);
}
inline void GetUserPermissionsRequest::set_namespace_name(const void* value, size_t size) {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  namespace_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserPermissionsRequest::mutable_namespace_name() {
  set_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    namespace_name_ = new ::std::string;
  }
  return namespace_name_;
}
inline ::std::string* GetUserPermissionsRequest::release_namespace_name() {
  clear_has_namespace_name();
  if (namespace_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace_name_;
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUserPermissionsRequest::set_allocated_namespace_name(::std::string* namespace_name) {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    delete namespace_name_;
  }
  if (namespace_name) {
    set_has_namespace_name();
    namespace_name_ = namespace_name;
  } else {
    clear_has_namespace_name();
    namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetUserPermissionsResponse

// repeated .hbase.pb.UserPermission user_permission = 1;
inline int GetUserPermissionsResponse::user_permission_size() const {
  return user_permission_.size();
}
inline void GetUserPermissionsResponse::clear_user_permission() {
  user_permission_.Clear();
}
inline const ::hbase::pb::UserPermission& GetUserPermissionsResponse::user_permission(int index) const {
  return user_permission_.Get(index);
}
inline ::hbase::pb::UserPermission* GetUserPermissionsResponse::mutable_user_permission(int index) {
  return user_permission_.Mutable(index);
}
inline ::hbase::pb::UserPermission* GetUserPermissionsResponse::add_user_permission() {
  return user_permission_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::UserPermission >&
GetUserPermissionsResponse::user_permission() const {
  return user_permission_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::UserPermission >*
GetUserPermissionsResponse::mutable_user_permission() {
  return &user_permission_;
}

// -------------------------------------------------------------------

// CheckPermissionsRequest

// repeated .hbase.pb.Permission permission = 1;
inline int CheckPermissionsRequest::permission_size() const {
  return permission_.size();
}
inline void CheckPermissionsRequest::clear_permission() {
  permission_.Clear();
}
inline const ::hbase::pb::Permission& CheckPermissionsRequest::permission(int index) const {
  return permission_.Get(index);
}
inline ::hbase::pb::Permission* CheckPermissionsRequest::mutable_permission(int index) {
  return permission_.Mutable(index);
}
inline ::hbase::pb::Permission* CheckPermissionsRequest::add_permission() {
  return permission_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >&
CheckPermissionsRequest::permission() const {
  return permission_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Permission >*
CheckPermissionsRequest::mutable_permission() {
  return &permission_;
}

// -------------------------------------------------------------------

// CheckPermissionsResponse


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Permission_Action>() {
  return ::hbase::pb::Permission_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Permission_Type>() {
  return ::hbase::pb::Permission_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AccessControl_2eproto__INCLUDED
