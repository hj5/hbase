// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Procedure.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Procedure.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* Procedure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Procedure_reflection_ = NULL;
const ::google::protobuf::Descriptor* SequentialProcedureData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SequentialProcedureData_reflection_ = NULL;
const ::google::protobuf::Descriptor* StateMachineProcedureData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StateMachineProcedureData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureWALHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureWALHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureWALTrailer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureWALTrailer_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureStoreTracker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureStoreTracker_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureStoreTracker_TrackerNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureStoreTracker_TrackerNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureWALEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureWALEntry_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ProcedureWALEntry_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ProcedureState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Procedure_2eproto() {
  protobuf_AddDesc_Procedure_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Procedure.proto");
  GOOGLE_CHECK(file != NULL);
  Procedure_descriptor_ = file->message_type(0);
  static const int Procedure_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, class_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, parent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, proc_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, start_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, owner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, stack_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, last_update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, exception_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, state_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, nonce_group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, nonce_),
  };
  Procedure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Procedure_descriptor_,
      Procedure::default_instance_,
      Procedure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Procedure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Procedure));
  SequentialProcedureData_descriptor_ = file->message_type(1);
  static const int SequentialProcedureData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequentialProcedureData, executed_),
  };
  SequentialProcedureData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SequentialProcedureData_descriptor_,
      SequentialProcedureData::default_instance_,
      SequentialProcedureData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequentialProcedureData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequentialProcedureData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SequentialProcedureData));
  StateMachineProcedureData_descriptor_ = file->message_type(2);
  static const int StateMachineProcedureData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StateMachineProcedureData, state_),
  };
  StateMachineProcedureData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StateMachineProcedureData_descriptor_,
      StateMachineProcedureData::default_instance_,
      StateMachineProcedureData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StateMachineProcedureData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StateMachineProcedureData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StateMachineProcedureData));
  ProcedureWALHeader_descriptor_ = file->message_type(3);
  static const int ProcedureWALHeader_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, log_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, min_proc_id_),
  };
  ProcedureWALHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProcedureWALHeader_descriptor_,
      ProcedureWALHeader::default_instance_,
      ProcedureWALHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProcedureWALHeader));
  ProcedureWALTrailer_descriptor_ = file->message_type(4);
  static const int ProcedureWALTrailer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALTrailer, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALTrailer, tracker_pos_),
  };
  ProcedureWALTrailer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProcedureWALTrailer_descriptor_,
      ProcedureWALTrailer::default_instance_,
      ProcedureWALTrailer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALTrailer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALTrailer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProcedureWALTrailer));
  ProcedureStoreTracker_descriptor_ = file->message_type(5);
  static const int ProcedureStoreTracker_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker, node_),
  };
  ProcedureStoreTracker_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProcedureStoreTracker_descriptor_,
      ProcedureStoreTracker::default_instance_,
      ProcedureStoreTracker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProcedureStoreTracker));
  ProcedureStoreTracker_TrackerNode_descriptor_ = ProcedureStoreTracker_descriptor_->nested_type(0);
  static const int ProcedureStoreTracker_TrackerNode_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker_TrackerNode, start_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker_TrackerNode, updated_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker_TrackerNode, deleted_),
  };
  ProcedureStoreTracker_TrackerNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProcedureStoreTracker_TrackerNode_descriptor_,
      ProcedureStoreTracker_TrackerNode::default_instance_,
      ProcedureStoreTracker_TrackerNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker_TrackerNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStoreTracker_TrackerNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProcedureStoreTracker_TrackerNode));
  ProcedureWALEntry_descriptor_ = file->message_type(6);
  static const int ProcedureWALEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALEntry, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALEntry, procedure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALEntry, proc_id_),
  };
  ProcedureWALEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProcedureWALEntry_descriptor_,
      ProcedureWALEntry::default_instance_,
      ProcedureWALEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureWALEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProcedureWALEntry));
  ProcedureWALEntry_Type_descriptor_ = ProcedureWALEntry_descriptor_->enum_type(0);
  ProcedureState_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Procedure_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Procedure_descriptor_, &Procedure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SequentialProcedureData_descriptor_, &SequentialProcedureData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StateMachineProcedureData_descriptor_, &StateMachineProcedureData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProcedureWALHeader_descriptor_, &ProcedureWALHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProcedureWALTrailer_descriptor_, &ProcedureWALTrailer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProcedureStoreTracker_descriptor_, &ProcedureStoreTracker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProcedureStoreTracker_TrackerNode_descriptor_, &ProcedureStoreTracker_TrackerNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProcedureWALEntry_descriptor_, &ProcedureWALEntry::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Procedure_2eproto() {
  delete Procedure::default_instance_;
  delete Procedure_reflection_;
  delete SequentialProcedureData::default_instance_;
  delete SequentialProcedureData_reflection_;
  delete StateMachineProcedureData::default_instance_;
  delete StateMachineProcedureData_reflection_;
  delete ProcedureWALHeader::default_instance_;
  delete ProcedureWALHeader_reflection_;
  delete ProcedureWALTrailer::default_instance_;
  delete ProcedureWALTrailer_reflection_;
  delete ProcedureStoreTracker::default_instance_;
  delete ProcedureStoreTracker_reflection_;
  delete ProcedureStoreTracker_TrackerNode::default_instance_;
  delete ProcedureStoreTracker_TrackerNode_reflection_;
  delete ProcedureWALEntry::default_instance_;
  delete ProcedureWALEntry_reflection_;
}

void protobuf_AddDesc_Procedure_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hbase::pb::protobuf_AddDesc_ErrorHandling_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017Procedure.proto\022\010hbase.pb\032\023ErrorHandli"
    "ng.proto\"\313\002\n\tProcedure\022\022\n\nclass_name\030\001 \002"
    "(\t\022\021\n\tparent_id\030\002 \001(\004\022\017\n\007proc_id\030\003 \002(\004\022\022"
    "\n\nstart_time\030\004 \002(\004\022\r\n\005owner\030\005 \001(\t\022\'\n\005sta"
    "te\030\006 \002(\0162\030.hbase.pb.ProcedureState\022\020\n\010st"
    "ack_id\030\007 \003(\r\022\023\n\013last_update\030\010 \002(\004\022\017\n\007tim"
    "eout\030\t \001(\r\0224\n\texception\030\n \001(\0132!.hbase.pb"
    ".ForeignExceptionMessage\022\016\n\006result\030\013 \001(\014"
    "\022\022\n\nstate_data\030\014 \001(\014\022\026\n\013nonce_group\030\r \001("
    "\004:\0010\022\020\n\005nonce\030\016 \001(\004:\0010\"+\n\027SequentialProc"
    "edureData\022\020\n\010executed\030\001 \002(\010\"*\n\031StateMach"
    "ineProcedureData\022\r\n\005state\030\001 \003(\r\"X\n\022Proce"
    "dureWALHeader\022\017\n\007version\030\001 \002(\r\022\014\n\004type\030\002"
    " \002(\r\022\016\n\006log_id\030\003 \002(\004\022\023\n\013min_proc_id\030\004 \002("
    "\004\";\n\023ProcedureWALTrailer\022\017\n\007version\030\001 \002("
    "\r\022\023\n\013tracker_pos\030\002 \002(\004\"\225\001\n\025ProcedureStor"
    "eTracker\0229\n\004node\030\001 \003(\0132+.hbase.pb.Proced"
    "ureStoreTracker.TrackerNode\032A\n\013TrackerNo"
    "de\022\020\n\010start_id\030\001 \002(\004\022\017\n\007updated\030\002 \003(\004\022\017\n"
    "\007deleted\030\003 \003(\004\"\235\002\n\021ProcedureWALEntry\022.\n\004"
    "type\030\001 \002(\0162 .hbase.pb.ProcedureWALEntry."
    "Type\022&\n\tprocedure\030\002 \003(\0132\023.hbase.pb.Proce"
    "dure\022\017\n\007proc_id\030\003 \001(\004\"\236\001\n\004Type\022\025\n\021PROCED"
    "URE_WAL_EOF\020\001\022\026\n\022PROCEDURE_WAL_INIT\020\002\022\030\n"
    "\024PROCEDURE_WAL_INSERT\020\003\022\030\n\024PROCEDURE_WAL"
    "_UPDATE\020\004\022\030\n\024PROCEDURE_WAL_DELETE\020\005\022\031\n\025P"
    "ROCEDURE_WAL_COMPACT\020\006*p\n\016ProcedureState"
    "\022\020\n\014INITIALIZING\020\001\022\014\n\010RUNNABLE\020\002\022\013\n\007WAIT"
    "ING\020\003\022\023\n\017WAITING_TIMEOUT\020\004\022\016\n\nROLLEDBACK"
    "\020\005\022\014\n\010FINISHED\020\006BE\n*org.apache.hadoop.hb"
    "ase.protobuf.generatedB\017ProcedureProtosH"
    "\001\210\001\001\240\001\001", 1247);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Procedure.proto", &protobuf_RegisterTypes);
  Procedure::default_instance_ = new Procedure();
  SequentialProcedureData::default_instance_ = new SequentialProcedureData();
  StateMachineProcedureData::default_instance_ = new StateMachineProcedureData();
  ProcedureWALHeader::default_instance_ = new ProcedureWALHeader();
  ProcedureWALTrailer::default_instance_ = new ProcedureWALTrailer();
  ProcedureStoreTracker::default_instance_ = new ProcedureStoreTracker();
  ProcedureStoreTracker_TrackerNode::default_instance_ = new ProcedureStoreTracker_TrackerNode();
  ProcedureWALEntry::default_instance_ = new ProcedureWALEntry();
  Procedure::default_instance_->InitAsDefaultInstance();
  SequentialProcedureData::default_instance_->InitAsDefaultInstance();
  StateMachineProcedureData::default_instance_->InitAsDefaultInstance();
  ProcedureWALHeader::default_instance_->InitAsDefaultInstance();
  ProcedureWALTrailer::default_instance_->InitAsDefaultInstance();
  ProcedureStoreTracker::default_instance_->InitAsDefaultInstance();
  ProcedureStoreTracker_TrackerNode::default_instance_->InitAsDefaultInstance();
  ProcedureWALEntry::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Procedure_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Procedure_2eproto {
  StaticDescriptorInitializer_Procedure_2eproto() {
    protobuf_AddDesc_Procedure_2eproto();
  }
} static_descriptor_initializer_Procedure_2eproto_;
const ::google::protobuf::EnumDescriptor* ProcedureState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureState_descriptor_;
}
bool ProcedureState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Procedure::kClassNameFieldNumber;
const int Procedure::kParentIdFieldNumber;
const int Procedure::kProcIdFieldNumber;
const int Procedure::kStartTimeFieldNumber;
const int Procedure::kOwnerFieldNumber;
const int Procedure::kStateFieldNumber;
const int Procedure::kStackIdFieldNumber;
const int Procedure::kLastUpdateFieldNumber;
const int Procedure::kTimeoutFieldNumber;
const int Procedure::kExceptionFieldNumber;
const int Procedure::kResultFieldNumber;
const int Procedure::kStateDataFieldNumber;
const int Procedure::kNonceGroupFieldNumber;
const int Procedure::kNonceFieldNumber;
#endif  // !_MSC_VER

Procedure::Procedure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Procedure::InitAsDefaultInstance() {
  exception_ = const_cast< ::hbase::pb::ForeignExceptionMessage*>(&::hbase::pb::ForeignExceptionMessage::default_instance());
}

Procedure::Procedure(const Procedure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Procedure::SharedCtor() {
  _cached_size_ = 0;
  class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  parent_id_ = GOOGLE_ULONGLONG(0);
  proc_id_ = GOOGLE_ULONGLONG(0);
  start_time_ = GOOGLE_ULONGLONG(0);
  owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_ = 1;
  last_update_ = GOOGLE_ULONGLONG(0);
  timeout_ = 0u;
  exception_ = NULL;
  result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nonce_group_ = GOOGLE_ULONGLONG(0);
  nonce_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Procedure::~Procedure() {
  SharedDtor();
}

void Procedure::SharedDtor() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    delete result_;
  }
  if (state_data_ != &::google::protobuf::internal::kEmptyString) {
    delete state_data_;
  }
  if (this != default_instance_) {
    delete exception_;
  }
}

void Procedure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Procedure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Procedure_descriptor_;
}

const Procedure& Procedure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

Procedure* Procedure::default_instance_ = NULL;

Procedure* Procedure::New() const {
  return new Procedure;
}

void Procedure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_class_name()) {
      if (class_name_ != &::google::protobuf::internal::kEmptyString) {
        class_name_->clear();
      }
    }
    parent_id_ = GOOGLE_ULONGLONG(0);
    proc_id_ = GOOGLE_ULONGLONG(0);
    start_time_ = GOOGLE_ULONGLONG(0);
    if (has_owner()) {
      if (owner_ != &::google::protobuf::internal::kEmptyString) {
        owner_->clear();
      }
    }
    state_ = 1;
    last_update_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    timeout_ = 0u;
    if (has_exception()) {
      if (exception_ != NULL) exception_->::hbase::pb::ForeignExceptionMessage::Clear();
    }
    if (has_result()) {
      if (result_ != &::google::protobuf::internal::kEmptyString) {
        result_->clear();
      }
    }
    if (has_state_data()) {
      if (state_data_ != &::google::protobuf::internal::kEmptyString) {
        state_data_->clear();
      }
    }
    nonce_group_ = GOOGLE_ULONGLONG(0);
    nonce_ = GOOGLE_ULONGLONG(0);
  }
  stack_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Procedure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string class_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_class_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->class_name().data(), this->class_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_parent_id;
        break;
      }

      // optional uint64 parent_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parent_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &parent_id_)));
          set_has_parent_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_proc_id;
        break;
      }

      // required uint64 proc_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_proc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &proc_id_)));
          set_has_proc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_start_time;
        break;
      }

      // required uint64 start_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_time_)));
          set_has_start_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_owner;
        break;
      }

      // optional string owner = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_owner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_owner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->owner().data(), this->owner().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // required .hbase.pb.ProcedureState state = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::ProcedureState_IsValid(value)) {
            set_state(static_cast< ::hbase::pb::ProcedureState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_stack_id;
        break;
      }

      // repeated uint32 stack_id = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stack_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_stack_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_stack_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_stack_id;
        if (input->ExpectTag(64)) goto parse_last_update;
        break;
      }

      // required uint64 last_update = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_update:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &last_update_)));
          set_has_last_update();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_timeout;
        break;
      }

      // optional uint32 timeout = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeout_)));
          set_has_timeout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_exception;
        break;
      }

      // optional .hbase.pb.ForeignExceptionMessage exception = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exception:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exception()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_result;
        break;
      }

      // optional bytes result = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_result()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_state_data;
        break;
      }

      // optional bytes state_data = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_state_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_nonce_group;
        break;
      }

      // optional uint64 nonce_group = 13 [default = 0];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nonce_group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nonce_group_)));
          set_has_nonce_group();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_nonce;
        break;
      }

      // optional uint64 nonce = 14 [default = 0];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nonce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nonce_)));
          set_has_nonce();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Procedure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string class_name = 1;
  if (has_class_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->class_name().data(), this->class_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->class_name(), output);
  }

  // optional uint64 parent_id = 2;
  if (has_parent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->parent_id(), output);
  }

  // required uint64 proc_id = 3;
  if (has_proc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->proc_id(), output);
  }

  // required uint64 start_time = 4;
  if (has_start_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->start_time(), output);
  }

  // optional string owner = 5;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->owner(), output);
  }

  // required .hbase.pb.ProcedureState state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->state(), output);
  }

  // repeated uint32 stack_id = 7;
  for (int i = 0; i < this->stack_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->stack_id(i), output);
  }

  // required uint64 last_update = 8;
  if (has_last_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->last_update(), output);
  }

  // optional uint32 timeout = 9;
  if (has_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->timeout(), output);
  }

  // optional .hbase.pb.ForeignExceptionMessage exception = 10;
  if (has_exception()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->exception(), output);
  }

  // optional bytes result = 11;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->result(), output);
  }

  // optional bytes state_data = 12;
  if (has_state_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      12, this->state_data(), output);
  }

  // optional uint64 nonce_group = 13 [default = 0];
  if (has_nonce_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->nonce_group(), output);
  }

  // optional uint64 nonce = 14 [default = 0];
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Procedure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string class_name = 1;
  if (has_class_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->class_name().data(), this->class_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->class_name(), target);
  }

  // optional uint64 parent_id = 2;
  if (has_parent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->parent_id(), target);
  }

  // required uint64 proc_id = 3;
  if (has_proc_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->proc_id(), target);
  }

  // required uint64 start_time = 4;
  if (has_start_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->start_time(), target);
  }

  // optional string owner = 5;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->owner(), target);
  }

  // required .hbase.pb.ProcedureState state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->state(), target);
  }

  // repeated uint32 stack_id = 7;
  for (int i = 0; i < this->stack_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(7, this->stack_id(i), target);
  }

  // required uint64 last_update = 8;
  if (has_last_update()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->last_update(), target);
  }

  // optional uint32 timeout = 9;
  if (has_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->timeout(), target);
  }

  // optional .hbase.pb.ForeignExceptionMessage exception = 10;
  if (has_exception()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->exception(), target);
  }

  // optional bytes result = 11;
  if (has_result()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->result(), target);
  }

  // optional bytes state_data = 12;
  if (has_state_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        12, this->state_data(), target);
  }

  // optional uint64 nonce_group = 13 [default = 0];
  if (has_nonce_group()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->nonce_group(), target);
  }

  // optional uint64 nonce = 14 [default = 0];
  if (has_nonce()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(14, this->nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Procedure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string class_name = 1;
    if (has_class_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->class_name());
    }

    // optional uint64 parent_id = 2;
    if (has_parent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->parent_id());
    }

    // required uint64 proc_id = 3;
    if (has_proc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->proc_id());
    }

    // required uint64 start_time = 4;
    if (has_start_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_time());
    }

    // optional string owner = 5;
    if (has_owner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->owner());
    }

    // required .hbase.pb.ProcedureState state = 6;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required uint64 last_update = 8;
    if (has_last_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->last_update());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 timeout = 9;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeout());
    }

    // optional .hbase.pb.ForeignExceptionMessage exception = 10;
    if (has_exception()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exception());
    }

    // optional bytes result = 11;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->result());
    }

    // optional bytes state_data = 12;
    if (has_state_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->state_data());
    }

    // optional uint64 nonce_group = 13 [default = 0];
    if (has_nonce_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nonce_group());
    }

    // optional uint64 nonce = 14 [default = 0];
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nonce());
    }

  }
  // repeated uint32 stack_id = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->stack_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->stack_id(i));
    }
    total_size += 1 * this->stack_id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Procedure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Procedure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Procedure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Procedure::MergeFrom(const Procedure& from) {
  GOOGLE_CHECK_NE(&from, this);
  stack_id_.MergeFrom(from.stack_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_class_name()) {
      set_class_name(from.class_name());
    }
    if (from.has_parent_id()) {
      set_parent_id(from.parent_id());
    }
    if (from.has_proc_id()) {
      set_proc_id(from.proc_id());
    }
    if (from.has_start_time()) {
      set_start_time(from.start_time());
    }
    if (from.has_owner()) {
      set_owner(from.owner());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_last_update()) {
      set_last_update(from.last_update());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_timeout()) {
      set_timeout(from.timeout());
    }
    if (from.has_exception()) {
      mutable_exception()->::hbase::pb::ForeignExceptionMessage::MergeFrom(from.exception());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_state_data()) {
      set_state_data(from.state_data());
    }
    if (from.has_nonce_group()) {
      set_nonce_group(from.nonce_group());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Procedure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Procedure::CopyFrom(const Procedure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Procedure::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ad) != 0x000000ad) return false;

  return true;
}

void Procedure::Swap(Procedure* other) {
  if (other != this) {
    std::swap(class_name_, other->class_name_);
    std::swap(parent_id_, other->parent_id_);
    std::swap(proc_id_, other->proc_id_);
    std::swap(start_time_, other->start_time_);
    std::swap(owner_, other->owner_);
    std::swap(state_, other->state_);
    stack_id_.Swap(&other->stack_id_);
    std::swap(last_update_, other->last_update_);
    std::swap(timeout_, other->timeout_);
    std::swap(exception_, other->exception_);
    std::swap(result_, other->result_);
    std::swap(state_data_, other->state_data_);
    std::swap(nonce_group_, other->nonce_group_);
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Procedure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Procedure_descriptor_;
  metadata.reflection = Procedure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SequentialProcedureData::kExecutedFieldNumber;
#endif  // !_MSC_VER

SequentialProcedureData::SequentialProcedureData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SequentialProcedureData::InitAsDefaultInstance() {
}

SequentialProcedureData::SequentialProcedureData(const SequentialProcedureData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SequentialProcedureData::SharedCtor() {
  _cached_size_ = 0;
  executed_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SequentialProcedureData::~SequentialProcedureData() {
  SharedDtor();
}

void SequentialProcedureData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SequentialProcedureData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SequentialProcedureData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SequentialProcedureData_descriptor_;
}

const SequentialProcedureData& SequentialProcedureData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

SequentialProcedureData* SequentialProcedureData::default_instance_ = NULL;

SequentialProcedureData* SequentialProcedureData::New() const {
  return new SequentialProcedureData;
}

void SequentialProcedureData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    executed_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SequentialProcedureData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool executed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &executed_)));
          set_has_executed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SequentialProcedureData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool executed = 1;
  if (has_executed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->executed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SequentialProcedureData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool executed = 1;
  if (has_executed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->executed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SequentialProcedureData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool executed = 1;
    if (has_executed()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SequentialProcedureData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SequentialProcedureData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SequentialProcedureData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SequentialProcedureData::MergeFrom(const SequentialProcedureData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executed()) {
      set_executed(from.executed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SequentialProcedureData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SequentialProcedureData::CopyFrom(const SequentialProcedureData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequentialProcedureData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SequentialProcedureData::Swap(SequentialProcedureData* other) {
  if (other != this) {
    std::swap(executed_, other->executed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SequentialProcedureData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SequentialProcedureData_descriptor_;
  metadata.reflection = SequentialProcedureData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StateMachineProcedureData::kStateFieldNumber;
#endif  // !_MSC_VER

StateMachineProcedureData::StateMachineProcedureData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StateMachineProcedureData::InitAsDefaultInstance() {
}

StateMachineProcedureData::StateMachineProcedureData(const StateMachineProcedureData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StateMachineProcedureData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StateMachineProcedureData::~StateMachineProcedureData() {
  SharedDtor();
}

void StateMachineProcedureData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StateMachineProcedureData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StateMachineProcedureData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StateMachineProcedureData_descriptor_;
}

const StateMachineProcedureData& StateMachineProcedureData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

StateMachineProcedureData* StateMachineProcedureData::default_instance_ = NULL;

StateMachineProcedureData* StateMachineProcedureData::New() const {
  return new StateMachineProcedureData;
}

void StateMachineProcedureData::Clear() {
  state_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StateMachineProcedureData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_state())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_state())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_state;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StateMachineProcedureData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 state = 1;
  for (int i = 0; i < this->state_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->state(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StateMachineProcedureData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 state = 1;
  for (int i = 0; i < this->state_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->state(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StateMachineProcedureData::ByteSize() const {
  int total_size = 0;

  // repeated uint32 state = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->state_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->state(i));
    }
    total_size += 1 * this->state_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StateMachineProcedureData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StateMachineProcedureData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StateMachineProcedureData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StateMachineProcedureData::MergeFrom(const StateMachineProcedureData& from) {
  GOOGLE_CHECK_NE(&from, this);
  state_.MergeFrom(from.state_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StateMachineProcedureData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StateMachineProcedureData::CopyFrom(const StateMachineProcedureData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateMachineProcedureData::IsInitialized() const {

  return true;
}

void StateMachineProcedureData::Swap(StateMachineProcedureData* other) {
  if (other != this) {
    state_.Swap(&other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StateMachineProcedureData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StateMachineProcedureData_descriptor_;
  metadata.reflection = StateMachineProcedureData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProcedureWALHeader::kVersionFieldNumber;
const int ProcedureWALHeader::kTypeFieldNumber;
const int ProcedureWALHeader::kLogIdFieldNumber;
const int ProcedureWALHeader::kMinProcIdFieldNumber;
#endif  // !_MSC_VER

ProcedureWALHeader::ProcedureWALHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProcedureWALHeader::InitAsDefaultInstance() {
}

ProcedureWALHeader::ProcedureWALHeader(const ProcedureWALHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProcedureWALHeader::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  type_ = 0u;
  log_id_ = GOOGLE_ULONGLONG(0);
  min_proc_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcedureWALHeader::~ProcedureWALHeader() {
  SharedDtor();
}

void ProcedureWALHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureWALHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureWALHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureWALHeader_descriptor_;
}

const ProcedureWALHeader& ProcedureWALHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

ProcedureWALHeader* ProcedureWALHeader::default_instance_ = NULL;

ProcedureWALHeader* ProcedureWALHeader::New() const {
  return new ProcedureWALHeader;
}

void ProcedureWALHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    type_ = 0u;
    log_id_ = GOOGLE_ULONGLONG(0);
    min_proc_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProcedureWALHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_log_id;
        break;
      }

      // required uint64 log_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_log_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &log_id_)));
          set_has_log_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_min_proc_id;
        break;
      }

      // required uint64 min_proc_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_min_proc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_proc_id_)));
          set_has_min_proc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProcedureWALHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // required uint64 log_id = 3;
  if (has_log_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->log_id(), output);
  }

  // required uint64 min_proc_id = 4;
  if (has_min_proc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->min_proc_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProcedureWALHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
  }

  // required uint64 log_id = 3;
  if (has_log_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->log_id(), target);
  }

  // required uint64 min_proc_id = 4;
  if (has_min_proc_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->min_proc_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProcedureWALHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint64 log_id = 3;
    if (has_log_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->log_id());
    }

    // required uint64 min_proc_id = 4;
    if (has_min_proc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_proc_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureWALHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProcedureWALHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProcedureWALHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProcedureWALHeader::MergeFrom(const ProcedureWALHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_log_id()) {
      set_log_id(from.log_id());
    }
    if (from.has_min_proc_id()) {
      set_min_proc_id(from.min_proc_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProcedureWALHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureWALHeader::CopyFrom(const ProcedureWALHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureWALHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void ProcedureWALHeader::Swap(ProcedureWALHeader* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(type_, other->type_);
    std::swap(log_id_, other->log_id_);
    std::swap(min_proc_id_, other->min_proc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProcedureWALHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureWALHeader_descriptor_;
  metadata.reflection = ProcedureWALHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProcedureWALTrailer::kVersionFieldNumber;
const int ProcedureWALTrailer::kTrackerPosFieldNumber;
#endif  // !_MSC_VER

ProcedureWALTrailer::ProcedureWALTrailer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProcedureWALTrailer::InitAsDefaultInstance() {
}

ProcedureWALTrailer::ProcedureWALTrailer(const ProcedureWALTrailer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProcedureWALTrailer::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  tracker_pos_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcedureWALTrailer::~ProcedureWALTrailer() {
  SharedDtor();
}

void ProcedureWALTrailer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureWALTrailer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureWALTrailer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureWALTrailer_descriptor_;
}

const ProcedureWALTrailer& ProcedureWALTrailer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

ProcedureWALTrailer* ProcedureWALTrailer::default_instance_ = NULL;

ProcedureWALTrailer* ProcedureWALTrailer::New() const {
  return new ProcedureWALTrailer;
}

void ProcedureWALTrailer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    tracker_pos_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProcedureWALTrailer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tracker_pos;
        break;
      }

      // required uint64 tracker_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tracker_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tracker_pos_)));
          set_has_tracker_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProcedureWALTrailer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint64 tracker_pos = 2;
  if (has_tracker_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->tracker_pos(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProcedureWALTrailer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint64 tracker_pos = 2;
  if (has_tracker_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->tracker_pos(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProcedureWALTrailer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint64 tracker_pos = 2;
    if (has_tracker_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tracker_pos());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureWALTrailer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProcedureWALTrailer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProcedureWALTrailer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProcedureWALTrailer::MergeFrom(const ProcedureWALTrailer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_tracker_pos()) {
      set_tracker_pos(from.tracker_pos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProcedureWALTrailer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureWALTrailer::CopyFrom(const ProcedureWALTrailer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureWALTrailer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ProcedureWALTrailer::Swap(ProcedureWALTrailer* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(tracker_pos_, other->tracker_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProcedureWALTrailer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureWALTrailer_descriptor_;
  metadata.reflection = ProcedureWALTrailer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProcedureStoreTracker_TrackerNode::kStartIdFieldNumber;
const int ProcedureStoreTracker_TrackerNode::kUpdatedFieldNumber;
const int ProcedureStoreTracker_TrackerNode::kDeletedFieldNumber;
#endif  // !_MSC_VER

ProcedureStoreTracker_TrackerNode::ProcedureStoreTracker_TrackerNode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProcedureStoreTracker_TrackerNode::InitAsDefaultInstance() {
}

ProcedureStoreTracker_TrackerNode::ProcedureStoreTracker_TrackerNode(const ProcedureStoreTracker_TrackerNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProcedureStoreTracker_TrackerNode::SharedCtor() {
  _cached_size_ = 0;
  start_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcedureStoreTracker_TrackerNode::~ProcedureStoreTracker_TrackerNode() {
  SharedDtor();
}

void ProcedureStoreTracker_TrackerNode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureStoreTracker_TrackerNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureStoreTracker_TrackerNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureStoreTracker_TrackerNode_descriptor_;
}

const ProcedureStoreTracker_TrackerNode& ProcedureStoreTracker_TrackerNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

ProcedureStoreTracker_TrackerNode* ProcedureStoreTracker_TrackerNode::default_instance_ = NULL;

ProcedureStoreTracker_TrackerNode* ProcedureStoreTracker_TrackerNode::New() const {
  return new ProcedureStoreTracker_TrackerNode;
}

void ProcedureStoreTracker_TrackerNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_id_ = GOOGLE_ULONGLONG(0);
  }
  updated_.Clear();
  deleted_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProcedureStoreTracker_TrackerNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 start_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_id_)));
          set_has_start_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_updated;
        break;
      }

      // repeated uint64 updated = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_updated:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_updated())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_updated())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_updated;
        if (input->ExpectTag(24)) goto parse_deleted;
        break;
      }

      // repeated uint64 deleted = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deleted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_deleted())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_deleted())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_deleted;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProcedureStoreTracker_TrackerNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 start_id = 1;
  if (has_start_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->start_id(), output);
  }

  // repeated uint64 updated = 2;
  for (int i = 0; i < this->updated_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->updated(i), output);
  }

  // repeated uint64 deleted = 3;
  for (int i = 0; i < this->deleted_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->deleted(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProcedureStoreTracker_TrackerNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 start_id = 1;
  if (has_start_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->start_id(), target);
  }

  // repeated uint64 updated = 2;
  for (int i = 0; i < this->updated_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->updated(i), target);
  }

  // repeated uint64 deleted = 3;
  for (int i = 0; i < this->deleted_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->deleted(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProcedureStoreTracker_TrackerNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 start_id = 1;
    if (has_start_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_id());
    }

  }
  // repeated uint64 updated = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->updated_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->updated(i));
    }
    total_size += 1 * this->updated_size() + data_size;
  }

  // repeated uint64 deleted = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->deleted_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->deleted(i));
    }
    total_size += 1 * this->deleted_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureStoreTracker_TrackerNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProcedureStoreTracker_TrackerNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProcedureStoreTracker_TrackerNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProcedureStoreTracker_TrackerNode::MergeFrom(const ProcedureStoreTracker_TrackerNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  updated_.MergeFrom(from.updated_);
  deleted_.MergeFrom(from.deleted_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_id()) {
      set_start_id(from.start_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProcedureStoreTracker_TrackerNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureStoreTracker_TrackerNode::CopyFrom(const ProcedureStoreTracker_TrackerNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureStoreTracker_TrackerNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ProcedureStoreTracker_TrackerNode::Swap(ProcedureStoreTracker_TrackerNode* other) {
  if (other != this) {
    std::swap(start_id_, other->start_id_);
    updated_.Swap(&other->updated_);
    deleted_.Swap(&other->deleted_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProcedureStoreTracker_TrackerNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureStoreTracker_TrackerNode_descriptor_;
  metadata.reflection = ProcedureStoreTracker_TrackerNode_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ProcedureStoreTracker::kNodeFieldNumber;
#endif  // !_MSC_VER

ProcedureStoreTracker::ProcedureStoreTracker()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProcedureStoreTracker::InitAsDefaultInstance() {
}

ProcedureStoreTracker::ProcedureStoreTracker(const ProcedureStoreTracker& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProcedureStoreTracker::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcedureStoreTracker::~ProcedureStoreTracker() {
  SharedDtor();
}

void ProcedureStoreTracker::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureStoreTracker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureStoreTracker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureStoreTracker_descriptor_;
}

const ProcedureStoreTracker& ProcedureStoreTracker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

ProcedureStoreTracker* ProcedureStoreTracker::default_instance_ = NULL;

ProcedureStoreTracker* ProcedureStoreTracker::New() const {
  return new ProcedureStoreTracker;
}

void ProcedureStoreTracker::Clear() {
  node_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProcedureStoreTracker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.ProcedureStoreTracker.TrackerNode node = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_node;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProcedureStoreTracker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.ProcedureStoreTracker.TrackerNode node = 1;
  for (int i = 0; i < this->node_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProcedureStoreTracker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.ProcedureStoreTracker.TrackerNode node = 1;
  for (int i = 0; i < this->node_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProcedureStoreTracker::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.ProcedureStoreTracker.TrackerNode node = 1;
  total_size += 1 * this->node_size();
  for (int i = 0; i < this->node_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->node(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureStoreTracker::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProcedureStoreTracker* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProcedureStoreTracker*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProcedureStoreTracker::MergeFrom(const ProcedureStoreTracker& from) {
  GOOGLE_CHECK_NE(&from, this);
  node_.MergeFrom(from.node_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProcedureStoreTracker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureStoreTracker::CopyFrom(const ProcedureStoreTracker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureStoreTracker::IsInitialized() const {

  for (int i = 0; i < node_size(); i++) {
    if (!this->node(i).IsInitialized()) return false;
  }
  return true;
}

void ProcedureStoreTracker::Swap(ProcedureStoreTracker* other) {
  if (other != this) {
    node_.Swap(&other->node_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProcedureStoreTracker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureStoreTracker_descriptor_;
  metadata.reflection = ProcedureStoreTracker_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ProcedureWALEntry_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureWALEntry_Type_descriptor_;
}
bool ProcedureWALEntry_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_EOF;
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_INIT;
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_INSERT;
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_UPDATE;
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_DELETE;
const ProcedureWALEntry_Type ProcedureWALEntry::PROCEDURE_WAL_COMPACT;
const ProcedureWALEntry_Type ProcedureWALEntry::Type_MIN;
const ProcedureWALEntry_Type ProcedureWALEntry::Type_MAX;
const int ProcedureWALEntry::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ProcedureWALEntry::kTypeFieldNumber;
const int ProcedureWALEntry::kProcedureFieldNumber;
const int ProcedureWALEntry::kProcIdFieldNumber;
#endif  // !_MSC_VER

ProcedureWALEntry::ProcedureWALEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProcedureWALEntry::InitAsDefaultInstance() {
}

ProcedureWALEntry::ProcedureWALEntry(const ProcedureWALEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProcedureWALEntry::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  proc_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcedureWALEntry::~ProcedureWALEntry() {
  SharedDtor();
}

void ProcedureWALEntry::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureWALEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureWALEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureWALEntry_descriptor_;
}

const ProcedureWALEntry& ProcedureWALEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Procedure_2eproto();
  return *default_instance_;
}

ProcedureWALEntry* ProcedureWALEntry::default_instance_ = NULL;

ProcedureWALEntry* ProcedureWALEntry::New() const {
  return new ProcedureWALEntry;
}

void ProcedureWALEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    proc_id_ = GOOGLE_ULONGLONG(0);
  }
  procedure_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProcedureWALEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.ProcedureWALEntry.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::ProcedureWALEntry_Type_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::ProcedureWALEntry_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_procedure;
        break;
      }

      // repeated .hbase.pb.Procedure procedure = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_procedure:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_procedure()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_procedure;
        if (input->ExpectTag(24)) goto parse_proc_id;
        break;
      }

      // optional uint64 proc_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_proc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &proc_id_)));
          set_has_proc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProcedureWALEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.ProcedureWALEntry.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // repeated .hbase.pb.Procedure procedure = 2;
  for (int i = 0; i < this->procedure_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->procedure(i), output);
  }

  // optional uint64 proc_id = 3;
  if (has_proc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->proc_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProcedureWALEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.ProcedureWALEntry.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // repeated .hbase.pb.Procedure procedure = 2;
  for (int i = 0; i < this->procedure_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->procedure(i), target);
  }

  // optional uint64 proc_id = 3;
  if (has_proc_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->proc_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProcedureWALEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.ProcedureWALEntry.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 proc_id = 3;
    if (has_proc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->proc_id());
    }

  }
  // repeated .hbase.pb.Procedure procedure = 2;
  total_size += 1 * this->procedure_size();
  for (int i = 0; i < this->procedure_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->procedure(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureWALEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProcedureWALEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProcedureWALEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProcedureWALEntry::MergeFrom(const ProcedureWALEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  procedure_.MergeFrom(from.procedure_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_proc_id()) {
      set_proc_id(from.proc_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProcedureWALEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureWALEntry::CopyFrom(const ProcedureWALEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureWALEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < procedure_size(); i++) {
    if (!this->procedure(i).IsInitialized()) return false;
  }
  return true;
}

void ProcedureWALEntry::Swap(ProcedureWALEntry* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    procedure_.Swap(&other->procedure_);
    std::swap(proc_id_, other->proc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProcedureWALEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureWALEntry_descriptor_;
  metadata.reflection = ProcedureWALEntry_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

// @@protoc_insertion_point(global_scope)
