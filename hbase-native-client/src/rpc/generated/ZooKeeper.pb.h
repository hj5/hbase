// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZooKeeper.proto

#ifndef PROTOBUF_ZooKeeper_2eproto__INCLUDED
#define PROTOBUF_ZooKeeper_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "ClusterStatus.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZooKeeper_2eproto();
void protobuf_AssignDesc_ZooKeeper_2eproto();
void protobuf_ShutdownFile_ZooKeeper_2eproto();

class MetaRegionServer;
class Master;
class ClusterUp;
class SplitLogTask;
class DeprecatedTableState;
class ReplicationPeer;
class ReplicationState;
class ReplicationHLogPosition;
class ReplicationLock;
class TableLock;
class SwitchState;

enum SplitLogTask_State {
  SplitLogTask_State_UNASSIGNED = 0,
  SplitLogTask_State_OWNED = 1,
  SplitLogTask_State_RESIGNED = 2,
  SplitLogTask_State_DONE = 3,
  SplitLogTask_State_ERR = 4
};
bool SplitLogTask_State_IsValid(int value);
const SplitLogTask_State SplitLogTask_State_State_MIN = SplitLogTask_State_UNASSIGNED;
const SplitLogTask_State SplitLogTask_State_State_MAX = SplitLogTask_State_ERR;
const int SplitLogTask_State_State_ARRAYSIZE = SplitLogTask_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitLogTask_State_descriptor();
inline const ::std::string& SplitLogTask_State_Name(SplitLogTask_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitLogTask_State_descriptor(), value);
}
inline bool SplitLogTask_State_Parse(
    const ::std::string& name, SplitLogTask_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitLogTask_State>(
    SplitLogTask_State_descriptor(), name, value);
}
enum SplitLogTask_RecoveryMode {
  SplitLogTask_RecoveryMode_UNKNOWN = 0,
  SplitLogTask_RecoveryMode_LOG_SPLITTING = 1,
  SplitLogTask_RecoveryMode_LOG_REPLAY = 2
};
bool SplitLogTask_RecoveryMode_IsValid(int value);
const SplitLogTask_RecoveryMode SplitLogTask_RecoveryMode_RecoveryMode_MIN = SplitLogTask_RecoveryMode_UNKNOWN;
const SplitLogTask_RecoveryMode SplitLogTask_RecoveryMode_RecoveryMode_MAX = SplitLogTask_RecoveryMode_LOG_REPLAY;
const int SplitLogTask_RecoveryMode_RecoveryMode_ARRAYSIZE = SplitLogTask_RecoveryMode_RecoveryMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitLogTask_RecoveryMode_descriptor();
inline const ::std::string& SplitLogTask_RecoveryMode_Name(SplitLogTask_RecoveryMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitLogTask_RecoveryMode_descriptor(), value);
}
inline bool SplitLogTask_RecoveryMode_Parse(
    const ::std::string& name, SplitLogTask_RecoveryMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitLogTask_RecoveryMode>(
    SplitLogTask_RecoveryMode_descriptor(), name, value);
}
enum DeprecatedTableState_State {
  DeprecatedTableState_State_ENABLED = 0,
  DeprecatedTableState_State_DISABLED = 1,
  DeprecatedTableState_State_DISABLING = 2,
  DeprecatedTableState_State_ENABLING = 3
};
bool DeprecatedTableState_State_IsValid(int value);
const DeprecatedTableState_State DeprecatedTableState_State_State_MIN = DeprecatedTableState_State_ENABLED;
const DeprecatedTableState_State DeprecatedTableState_State_State_MAX = DeprecatedTableState_State_ENABLING;
const int DeprecatedTableState_State_State_ARRAYSIZE = DeprecatedTableState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeprecatedTableState_State_descriptor();
inline const ::std::string& DeprecatedTableState_State_Name(DeprecatedTableState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeprecatedTableState_State_descriptor(), value);
}
inline bool DeprecatedTableState_State_Parse(
    const ::std::string& name, DeprecatedTableState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeprecatedTableState_State>(
    DeprecatedTableState_State_descriptor(), name, value);
}
enum ReplicationState_State {
  ReplicationState_State_ENABLED = 0,
  ReplicationState_State_DISABLED = 1
};
bool ReplicationState_State_IsValid(int value);
const ReplicationState_State ReplicationState_State_State_MIN = ReplicationState_State_ENABLED;
const ReplicationState_State ReplicationState_State_State_MAX = ReplicationState_State_DISABLED;
const int ReplicationState_State_State_ARRAYSIZE = ReplicationState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReplicationState_State_descriptor();
inline const ::std::string& ReplicationState_State_Name(ReplicationState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReplicationState_State_descriptor(), value);
}
inline bool ReplicationState_State_Parse(
    const ::std::string& name, ReplicationState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReplicationState_State>(
    ReplicationState_State_descriptor(), name, value);
}
// ===================================================================

class MetaRegionServer : public ::google::protobuf::Message {
 public:
  MetaRegionServer();
  virtual ~MetaRegionServer();

  MetaRegionServer(const MetaRegionServer& from);

  inline MetaRegionServer& operator=(const MetaRegionServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaRegionServer& default_instance();

  void Swap(MetaRegionServer* other);

  // implements Message ----------------------------------------------

  MetaRegionServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaRegionServer& from);
  void MergeFrom(const MetaRegionServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.ServerName server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::hbase::pb::ServerName& server() const;
  inline ::hbase::pb::ServerName* mutable_server();
  inline ::hbase::pb::ServerName* release_server();
  inline void set_allocated_server(::hbase::pb::ServerName* server);

  // optional uint32 rpc_version = 2;
  inline bool has_rpc_version() const;
  inline void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 rpc_version() const;
  inline void set_rpc_version(::google::protobuf::uint32 value);

  // optional .hbase.pb.RegionState.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::hbase::pb::RegionState_State state() const;
  inline void set_state(::hbase::pb::RegionState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MetaRegionServer)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_rpc_version();
  inline void clear_has_rpc_version();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::ServerName* server_;
  ::google::protobuf::uint32 rpc_version_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static MetaRegionServer* default_instance_;
};
// -------------------------------------------------------------------

class Master : public ::google::protobuf::Message {
 public:
  Master();
  virtual ~Master();

  Master(const Master& from);

  inline Master& operator=(const Master& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Master& default_instance();

  void Swap(Master* other);

  // implements Message ----------------------------------------------

  Master* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Master& from);
  void MergeFrom(const Master& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.ServerName master = 1;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 1;
  inline const ::hbase::pb::ServerName& master() const;
  inline ::hbase::pb::ServerName* mutable_master();
  inline ::hbase::pb::ServerName* release_master();
  inline void set_allocated_master(::hbase::pb::ServerName* master);

  // optional uint32 rpc_version = 2;
  inline bool has_rpc_version() const;
  inline void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 rpc_version() const;
  inline void set_rpc_version(::google::protobuf::uint32 value);

  // optional uint32 info_port = 3;
  inline bool has_info_port() const;
  inline void clear_info_port();
  static const int kInfoPortFieldNumber = 3;
  inline ::google::protobuf::uint32 info_port() const;
  inline void set_info_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Master)
 private:
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_rpc_version();
  inline void clear_has_rpc_version();
  inline void set_has_info_port();
  inline void clear_has_info_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::ServerName* master_;
  ::google::protobuf::uint32 rpc_version_;
  ::google::protobuf::uint32 info_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static Master* default_instance_;
};
// -------------------------------------------------------------------

class ClusterUp : public ::google::protobuf::Message {
 public:
  ClusterUp();
  virtual ~ClusterUp();

  ClusterUp(const ClusterUp& from);

  inline ClusterUp& operator=(const ClusterUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterUp& default_instance();

  void Swap(ClusterUp* other);

  // implements Message ----------------------------------------------

  ClusterUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterUp& from);
  void MergeFrom(const ClusterUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const char* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // @@protoc_insertion_point(class_scope:hbase.pb.ClusterUp)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* start_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static ClusterUp* default_instance_;
};
// -------------------------------------------------------------------

class SplitLogTask : public ::google::protobuf::Message {
 public:
  SplitLogTask();
  virtual ~SplitLogTask();

  SplitLogTask(const SplitLogTask& from);

  inline SplitLogTask& operator=(const SplitLogTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitLogTask& default_instance();

  void Swap(SplitLogTask* other);

  // implements Message ----------------------------------------------

  SplitLogTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SplitLogTask& from);
  void MergeFrom(const SplitLogTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SplitLogTask_State State;
  static const State UNASSIGNED = SplitLogTask_State_UNASSIGNED;
  static const State OWNED = SplitLogTask_State_OWNED;
  static const State RESIGNED = SplitLogTask_State_RESIGNED;
  static const State DONE = SplitLogTask_State_DONE;
  static const State ERR = SplitLogTask_State_ERR;
  static inline bool State_IsValid(int value) {
    return SplitLogTask_State_IsValid(value);
  }
  static const State State_MIN =
    SplitLogTask_State_State_MIN;
  static const State State_MAX =
    SplitLogTask_State_State_MAX;
  static const int State_ARRAYSIZE =
    SplitLogTask_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return SplitLogTask_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return SplitLogTask_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return SplitLogTask_State_Parse(name, value);
  }

  typedef SplitLogTask_RecoveryMode RecoveryMode;
  static const RecoveryMode UNKNOWN = SplitLogTask_RecoveryMode_UNKNOWN;
  static const RecoveryMode LOG_SPLITTING = SplitLogTask_RecoveryMode_LOG_SPLITTING;
  static const RecoveryMode LOG_REPLAY = SplitLogTask_RecoveryMode_LOG_REPLAY;
  static inline bool RecoveryMode_IsValid(int value) {
    return SplitLogTask_RecoveryMode_IsValid(value);
  }
  static const RecoveryMode RecoveryMode_MIN =
    SplitLogTask_RecoveryMode_RecoveryMode_MIN;
  static const RecoveryMode RecoveryMode_MAX =
    SplitLogTask_RecoveryMode_RecoveryMode_MAX;
  static const int RecoveryMode_ARRAYSIZE =
    SplitLogTask_RecoveryMode_RecoveryMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecoveryMode_descriptor() {
    return SplitLogTask_RecoveryMode_descriptor();
  }
  static inline const ::std::string& RecoveryMode_Name(RecoveryMode value) {
    return SplitLogTask_RecoveryMode_Name(value);
  }
  static inline bool RecoveryMode_Parse(const ::std::string& name,
      RecoveryMode* value) {
    return SplitLogTask_RecoveryMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.SplitLogTask.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::hbase::pb::SplitLogTask_State state() const;
  inline void set_state(::hbase::pb::SplitLogTask_State value);

  // required .hbase.pb.ServerName server_name = 2;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 2;
  inline const ::hbase::pb::ServerName& server_name() const;
  inline ::hbase::pb::ServerName* mutable_server_name();
  inline ::hbase::pb::ServerName* release_server_name();
  inline void set_allocated_server_name(::hbase::pb::ServerName* server_name);

  // optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::hbase::pb::SplitLogTask_RecoveryMode mode() const;
  inline void set_mode(::hbase::pb::SplitLogTask_RecoveryMode value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SplitLogTask)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::ServerName* server_name_;
  int state_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static SplitLogTask* default_instance_;
};
// -------------------------------------------------------------------

class DeprecatedTableState : public ::google::protobuf::Message {
 public:
  DeprecatedTableState();
  virtual ~DeprecatedTableState();

  DeprecatedTableState(const DeprecatedTableState& from);

  inline DeprecatedTableState& operator=(const DeprecatedTableState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeprecatedTableState& default_instance();

  void Swap(DeprecatedTableState* other);

  // implements Message ----------------------------------------------

  DeprecatedTableState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeprecatedTableState& from);
  void MergeFrom(const DeprecatedTableState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DeprecatedTableState_State State;
  static const State ENABLED = DeprecatedTableState_State_ENABLED;
  static const State DISABLED = DeprecatedTableState_State_DISABLED;
  static const State DISABLING = DeprecatedTableState_State_DISABLING;
  static const State ENABLING = DeprecatedTableState_State_ENABLING;
  static inline bool State_IsValid(int value) {
    return DeprecatedTableState_State_IsValid(value);
  }
  static const State State_MIN =
    DeprecatedTableState_State_State_MIN;
  static const State State_MAX =
    DeprecatedTableState_State_State_MAX;
  static const int State_ARRAYSIZE =
    DeprecatedTableState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return DeprecatedTableState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return DeprecatedTableState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return DeprecatedTableState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::hbase::pb::DeprecatedTableState_State state() const;
  inline void set_state(::hbase::pb::DeprecatedTableState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DeprecatedTableState)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static DeprecatedTableState* default_instance_;
};
// -------------------------------------------------------------------

class ReplicationPeer : public ::google::protobuf::Message {
 public:
  ReplicationPeer();
  virtual ~ReplicationPeer();

  ReplicationPeer(const ReplicationPeer& from);

  inline ReplicationPeer& operator=(const ReplicationPeer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicationPeer& default_instance();

  void Swap(ReplicationPeer* other);

  // implements Message ----------------------------------------------

  ReplicationPeer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicationPeer& from);
  void MergeFrom(const ReplicationPeer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string clusterkey = 1;
  inline bool has_clusterkey() const;
  inline void clear_clusterkey();
  static const int kClusterkeyFieldNumber = 1;
  inline const ::std::string& clusterkey() const;
  inline void set_clusterkey(const ::std::string& value);
  inline void set_clusterkey(const char* value);
  inline void set_clusterkey(const char* value, size_t size);
  inline ::std::string* mutable_clusterkey();
  inline ::std::string* release_clusterkey();
  inline void set_allocated_clusterkey(::std::string* clusterkey);

  // optional string replicationEndpointImpl = 2;
  inline bool has_replicationendpointimpl() const;
  inline void clear_replicationendpointimpl();
  static const int kReplicationEndpointImplFieldNumber = 2;
  inline const ::std::string& replicationendpointimpl() const;
  inline void set_replicationendpointimpl(const ::std::string& value);
  inline void set_replicationendpointimpl(const char* value);
  inline void set_replicationendpointimpl(const char* value, size_t size);
  inline ::std::string* mutable_replicationendpointimpl();
  inline ::std::string* release_replicationendpointimpl();
  inline void set_allocated_replicationendpointimpl(::std::string* replicationendpointimpl);

  // repeated .hbase.pb.BytesBytesPair data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::hbase::pb::BytesBytesPair& data(int index) const;
  inline ::hbase::pb::BytesBytesPair* mutable_data(int index);
  inline ::hbase::pb::BytesBytesPair* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_data();

  // repeated .hbase.pb.NameStringPair configuration = 4;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 4;
  inline const ::hbase::pb::NameStringPair& configuration(int index) const;
  inline ::hbase::pb::NameStringPair* mutable_configuration(int index);
  inline ::hbase::pb::NameStringPair* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationPeer)
 private:
  inline void set_has_clusterkey();
  inline void clear_has_clusterkey();
  inline void set_has_replicationendpointimpl();
  inline void clear_has_replicationendpointimpl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clusterkey_;
  ::std::string* replicationendpointimpl_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair > data_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static ReplicationPeer* default_instance_;
};
// -------------------------------------------------------------------

class ReplicationState : public ::google::protobuf::Message {
 public:
  ReplicationState();
  virtual ~ReplicationState();

  ReplicationState(const ReplicationState& from);

  inline ReplicationState& operator=(const ReplicationState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicationState& default_instance();

  void Swap(ReplicationState* other);

  // implements Message ----------------------------------------------

  ReplicationState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicationState& from);
  void MergeFrom(const ReplicationState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReplicationState_State State;
  static const State ENABLED = ReplicationState_State_ENABLED;
  static const State DISABLED = ReplicationState_State_DISABLED;
  static inline bool State_IsValid(int value) {
    return ReplicationState_State_IsValid(value);
  }
  static const State State_MIN =
    ReplicationState_State_State_MIN;
  static const State State_MAX =
    ReplicationState_State_State_MAX;
  static const int State_ARRAYSIZE =
    ReplicationState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ReplicationState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ReplicationState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ReplicationState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.ReplicationState.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::hbase::pb::ReplicationState_State state() const;
  inline void set_state(::hbase::pb::ReplicationState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationState)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static ReplicationState* default_instance_;
};
// -------------------------------------------------------------------

class ReplicationHLogPosition : public ::google::protobuf::Message {
 public:
  ReplicationHLogPosition();
  virtual ~ReplicationHLogPosition();

  ReplicationHLogPosition(const ReplicationHLogPosition& from);

  inline ReplicationHLogPosition& operator=(const ReplicationHLogPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicationHLogPosition& default_instance();

  void Swap(ReplicationHLogPosition* other);

  // implements Message ----------------------------------------------

  ReplicationHLogPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicationHLogPosition& from);
  void MergeFrom(const ReplicationHLogPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::google::protobuf::int64 position() const;
  inline void set_position(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationHLogPosition)
 private:
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static ReplicationHLogPosition* default_instance_;
};
// -------------------------------------------------------------------

class ReplicationLock : public ::google::protobuf::Message {
 public:
  ReplicationLock();
  virtual ~ReplicationLock();

  ReplicationLock(const ReplicationLock& from);

  inline ReplicationLock& operator=(const ReplicationLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicationLock& default_instance();

  void Swap(ReplicationLock* other);

  // implements Message ----------------------------------------------

  ReplicationLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicationLock& from);
  void MergeFrom(const ReplicationLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string lock_owner = 1;
  inline bool has_lock_owner() const;
  inline void clear_lock_owner();
  static const int kLockOwnerFieldNumber = 1;
  inline const ::std::string& lock_owner() const;
  inline void set_lock_owner(const ::std::string& value);
  inline void set_lock_owner(const char* value);
  inline void set_lock_owner(const char* value, size_t size);
  inline ::std::string* mutable_lock_owner();
  inline ::std::string* release_lock_owner();
  inline void set_allocated_lock_owner(::std::string* lock_owner);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationLock)
 private:
  inline void set_has_lock_owner();
  inline void clear_has_lock_owner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lock_owner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static ReplicationLock* default_instance_;
};
// -------------------------------------------------------------------

class TableLock : public ::google::protobuf::Message {
 public:
  TableLock();
  virtual ~TableLock();

  TableLock(const TableLock& from);

  inline TableLock& operator=(const TableLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableLock& default_instance();

  void Swap(TableLock* other);

  // implements Message ----------------------------------------------

  TableLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableLock& from);
  void MergeFrom(const TableLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.TableName table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional .hbase.pb.ServerName lock_owner = 2;
  inline bool has_lock_owner() const;
  inline void clear_lock_owner();
  static const int kLockOwnerFieldNumber = 2;
  inline const ::hbase::pb::ServerName& lock_owner() const;
  inline ::hbase::pb::ServerName* mutable_lock_owner();
  inline ::hbase::pb::ServerName* release_lock_owner();
  inline void set_allocated_lock_owner(::hbase::pb::ServerName* lock_owner);

  // optional int64 thread_id = 3;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 3;
  inline ::google::protobuf::int64 thread_id() const;
  inline void set_thread_id(::google::protobuf::int64 value);

  // optional bool is_shared = 4;
  inline bool has_is_shared() const;
  inline void clear_is_shared();
  static const int kIsSharedFieldNumber = 4;
  inline bool is_shared() const;
  inline void set_is_shared(bool value);

  // optional string purpose = 5;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 5;
  inline const ::std::string& purpose() const;
  inline void set_purpose(const ::std::string& value);
  inline void set_purpose(const char* value);
  inline void set_purpose(const char* value, size_t size);
  inline ::std::string* mutable_purpose();
  inline ::std::string* release_purpose();
  inline void set_allocated_purpose(::std::string* purpose);

  // optional int64 create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 create_time() const;
  inline void set_create_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableLock)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_lock_owner();
  inline void clear_has_lock_owner();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_is_shared();
  inline void clear_has_is_shared();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;
  ::hbase::pb::ServerName* lock_owner_;
  ::google::protobuf::int64 thread_id_;
  ::std::string* purpose_;
  ::google::protobuf::int64 create_time_;
  bool is_shared_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static TableLock* default_instance_;
};
// -------------------------------------------------------------------

class SwitchState : public ::google::protobuf::Message {
 public:
  SwitchState();
  virtual ~SwitchState();

  SwitchState(const SwitchState& from);

  inline SwitchState& operator=(const SwitchState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchState& default_instance();

  void Swap(SwitchState* other);

  // implements Message ----------------------------------------------

  SwitchState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchState& from);
  void MergeFrom(const SwitchState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SwitchState)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ZooKeeper_2eproto();
  friend void protobuf_AssignDesc_ZooKeeper_2eproto();
  friend void protobuf_ShutdownFile_ZooKeeper_2eproto();

  void InitAsDefaultInstance();
  static SwitchState* default_instance_;
};
// ===================================================================


// ===================================================================

// MetaRegionServer

// required .hbase.pb.ServerName server = 1;
inline bool MetaRegionServer::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaRegionServer::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaRegionServer::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaRegionServer::clear_server() {
  if (server_ != NULL) server_->::hbase::pb::ServerName::Clear();
  clear_has_server();
}
inline const ::hbase::pb::ServerName& MetaRegionServer::server() const {
  return server_ != NULL ? *server_ : *default_instance_->server_;
}
inline ::hbase::pb::ServerName* MetaRegionServer::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::hbase::pb::ServerName;
  return server_;
}
inline ::hbase::pb::ServerName* MetaRegionServer::release_server() {
  clear_has_server();
  ::hbase::pb::ServerName* temp = server_;
  server_ = NULL;
  return temp;
}
inline void MetaRegionServer::set_allocated_server(::hbase::pb::ServerName* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional uint32 rpc_version = 2;
inline bool MetaRegionServer::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaRegionServer::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaRegionServer::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaRegionServer::clear_rpc_version() {
  rpc_version_ = 0u;
  clear_has_rpc_version();
}
inline ::google::protobuf::uint32 MetaRegionServer::rpc_version() const {
  return rpc_version_;
}
inline void MetaRegionServer::set_rpc_version(::google::protobuf::uint32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
}

// optional .hbase.pb.RegionState.State state = 3;
inline bool MetaRegionServer::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaRegionServer::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaRegionServer::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaRegionServer::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hbase::pb::RegionState_State MetaRegionServer::state() const {
  return static_cast< ::hbase::pb::RegionState_State >(state_);
}
inline void MetaRegionServer::set_state(::hbase::pb::RegionState_State value) {
  assert(::hbase::pb::RegionState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// Master

// required .hbase.pb.ServerName master = 1;
inline bool Master::has_master() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Master::set_has_master() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Master::clear_has_master() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Master::clear_master() {
  if (master_ != NULL) master_->::hbase::pb::ServerName::Clear();
  clear_has_master();
}
inline const ::hbase::pb::ServerName& Master::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::hbase::pb::ServerName* Master::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::hbase::pb::ServerName;
  return master_;
}
inline ::hbase::pb::ServerName* Master::release_master() {
  clear_has_master();
  ::hbase::pb::ServerName* temp = master_;
  master_ = NULL;
  return temp;
}
inline void Master::set_allocated_master(::hbase::pb::ServerName* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// optional uint32 rpc_version = 2;
inline bool Master::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Master::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Master::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Master::clear_rpc_version() {
  rpc_version_ = 0u;
  clear_has_rpc_version();
}
inline ::google::protobuf::uint32 Master::rpc_version() const {
  return rpc_version_;
}
inline void Master::set_rpc_version(::google::protobuf::uint32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
}

// optional uint32 info_port = 3;
inline bool Master::has_info_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Master::set_has_info_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Master::clear_has_info_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Master::clear_info_port() {
  info_port_ = 0u;
  clear_has_info_port();
}
inline ::google::protobuf::uint32 Master::info_port() const {
  return info_port_;
}
inline void Master::set_info_port(::google::protobuf::uint32 value) {
  set_has_info_port();
  info_port_ = value;
}

// -------------------------------------------------------------------

// ClusterUp

// required string start_date = 1;
inline bool ClusterUp::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterUp::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterUp::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterUp::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& ClusterUp::start_date() const {
  return *start_date_;
}
inline void ClusterUp::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void ClusterUp::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void ClusterUp::set_start_date(const char* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClusterUp::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  return start_date_;
}
inline ::std::string* ClusterUp::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClusterUp::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SplitLogTask

// required .hbase.pb.SplitLogTask.State state = 1;
inline bool SplitLogTask::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SplitLogTask::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SplitLogTask::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SplitLogTask::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hbase::pb::SplitLogTask_State SplitLogTask::state() const {
  return static_cast< ::hbase::pb::SplitLogTask_State >(state_);
}
inline void SplitLogTask::set_state(::hbase::pb::SplitLogTask_State value) {
  assert(::hbase::pb::SplitLogTask_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// required .hbase.pb.ServerName server_name = 2;
inline bool SplitLogTask::has_server_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SplitLogTask::set_has_server_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SplitLogTask::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SplitLogTask::clear_server_name() {
  if (server_name_ != NULL) server_name_->::hbase::pb::ServerName::Clear();
  clear_has_server_name();
}
inline const ::hbase::pb::ServerName& SplitLogTask::server_name() const {
  return server_name_ != NULL ? *server_name_ : *default_instance_->server_name_;
}
inline ::hbase::pb::ServerName* SplitLogTask::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == NULL) server_name_ = new ::hbase::pb::ServerName;
  return server_name_;
}
inline ::hbase::pb::ServerName* SplitLogTask::release_server_name() {
  clear_has_server_name();
  ::hbase::pb::ServerName* temp = server_name_;
  server_name_ = NULL;
  return temp;
}
inline void SplitLogTask::set_allocated_server_name(::hbase::pb::ServerName* server_name) {
  delete server_name_;
  server_name_ = server_name;
  if (server_name) {
    set_has_server_name();
  } else {
    clear_has_server_name();
  }
}

// optional .hbase.pb.SplitLogTask.RecoveryMode mode = 3 [default = UNKNOWN];
inline bool SplitLogTask::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SplitLogTask::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SplitLogTask::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SplitLogTask::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::hbase::pb::SplitLogTask_RecoveryMode SplitLogTask::mode() const {
  return static_cast< ::hbase::pb::SplitLogTask_RecoveryMode >(mode_);
}
inline void SplitLogTask::set_mode(::hbase::pb::SplitLogTask_RecoveryMode value) {
  assert(::hbase::pb::SplitLogTask_RecoveryMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// DeprecatedTableState

// required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
inline bool DeprecatedTableState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeprecatedTableState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeprecatedTableState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeprecatedTableState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hbase::pb::DeprecatedTableState_State DeprecatedTableState::state() const {
  return static_cast< ::hbase::pb::DeprecatedTableState_State >(state_);
}
inline void DeprecatedTableState::set_state(::hbase::pb::DeprecatedTableState_State value) {
  assert(::hbase::pb::DeprecatedTableState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ReplicationPeer

// required string clusterkey = 1;
inline bool ReplicationPeer::has_clusterkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationPeer::set_has_clusterkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicationPeer::clear_has_clusterkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicationPeer::clear_clusterkey() {
  if (clusterkey_ != &::google::protobuf::internal::kEmptyString) {
    clusterkey_->clear();
  }
  clear_has_clusterkey();
}
inline const ::std::string& ReplicationPeer::clusterkey() const {
  return *clusterkey_;
}
inline void ReplicationPeer::set_clusterkey(const ::std::string& value) {
  set_has_clusterkey();
  if (clusterkey_ == &::google::protobuf::internal::kEmptyString) {
    clusterkey_ = new ::std::string;
  }
  clusterkey_->assign(value);
}
inline void ReplicationPeer::set_clusterkey(const char* value) {
  set_has_clusterkey();
  if (clusterkey_ == &::google::protobuf::internal::kEmptyString) {
    clusterkey_ = new ::std::string;
  }
  clusterkey_->assign(value);
}
inline void ReplicationPeer::set_clusterkey(const char* value, size_t size) {
  set_has_clusterkey();
  if (clusterkey_ == &::google::protobuf::internal::kEmptyString) {
    clusterkey_ = new ::std::string;
  }
  clusterkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplicationPeer::mutable_clusterkey() {
  set_has_clusterkey();
  if (clusterkey_ == &::google::protobuf::internal::kEmptyString) {
    clusterkey_ = new ::std::string;
  }
  return clusterkey_;
}
inline ::std::string* ReplicationPeer::release_clusterkey() {
  clear_has_clusterkey();
  if (clusterkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clusterkey_;
    clusterkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplicationPeer::set_allocated_clusterkey(::std::string* clusterkey) {
  if (clusterkey_ != &::google::protobuf::internal::kEmptyString) {
    delete clusterkey_;
  }
  if (clusterkey) {
    set_has_clusterkey();
    clusterkey_ = clusterkey;
  } else {
    clear_has_clusterkey();
    clusterkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string replicationEndpointImpl = 2;
inline bool ReplicationPeer::has_replicationendpointimpl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplicationPeer::set_has_replicationendpointimpl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplicationPeer::clear_has_replicationendpointimpl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplicationPeer::clear_replicationendpointimpl() {
  if (replicationendpointimpl_ != &::google::protobuf::internal::kEmptyString) {
    replicationendpointimpl_->clear();
  }
  clear_has_replicationendpointimpl();
}
inline const ::std::string& ReplicationPeer::replicationendpointimpl() const {
  return *replicationendpointimpl_;
}
inline void ReplicationPeer::set_replicationendpointimpl(const ::std::string& value) {
  set_has_replicationendpointimpl();
  if (replicationendpointimpl_ == &::google::protobuf::internal::kEmptyString) {
    replicationendpointimpl_ = new ::std::string;
  }
  replicationendpointimpl_->assign(value);
}
inline void ReplicationPeer::set_replicationendpointimpl(const char* value) {
  set_has_replicationendpointimpl();
  if (replicationendpointimpl_ == &::google::protobuf::internal::kEmptyString) {
    replicationendpointimpl_ = new ::std::string;
  }
  replicationendpointimpl_->assign(value);
}
inline void ReplicationPeer::set_replicationendpointimpl(const char* value, size_t size) {
  set_has_replicationendpointimpl();
  if (replicationendpointimpl_ == &::google::protobuf::internal::kEmptyString) {
    replicationendpointimpl_ = new ::std::string;
  }
  replicationendpointimpl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplicationPeer::mutable_replicationendpointimpl() {
  set_has_replicationendpointimpl();
  if (replicationendpointimpl_ == &::google::protobuf::internal::kEmptyString) {
    replicationendpointimpl_ = new ::std::string;
  }
  return replicationendpointimpl_;
}
inline ::std::string* ReplicationPeer::release_replicationendpointimpl() {
  clear_has_replicationendpointimpl();
  if (replicationendpointimpl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = replicationendpointimpl_;
    replicationendpointimpl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplicationPeer::set_allocated_replicationendpointimpl(::std::string* replicationendpointimpl) {
  if (replicationendpointimpl_ != &::google::protobuf::internal::kEmptyString) {
    delete replicationendpointimpl_;
  }
  if (replicationendpointimpl) {
    set_has_replicationendpointimpl();
    replicationendpointimpl_ = replicationendpointimpl;
  } else {
    clear_has_replicationendpointimpl();
    replicationendpointimpl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.BytesBytesPair data = 3;
inline int ReplicationPeer::data_size() const {
  return data_.size();
}
inline void ReplicationPeer::clear_data() {
  data_.Clear();
}
inline const ::hbase::pb::BytesBytesPair& ReplicationPeer::data(int index) const {
  return data_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* ReplicationPeer::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::hbase::pb::BytesBytesPair* ReplicationPeer::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
ReplicationPeer::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
ReplicationPeer::mutable_data() {
  return &data_;
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int ReplicationPeer::configuration_size() const {
  return configuration_.size();
}
inline void ReplicationPeer::clear_configuration() {
  configuration_.Clear();
}
inline const ::hbase::pb::NameStringPair& ReplicationPeer::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ReplicationPeer::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::hbase::pb::NameStringPair* ReplicationPeer::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ReplicationPeer::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ReplicationPeer::mutable_configuration() {
  return &configuration_;
}

// -------------------------------------------------------------------

// ReplicationState

// required .hbase.pb.ReplicationState.State state = 1;
inline bool ReplicationState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicationState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicationState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hbase::pb::ReplicationState_State ReplicationState::state() const {
  return static_cast< ::hbase::pb::ReplicationState_State >(state_);
}
inline void ReplicationState::set_state(::hbase::pb::ReplicationState_State value) {
  assert(::hbase::pb::ReplicationState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ReplicationHLogPosition

// required int64 position = 1;
inline bool ReplicationHLogPosition::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationHLogPosition::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicationHLogPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicationHLogPosition::clear_position() {
  position_ = GOOGLE_LONGLONG(0);
  clear_has_position();
}
inline ::google::protobuf::int64 ReplicationHLogPosition::position() const {
  return position_;
}
inline void ReplicationHLogPosition::set_position(::google::protobuf::int64 value) {
  set_has_position();
  position_ = value;
}

// -------------------------------------------------------------------

// ReplicationLock

// required string lock_owner = 1;
inline bool ReplicationLock::has_lock_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationLock::set_has_lock_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicationLock::clear_has_lock_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicationLock::clear_lock_owner() {
  if (lock_owner_ != &::google::protobuf::internal::kEmptyString) {
    lock_owner_->clear();
  }
  clear_has_lock_owner();
}
inline const ::std::string& ReplicationLock::lock_owner() const {
  return *lock_owner_;
}
inline void ReplicationLock::set_lock_owner(const ::std::string& value) {
  set_has_lock_owner();
  if (lock_owner_ == &::google::protobuf::internal::kEmptyString) {
    lock_owner_ = new ::std::string;
  }
  lock_owner_->assign(value);
}
inline void ReplicationLock::set_lock_owner(const char* value) {
  set_has_lock_owner();
  if (lock_owner_ == &::google::protobuf::internal::kEmptyString) {
    lock_owner_ = new ::std::string;
  }
  lock_owner_->assign(value);
}
inline void ReplicationLock::set_lock_owner(const char* value, size_t size) {
  set_has_lock_owner();
  if (lock_owner_ == &::google::protobuf::internal::kEmptyString) {
    lock_owner_ = new ::std::string;
  }
  lock_owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplicationLock::mutable_lock_owner() {
  set_has_lock_owner();
  if (lock_owner_ == &::google::protobuf::internal::kEmptyString) {
    lock_owner_ = new ::std::string;
  }
  return lock_owner_;
}
inline ::std::string* ReplicationLock::release_lock_owner() {
  clear_has_lock_owner();
  if (lock_owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lock_owner_;
    lock_owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplicationLock::set_allocated_lock_owner(::std::string* lock_owner) {
  if (lock_owner_ != &::google::protobuf::internal::kEmptyString) {
    delete lock_owner_;
  }
  if (lock_owner) {
    set_has_lock_owner();
    lock_owner_ = lock_owner;
  } else {
    clear_has_lock_owner();
    lock_owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TableLock

// optional .hbase.pb.TableName table_name = 1;
inline bool TableLock::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableLock::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableLock::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableLock::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& TableLock::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* TableLock::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* TableLock::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void TableLock::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// optional .hbase.pb.ServerName lock_owner = 2;
inline bool TableLock::has_lock_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableLock::set_has_lock_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableLock::clear_has_lock_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableLock::clear_lock_owner() {
  if (lock_owner_ != NULL) lock_owner_->::hbase::pb::ServerName::Clear();
  clear_has_lock_owner();
}
inline const ::hbase::pb::ServerName& TableLock::lock_owner() const {
  return lock_owner_ != NULL ? *lock_owner_ : *default_instance_->lock_owner_;
}
inline ::hbase::pb::ServerName* TableLock::mutable_lock_owner() {
  set_has_lock_owner();
  if (lock_owner_ == NULL) lock_owner_ = new ::hbase::pb::ServerName;
  return lock_owner_;
}
inline ::hbase::pb::ServerName* TableLock::release_lock_owner() {
  clear_has_lock_owner();
  ::hbase::pb::ServerName* temp = lock_owner_;
  lock_owner_ = NULL;
  return temp;
}
inline void TableLock::set_allocated_lock_owner(::hbase::pb::ServerName* lock_owner) {
  delete lock_owner_;
  lock_owner_ = lock_owner;
  if (lock_owner) {
    set_has_lock_owner();
  } else {
    clear_has_lock_owner();
  }
}

// optional int64 thread_id = 3;
inline bool TableLock::has_thread_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableLock::set_has_thread_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableLock::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableLock::clear_thread_id() {
  thread_id_ = GOOGLE_LONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::int64 TableLock::thread_id() const {
  return thread_id_;
}
inline void TableLock::set_thread_id(::google::protobuf::int64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional bool is_shared = 4;
inline bool TableLock::has_is_shared() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableLock::set_has_is_shared() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableLock::clear_has_is_shared() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableLock::clear_is_shared() {
  is_shared_ = false;
  clear_has_is_shared();
}
inline bool TableLock::is_shared() const {
  return is_shared_;
}
inline void TableLock::set_is_shared(bool value) {
  set_has_is_shared();
  is_shared_ = value;
}

// optional string purpose = 5;
inline bool TableLock::has_purpose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableLock::set_has_purpose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableLock::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableLock::clear_purpose() {
  if (purpose_ != &::google::protobuf::internal::kEmptyString) {
    purpose_->clear();
  }
  clear_has_purpose();
}
inline const ::std::string& TableLock::purpose() const {
  return *purpose_;
}
inline void TableLock::set_purpose(const ::std::string& value) {
  set_has_purpose();
  if (purpose_ == &::google::protobuf::internal::kEmptyString) {
    purpose_ = new ::std::string;
  }
  purpose_->assign(value);
}
inline void TableLock::set_purpose(const char* value) {
  set_has_purpose();
  if (purpose_ == &::google::protobuf::internal::kEmptyString) {
    purpose_ = new ::std::string;
  }
  purpose_->assign(value);
}
inline void TableLock::set_purpose(const char* value, size_t size) {
  set_has_purpose();
  if (purpose_ == &::google::protobuf::internal::kEmptyString) {
    purpose_ = new ::std::string;
  }
  purpose_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableLock::mutable_purpose() {
  set_has_purpose();
  if (purpose_ == &::google::protobuf::internal::kEmptyString) {
    purpose_ = new ::std::string;
  }
  return purpose_;
}
inline ::std::string* TableLock::release_purpose() {
  clear_has_purpose();
  if (purpose_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purpose_;
    purpose_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableLock::set_allocated_purpose(::std::string* purpose) {
  if (purpose_ != &::google::protobuf::internal::kEmptyString) {
    delete purpose_;
  }
  if (purpose) {
    set_has_purpose();
    purpose_ = purpose;
  } else {
    clear_has_purpose();
    purpose_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 create_time = 6;
inline bool TableLock::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableLock::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableLock::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableLock::clear_create_time() {
  create_time_ = GOOGLE_LONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::int64 TableLock::create_time() const {
  return create_time_;
}
inline void TableLock::set_create_time(::google::protobuf::int64 value) {
  set_has_create_time();
  create_time_ = value;
}

// -------------------------------------------------------------------

// SwitchState

// optional bool enabled = 1;
inline bool SwitchState::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchState::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchState::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchState::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool SwitchState::enabled() const {
  return enabled_;
}
inline void SwitchState::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SplitLogTask_State>() {
  return ::hbase::pb::SplitLogTask_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SplitLogTask_RecoveryMode>() {
  return ::hbase::pb::SplitLogTask_RecoveryMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DeprecatedTableState_State>() {
  return ::hbase::pb::DeprecatedTableState_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ReplicationState_State>() {
  return ::hbase::pb::ReplicationState_State_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZooKeeper_2eproto__INCLUDED
