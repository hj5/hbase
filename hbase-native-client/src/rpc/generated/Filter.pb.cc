// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Filter.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Filter.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* Filter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Filter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnCountGetFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnCountGetFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnPaginationFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnPaginationFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnPrefixFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnPrefixFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnRangeFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnRangeFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* CompareFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CompareFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* DependentColumnFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DependentColumnFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* FamilyFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FamilyFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* FilterList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilterList_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FilterList_Operator_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FilterWrapper_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilterWrapper_reflection_ = NULL;
const ::google::protobuf::Descriptor* FirstKeyOnlyFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirstKeyOnlyFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* FirstKeyValueMatchingQualifiersFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirstKeyValueMatchingQualifiersFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* FuzzyRowFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FuzzyRowFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* InclusiveStopFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InclusiveStopFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyOnlyFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyOnlyFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* MultipleColumnPrefixFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultipleColumnPrefixFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* PageFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PageFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* PrefixFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PrefixFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* QualifierFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QualifierFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* RandomRowFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RandomRowFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* RowFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RowFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* SingleColumnValueExcludeFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SingleColumnValueExcludeFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* SingleColumnValueFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SingleColumnValueFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* SkipFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SkipFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimestampsFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimestampsFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ValueFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ValueFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* WhileMatchFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WhileMatchFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* FilterAllFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilterAllFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* RowRange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RowRange_reflection_ = NULL;
const ::google::protobuf::Descriptor* MultiRowRangeFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultiRowRangeFilter_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Filter_2eproto() {
  protobuf_AddDesc_Filter_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Filter.proto");
  GOOGLE_CHECK(file != NULL);
  Filter_descriptor_ = file->message_type(0);
  static const int Filter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, serialized_filter_),
  };
  Filter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Filter_descriptor_,
      Filter::default_instance_,
      Filter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Filter));
  ColumnCountGetFilter_descriptor_ = file->message_type(1);
  static const int ColumnCountGetFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnCountGetFilter, limit_),
  };
  ColumnCountGetFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnCountGetFilter_descriptor_,
      ColumnCountGetFilter::default_instance_,
      ColumnCountGetFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnCountGetFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnCountGetFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnCountGetFilter));
  ColumnPaginationFilter_descriptor_ = file->message_type(2);
  static const int ColumnPaginationFilter_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPaginationFilter, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPaginationFilter, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPaginationFilter, column_offset_),
  };
  ColumnPaginationFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnPaginationFilter_descriptor_,
      ColumnPaginationFilter::default_instance_,
      ColumnPaginationFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPaginationFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPaginationFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnPaginationFilter));
  ColumnPrefixFilter_descriptor_ = file->message_type(3);
  static const int ColumnPrefixFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPrefixFilter, prefix_),
  };
  ColumnPrefixFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnPrefixFilter_descriptor_,
      ColumnPrefixFilter::default_instance_,
      ColumnPrefixFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPrefixFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPrefixFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnPrefixFilter));
  ColumnRangeFilter_descriptor_ = file->message_type(4);
  static const int ColumnRangeFilter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, min_column_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, min_column_inclusive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, max_column_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, max_column_inclusive_),
  };
  ColumnRangeFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnRangeFilter_descriptor_,
      ColumnRangeFilter::default_instance_,
      ColumnRangeFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnRangeFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnRangeFilter));
  CompareFilter_descriptor_ = file->message_type(5);
  static const int CompareFilter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompareFilter, compare_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompareFilter, comparator_),
  };
  CompareFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CompareFilter_descriptor_,
      CompareFilter::default_instance_,
      CompareFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompareFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompareFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CompareFilter));
  DependentColumnFilter_descriptor_ = file->message_type(6);
  static const int DependentColumnFilter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, compare_filter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, column_family_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, column_qualifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, drop_dependent_column_),
  };
  DependentColumnFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DependentColumnFilter_descriptor_,
      DependentColumnFilter::default_instance_,
      DependentColumnFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependentColumnFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DependentColumnFilter));
  FamilyFilter_descriptor_ = file->message_type(7);
  static const int FamilyFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FamilyFilter, compare_filter_),
  };
  FamilyFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FamilyFilter_descriptor_,
      FamilyFilter::default_instance_,
      FamilyFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FamilyFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FamilyFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FamilyFilter));
  FilterList_descriptor_ = file->message_type(8);
  static const int FilterList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterList, operator__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterList, filters_),
  };
  FilterList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilterList_descriptor_,
      FilterList::default_instance_,
      FilterList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilterList));
  FilterList_Operator_descriptor_ = FilterList_descriptor_->enum_type(0);
  FilterWrapper_descriptor_ = file->message_type(9);
  static const int FilterWrapper_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterWrapper, filter_),
  };
  FilterWrapper_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilterWrapper_descriptor_,
      FilterWrapper::default_instance_,
      FilterWrapper_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterWrapper, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterWrapper, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilterWrapper));
  FirstKeyOnlyFilter_descriptor_ = file->message_type(10);
  static const int FirstKeyOnlyFilter_offsets_[1] = {
  };
  FirstKeyOnlyFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirstKeyOnlyFilter_descriptor_,
      FirstKeyOnlyFilter::default_instance_,
      FirstKeyOnlyFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstKeyOnlyFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstKeyOnlyFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirstKeyOnlyFilter));
  FirstKeyValueMatchingQualifiersFilter_descriptor_ = file->message_type(11);
  static const int FirstKeyValueMatchingQualifiersFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstKeyValueMatchingQualifiersFilter, qualifiers_),
  };
  FirstKeyValueMatchingQualifiersFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirstKeyValueMatchingQualifiersFilter_descriptor_,
      FirstKeyValueMatchingQualifiersFilter::default_instance_,
      FirstKeyValueMatchingQualifiersFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstKeyValueMatchingQualifiersFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstKeyValueMatchingQualifiersFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirstKeyValueMatchingQualifiersFilter));
  FuzzyRowFilter_descriptor_ = file->message_type(12);
  static const int FuzzyRowFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FuzzyRowFilter, fuzzy_keys_data_),
  };
  FuzzyRowFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FuzzyRowFilter_descriptor_,
      FuzzyRowFilter::default_instance_,
      FuzzyRowFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FuzzyRowFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FuzzyRowFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FuzzyRowFilter));
  InclusiveStopFilter_descriptor_ = file->message_type(13);
  static const int InclusiveStopFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InclusiveStopFilter, stop_row_key_),
  };
  InclusiveStopFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InclusiveStopFilter_descriptor_,
      InclusiveStopFilter::default_instance_,
      InclusiveStopFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InclusiveStopFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InclusiveStopFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InclusiveStopFilter));
  KeyOnlyFilter_descriptor_ = file->message_type(14);
  static const int KeyOnlyFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyOnlyFilter, len_as_val_),
  };
  KeyOnlyFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyOnlyFilter_descriptor_,
      KeyOnlyFilter::default_instance_,
      KeyOnlyFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyOnlyFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyOnlyFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyOnlyFilter));
  MultipleColumnPrefixFilter_descriptor_ = file->message_type(15);
  static const int MultipleColumnPrefixFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultipleColumnPrefixFilter, sorted_prefixes_),
  };
  MultipleColumnPrefixFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultipleColumnPrefixFilter_descriptor_,
      MultipleColumnPrefixFilter::default_instance_,
      MultipleColumnPrefixFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultipleColumnPrefixFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultipleColumnPrefixFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultipleColumnPrefixFilter));
  PageFilter_descriptor_ = file->message_type(16);
  static const int PageFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PageFilter, page_size_),
  };
  PageFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PageFilter_descriptor_,
      PageFilter::default_instance_,
      PageFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PageFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PageFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PageFilter));
  PrefixFilter_descriptor_ = file->message_type(17);
  static const int PrefixFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrefixFilter, prefix_),
  };
  PrefixFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PrefixFilter_descriptor_,
      PrefixFilter::default_instance_,
      PrefixFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrefixFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrefixFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PrefixFilter));
  QualifierFilter_descriptor_ = file->message_type(18);
  static const int QualifierFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QualifierFilter, compare_filter_),
  };
  QualifierFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QualifierFilter_descriptor_,
      QualifierFilter::default_instance_,
      QualifierFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QualifierFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QualifierFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QualifierFilter));
  RandomRowFilter_descriptor_ = file->message_type(19);
  static const int RandomRowFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RandomRowFilter, chance_),
  };
  RandomRowFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RandomRowFilter_descriptor_,
      RandomRowFilter::default_instance_,
      RandomRowFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RandomRowFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RandomRowFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RandomRowFilter));
  RowFilter_descriptor_ = file->message_type(20);
  static const int RowFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowFilter, compare_filter_),
  };
  RowFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RowFilter_descriptor_,
      RowFilter::default_instance_,
      RowFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RowFilter));
  SingleColumnValueExcludeFilter_descriptor_ = file->message_type(21);
  static const int SingleColumnValueExcludeFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueExcludeFilter, single_column_value_filter_),
  };
  SingleColumnValueExcludeFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SingleColumnValueExcludeFilter_descriptor_,
      SingleColumnValueExcludeFilter::default_instance_,
      SingleColumnValueExcludeFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueExcludeFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueExcludeFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SingleColumnValueExcludeFilter));
  SingleColumnValueFilter_descriptor_ = file->message_type(22);
  static const int SingleColumnValueFilter_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, column_family_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, column_qualifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, compare_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, comparator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, filter_if_missing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, latest_version_only_),
  };
  SingleColumnValueFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SingleColumnValueFilter_descriptor_,
      SingleColumnValueFilter::default_instance_,
      SingleColumnValueFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleColumnValueFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SingleColumnValueFilter));
  SkipFilter_descriptor_ = file->message_type(23);
  static const int SkipFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkipFilter, filter_),
  };
  SkipFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SkipFilter_descriptor_,
      SkipFilter::default_instance_,
      SkipFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkipFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkipFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SkipFilter));
  TimestampsFilter_descriptor_ = file->message_type(24);
  static const int TimestampsFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampsFilter, timestamps_),
  };
  TimestampsFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimestampsFilter_descriptor_,
      TimestampsFilter::default_instance_,
      TimestampsFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampsFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampsFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimestampsFilter));
  ValueFilter_descriptor_ = file->message_type(25);
  static const int ValueFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ValueFilter, compare_filter_),
  };
  ValueFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ValueFilter_descriptor_,
      ValueFilter::default_instance_,
      ValueFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ValueFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ValueFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ValueFilter));
  WhileMatchFilter_descriptor_ = file->message_type(26);
  static const int WhileMatchFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WhileMatchFilter, filter_),
  };
  WhileMatchFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WhileMatchFilter_descriptor_,
      WhileMatchFilter::default_instance_,
      WhileMatchFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WhileMatchFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WhileMatchFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WhileMatchFilter));
  FilterAllFilter_descriptor_ = file->message_type(27);
  static const int FilterAllFilter_offsets_[1] = {
  };
  FilterAllFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilterAllFilter_descriptor_,
      FilterAllFilter::default_instance_,
      FilterAllFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterAllFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterAllFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilterAllFilter));
  RowRange_descriptor_ = file->message_type(28);
  static const int RowRange_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, start_row_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, start_row_inclusive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, stop_row_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, stop_row_inclusive_),
  };
  RowRange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RowRange_descriptor_,
      RowRange::default_instance_,
      RowRange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RowRange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RowRange));
  MultiRowRangeFilter_descriptor_ = file->message_type(29);
  static const int MultiRowRangeFilter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiRowRangeFilter, row_range_list_),
  };
  MultiRowRangeFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultiRowRangeFilter_descriptor_,
      MultiRowRangeFilter::default_instance_,
      MultiRowRangeFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiRowRangeFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiRowRangeFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultiRowRangeFilter));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Filter_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Filter_descriptor_, &Filter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnCountGetFilter_descriptor_, &ColumnCountGetFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnPaginationFilter_descriptor_, &ColumnPaginationFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnPrefixFilter_descriptor_, &ColumnPrefixFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnRangeFilter_descriptor_, &ColumnRangeFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CompareFilter_descriptor_, &CompareFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DependentColumnFilter_descriptor_, &DependentColumnFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FamilyFilter_descriptor_, &FamilyFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilterList_descriptor_, &FilterList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilterWrapper_descriptor_, &FilterWrapper::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirstKeyOnlyFilter_descriptor_, &FirstKeyOnlyFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirstKeyValueMatchingQualifiersFilter_descriptor_, &FirstKeyValueMatchingQualifiersFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FuzzyRowFilter_descriptor_, &FuzzyRowFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InclusiveStopFilter_descriptor_, &InclusiveStopFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyOnlyFilter_descriptor_, &KeyOnlyFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultipleColumnPrefixFilter_descriptor_, &MultipleColumnPrefixFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PageFilter_descriptor_, &PageFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PrefixFilter_descriptor_, &PrefixFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QualifierFilter_descriptor_, &QualifierFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RandomRowFilter_descriptor_, &RandomRowFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RowFilter_descriptor_, &RowFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SingleColumnValueExcludeFilter_descriptor_, &SingleColumnValueExcludeFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SingleColumnValueFilter_descriptor_, &SingleColumnValueFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SkipFilter_descriptor_, &SkipFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimestampsFilter_descriptor_, &TimestampsFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ValueFilter_descriptor_, &ValueFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WhileMatchFilter_descriptor_, &WhileMatchFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilterAllFilter_descriptor_, &FilterAllFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RowRange_descriptor_, &RowRange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultiRowRangeFilter_descriptor_, &MultiRowRangeFilter::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Filter_2eproto() {
  delete Filter::default_instance_;
  delete Filter_reflection_;
  delete ColumnCountGetFilter::default_instance_;
  delete ColumnCountGetFilter_reflection_;
  delete ColumnPaginationFilter::default_instance_;
  delete ColumnPaginationFilter_reflection_;
  delete ColumnPrefixFilter::default_instance_;
  delete ColumnPrefixFilter_reflection_;
  delete ColumnRangeFilter::default_instance_;
  delete ColumnRangeFilter_reflection_;
  delete CompareFilter::default_instance_;
  delete CompareFilter_reflection_;
  delete DependentColumnFilter::default_instance_;
  delete DependentColumnFilter_reflection_;
  delete FamilyFilter::default_instance_;
  delete FamilyFilter_reflection_;
  delete FilterList::default_instance_;
  delete FilterList_reflection_;
  delete FilterWrapper::default_instance_;
  delete FilterWrapper_reflection_;
  delete FirstKeyOnlyFilter::default_instance_;
  delete FirstKeyOnlyFilter_reflection_;
  delete FirstKeyValueMatchingQualifiersFilter::default_instance_;
  delete FirstKeyValueMatchingQualifiersFilter_reflection_;
  delete FuzzyRowFilter::default_instance_;
  delete FuzzyRowFilter_reflection_;
  delete InclusiveStopFilter::default_instance_;
  delete InclusiveStopFilter_reflection_;
  delete KeyOnlyFilter::default_instance_;
  delete KeyOnlyFilter_reflection_;
  delete MultipleColumnPrefixFilter::default_instance_;
  delete MultipleColumnPrefixFilter_reflection_;
  delete PageFilter::default_instance_;
  delete PageFilter_reflection_;
  delete PrefixFilter::default_instance_;
  delete PrefixFilter_reflection_;
  delete QualifierFilter::default_instance_;
  delete QualifierFilter_reflection_;
  delete RandomRowFilter::default_instance_;
  delete RandomRowFilter_reflection_;
  delete RowFilter::default_instance_;
  delete RowFilter_reflection_;
  delete SingleColumnValueExcludeFilter::default_instance_;
  delete SingleColumnValueExcludeFilter_reflection_;
  delete SingleColumnValueFilter::default_instance_;
  delete SingleColumnValueFilter_reflection_;
  delete SkipFilter::default_instance_;
  delete SkipFilter_reflection_;
  delete TimestampsFilter::default_instance_;
  delete TimestampsFilter_reflection_;
  delete ValueFilter::default_instance_;
  delete ValueFilter_reflection_;
  delete WhileMatchFilter::default_instance_;
  delete WhileMatchFilter_reflection_;
  delete FilterAllFilter::default_instance_;
  delete FilterAllFilter_reflection_;
  delete RowRange::default_instance_;
  delete RowRange_reflection_;
  delete MultiRowRangeFilter::default_instance_;
  delete MultiRowRangeFilter_reflection_;
}

void protobuf_AddDesc_Filter_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hbase::pb::protobuf_AddDesc_HBase_2eproto();
  ::hbase::pb::protobuf_AddDesc_Comparator_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014Filter.proto\022\010hbase.pb\032\013HBase.proto\032\020C"
    "omparator.proto\"1\n\006Filter\022\014\n\004name\030\001 \002(\t\022"
    "\031\n\021serialized_filter\030\002 \001(\014\"%\n\024ColumnCoun"
    "tGetFilter\022\r\n\005limit\030\001 \002(\005\"N\n\026ColumnPagin"
    "ationFilter\022\r\n\005limit\030\001 \002(\005\022\016\n\006offset\030\002 \001"
    "(\005\022\025\n\rcolumn_offset\030\003 \001(\014\"$\n\022ColumnPrefi"
    "xFilter\022\016\n\006prefix\030\001 \002(\014\"w\n\021ColumnRangeFi"
    "lter\022\022\n\nmin_column\030\001 \001(\014\022\034\n\024min_column_i"
    "nclusive\030\002 \001(\010\022\022\n\nmax_column\030\003 \001(\014\022\034\n\024ma"
    "x_column_inclusive\030\004 \001(\010\"d\n\rCompareFilte"
    "r\022)\n\ncompare_op\030\001 \002(\0162\025.hbase.pb.Compare"
    "Type\022(\n\ncomparator\030\002 \001(\0132\024.hbase.pb.Comp"
    "arator\"\230\001\n\025DependentColumnFilter\022/\n\016comp"
    "are_filter\030\001 \002(\0132\027.hbase.pb.CompareFilte"
    "r\022\025\n\rcolumn_family\030\002 \001(\014\022\030\n\020column_quali"
    "fier\030\003 \001(\014\022\035\n\025drop_dependent_column\030\004 \001("
    "\010\"\?\n\014FamilyFilter\022/\n\016compare_filter\030\001 \002("
    "\0132\027.hbase.pb.CompareFilter\"\222\001\n\nFilterLis"
    "t\022/\n\010operator\030\001 \002(\0162\035.hbase.pb.FilterLis"
    "t.Operator\022!\n\007filters\030\002 \003(\0132\020.hbase.pb.F"
    "ilter\"0\n\010Operator\022\021\n\rMUST_PASS_ALL\020\001\022\021\n\r"
    "MUST_PASS_ONE\020\002\"1\n\rFilterWrapper\022 \n\006filt"
    "er\030\001 \002(\0132\020.hbase.pb.Filter\"\024\n\022FirstKeyOn"
    "lyFilter\";\n%FirstKeyValueMatchingQualifi"
    "ersFilter\022\022\n\nqualifiers\030\001 \003(\014\"C\n\016FuzzyRo"
    "wFilter\0221\n\017fuzzy_keys_data\030\001 \003(\0132\030.hbase"
    ".pb.BytesBytesPair\"+\n\023InclusiveStopFilte"
    "r\022\024\n\014stop_row_key\030\001 \001(\014\"#\n\rKeyOnlyFilter"
    "\022\022\n\nlen_as_val\030\001 \002(\010\"5\n\032MultipleColumnPr"
    "efixFilter\022\027\n\017sorted_prefixes\030\001 \003(\014\"\037\n\nP"
    "ageFilter\022\021\n\tpage_size\030\001 \002(\003\"\036\n\014PrefixFi"
    "lter\022\016\n\006prefix\030\001 \001(\014\"B\n\017QualifierFilter\022"
    "/\n\016compare_filter\030\001 \002(\0132\027.hbase.pb.Compa"
    "reFilter\"!\n\017RandomRowFilter\022\016\n\006chance\030\001 "
    "\002(\002\"<\n\tRowFilter\022/\n\016compare_filter\030\001 \002(\013"
    "2\027.hbase.pb.CompareFilter\"g\n\036SingleColum"
    "nValueExcludeFilter\022E\n\032single_column_val"
    "ue_filter\030\001 \002(\0132!.hbase.pb.SingleColumnV"
    "alueFilter\"\327\001\n\027SingleColumnValueFilter\022\025"
    "\n\rcolumn_family\030\001 \001(\014\022\030\n\020column_qualifie"
    "r\030\002 \001(\014\022)\n\ncompare_op\030\003 \002(\0162\025.hbase.pb.C"
    "ompareType\022(\n\ncomparator\030\004 \002(\0132\024.hbase.p"
    "b.Comparator\022\031\n\021filter_if_missing\030\005 \001(\010\022"
    "\033\n\023latest_version_only\030\006 \001(\010\".\n\nSkipFilt"
    "er\022 \n\006filter\030\001 \002(\0132\020.hbase.pb.Filter\"*\n\020"
    "TimestampsFilter\022\026\n\ntimestamps\030\001 \003(\003B\002\020\001"
    "\">\n\013ValueFilter\022/\n\016compare_filter\030\001 \002(\0132"
    "\027.hbase.pb.CompareFilter\"4\n\020WhileMatchFi"
    "lter\022 \n\006filter\030\001 \002(\0132\020.hbase.pb.Filter\"\021"
    "\n\017FilterAllFilter\"h\n\010RowRange\022\021\n\tstart_r"
    "ow\030\001 \001(\014\022\033\n\023start_row_inclusive\030\002 \001(\010\022\020\n"
    "\010stop_row\030\003 \001(\014\022\032\n\022stop_row_inclusive\030\004 "
    "\001(\010\"A\n\023MultiRowRangeFilter\022*\n\016row_range_"
    "list\030\001 \003(\0132\022.hbase.pb.RowRangeBB\n*org.ap"
    "ache.hadoop.hbase.protobuf.generatedB\014Fi"
    "lterProtosH\001\210\001\001\240\001\001", 2218);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Filter.proto", &protobuf_RegisterTypes);
  Filter::default_instance_ = new Filter();
  ColumnCountGetFilter::default_instance_ = new ColumnCountGetFilter();
  ColumnPaginationFilter::default_instance_ = new ColumnPaginationFilter();
  ColumnPrefixFilter::default_instance_ = new ColumnPrefixFilter();
  ColumnRangeFilter::default_instance_ = new ColumnRangeFilter();
  CompareFilter::default_instance_ = new CompareFilter();
  DependentColumnFilter::default_instance_ = new DependentColumnFilter();
  FamilyFilter::default_instance_ = new FamilyFilter();
  FilterList::default_instance_ = new FilterList();
  FilterWrapper::default_instance_ = new FilterWrapper();
  FirstKeyOnlyFilter::default_instance_ = new FirstKeyOnlyFilter();
  FirstKeyValueMatchingQualifiersFilter::default_instance_ = new FirstKeyValueMatchingQualifiersFilter();
  FuzzyRowFilter::default_instance_ = new FuzzyRowFilter();
  InclusiveStopFilter::default_instance_ = new InclusiveStopFilter();
  KeyOnlyFilter::default_instance_ = new KeyOnlyFilter();
  MultipleColumnPrefixFilter::default_instance_ = new MultipleColumnPrefixFilter();
  PageFilter::default_instance_ = new PageFilter();
  PrefixFilter::default_instance_ = new PrefixFilter();
  QualifierFilter::default_instance_ = new QualifierFilter();
  RandomRowFilter::default_instance_ = new RandomRowFilter();
  RowFilter::default_instance_ = new RowFilter();
  SingleColumnValueExcludeFilter::default_instance_ = new SingleColumnValueExcludeFilter();
  SingleColumnValueFilter::default_instance_ = new SingleColumnValueFilter();
  SkipFilter::default_instance_ = new SkipFilter();
  TimestampsFilter::default_instance_ = new TimestampsFilter();
  ValueFilter::default_instance_ = new ValueFilter();
  WhileMatchFilter::default_instance_ = new WhileMatchFilter();
  FilterAllFilter::default_instance_ = new FilterAllFilter();
  RowRange::default_instance_ = new RowRange();
  MultiRowRangeFilter::default_instance_ = new MultiRowRangeFilter();
  Filter::default_instance_->InitAsDefaultInstance();
  ColumnCountGetFilter::default_instance_->InitAsDefaultInstance();
  ColumnPaginationFilter::default_instance_->InitAsDefaultInstance();
  ColumnPrefixFilter::default_instance_->InitAsDefaultInstance();
  ColumnRangeFilter::default_instance_->InitAsDefaultInstance();
  CompareFilter::default_instance_->InitAsDefaultInstance();
  DependentColumnFilter::default_instance_->InitAsDefaultInstance();
  FamilyFilter::default_instance_->InitAsDefaultInstance();
  FilterList::default_instance_->InitAsDefaultInstance();
  FilterWrapper::default_instance_->InitAsDefaultInstance();
  FirstKeyOnlyFilter::default_instance_->InitAsDefaultInstance();
  FirstKeyValueMatchingQualifiersFilter::default_instance_->InitAsDefaultInstance();
  FuzzyRowFilter::default_instance_->InitAsDefaultInstance();
  InclusiveStopFilter::default_instance_->InitAsDefaultInstance();
  KeyOnlyFilter::default_instance_->InitAsDefaultInstance();
  MultipleColumnPrefixFilter::default_instance_->InitAsDefaultInstance();
  PageFilter::default_instance_->InitAsDefaultInstance();
  PrefixFilter::default_instance_->InitAsDefaultInstance();
  QualifierFilter::default_instance_->InitAsDefaultInstance();
  RandomRowFilter::default_instance_->InitAsDefaultInstance();
  RowFilter::default_instance_->InitAsDefaultInstance();
  SingleColumnValueExcludeFilter::default_instance_->InitAsDefaultInstance();
  SingleColumnValueFilter::default_instance_->InitAsDefaultInstance();
  SkipFilter::default_instance_->InitAsDefaultInstance();
  TimestampsFilter::default_instance_->InitAsDefaultInstance();
  ValueFilter::default_instance_->InitAsDefaultInstance();
  WhileMatchFilter::default_instance_->InitAsDefaultInstance();
  FilterAllFilter::default_instance_->InitAsDefaultInstance();
  RowRange::default_instance_->InitAsDefaultInstance();
  MultiRowRangeFilter::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Filter_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Filter_2eproto {
  StaticDescriptorInitializer_Filter_2eproto() {
    protobuf_AddDesc_Filter_2eproto();
  }
} static_descriptor_initializer_Filter_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Filter::kNameFieldNumber;
const int Filter::kSerializedFilterFieldNumber;
#endif  // !_MSC_VER

Filter::Filter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Filter::InitAsDefaultInstance() {
}

Filter::Filter(const Filter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Filter::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialized_filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Filter::~Filter() {
  SharedDtor();
}

void Filter::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (serialized_filter_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_filter_;
  }
  if (this != default_instance_) {
  }
}

void Filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Filter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Filter_descriptor_;
}

const Filter& Filter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

Filter* Filter::default_instance_ = NULL;

Filter* Filter::New() const {
  return new Filter;
}

void Filter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_serialized_filter()) {
      if (serialized_filter_ != &::google::protobuf::internal::kEmptyString) {
        serialized_filter_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialized_filter;
        break;
      }

      // optional bytes serialized_filter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialized_filter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialized_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional bytes serialized_filter = 2;
  if (has_serialized_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialized_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Filter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional bytes serialized_filter = 2;
  if (has_serialized_filter()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->serialized_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Filter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bytes serialized_filter = 2;
    if (has_serialized_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialized_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Filter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Filter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Filter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Filter::MergeFrom(const Filter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_serialized_filter()) {
      set_serialized_filter(from.serialized_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Filter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Filter::CopyFrom(const Filter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Filter::Swap(Filter* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(serialized_filter_, other->serialized_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Filter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Filter_descriptor_;
  metadata.reflection = Filter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnCountGetFilter::kLimitFieldNumber;
#endif  // !_MSC_VER

ColumnCountGetFilter::ColumnCountGetFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnCountGetFilter::InitAsDefaultInstance() {
}

ColumnCountGetFilter::ColumnCountGetFilter(const ColumnCountGetFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnCountGetFilter::SharedCtor() {
  _cached_size_ = 0;
  limit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnCountGetFilter::~ColumnCountGetFilter() {
  SharedDtor();
}

void ColumnCountGetFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColumnCountGetFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnCountGetFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnCountGetFilter_descriptor_;
}

const ColumnCountGetFilter& ColumnCountGetFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

ColumnCountGetFilter* ColumnCountGetFilter::default_instance_ = NULL;

ColumnCountGetFilter* ColumnCountGetFilter::New() const {
  return new ColumnCountGetFilter;
}

void ColumnCountGetFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    limit_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnCountGetFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 limit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnCountGetFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 limit = 1;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->limit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnCountGetFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 limit = 1;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->limit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnCountGetFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 limit = 1;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limit());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnCountGetFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnCountGetFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnCountGetFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnCountGetFilter::MergeFrom(const ColumnCountGetFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_limit()) {
      set_limit(from.limit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnCountGetFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnCountGetFilter::CopyFrom(const ColumnCountGetFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnCountGetFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ColumnCountGetFilter::Swap(ColumnCountGetFilter* other) {
  if (other != this) {
    std::swap(limit_, other->limit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnCountGetFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnCountGetFilter_descriptor_;
  metadata.reflection = ColumnCountGetFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnPaginationFilter::kLimitFieldNumber;
const int ColumnPaginationFilter::kOffsetFieldNumber;
const int ColumnPaginationFilter::kColumnOffsetFieldNumber;
#endif  // !_MSC_VER

ColumnPaginationFilter::ColumnPaginationFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnPaginationFilter::InitAsDefaultInstance() {
}

ColumnPaginationFilter::ColumnPaginationFilter(const ColumnPaginationFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnPaginationFilter::SharedCtor() {
  _cached_size_ = 0;
  limit_ = 0;
  offset_ = 0;
  column_offset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnPaginationFilter::~ColumnPaginationFilter() {
  SharedDtor();
}

void ColumnPaginationFilter::SharedDtor() {
  if (column_offset_ != &::google::protobuf::internal::kEmptyString) {
    delete column_offset_;
  }
  if (this != default_instance_) {
  }
}

void ColumnPaginationFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnPaginationFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnPaginationFilter_descriptor_;
}

const ColumnPaginationFilter& ColumnPaginationFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

ColumnPaginationFilter* ColumnPaginationFilter::default_instance_ = NULL;

ColumnPaginationFilter* ColumnPaginationFilter::New() const {
  return new ColumnPaginationFilter;
}

void ColumnPaginationFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    limit_ = 0;
    offset_ = 0;
    if (has_column_offset()) {
      if (column_offset_ != &::google::protobuf::internal::kEmptyString) {
        column_offset_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnPaginationFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 limit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // optional int32 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_column_offset;
        break;
      }

      // optional bytes column_offset = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column_offset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_offset()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnPaginationFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 limit = 1;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->limit(), output);
  }

  // optional int32 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->offset(), output);
  }

  // optional bytes column_offset = 3;
  if (has_column_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->column_offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnPaginationFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 limit = 1;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->limit(), target);
  }

  // optional int32 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->offset(), target);
  }

  // optional bytes column_offset = 3;
  if (has_column_offset()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->column_offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnPaginationFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 limit = 1;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limit());
    }

    // optional int32 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->offset());
    }

    // optional bytes column_offset = 3;
    if (has_column_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->column_offset());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnPaginationFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnPaginationFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnPaginationFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnPaginationFilter::MergeFrom(const ColumnPaginationFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_limit()) {
      set_limit(from.limit());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_column_offset()) {
      set_column_offset(from.column_offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnPaginationFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnPaginationFilter::CopyFrom(const ColumnPaginationFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnPaginationFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ColumnPaginationFilter::Swap(ColumnPaginationFilter* other) {
  if (other != this) {
    std::swap(limit_, other->limit_);
    std::swap(offset_, other->offset_);
    std::swap(column_offset_, other->column_offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnPaginationFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnPaginationFilter_descriptor_;
  metadata.reflection = ColumnPaginationFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnPrefixFilter::kPrefixFieldNumber;
#endif  // !_MSC_VER

ColumnPrefixFilter::ColumnPrefixFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnPrefixFilter::InitAsDefaultInstance() {
}

ColumnPrefixFilter::ColumnPrefixFilter(const ColumnPrefixFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnPrefixFilter::SharedCtor() {
  _cached_size_ = 0;
  prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnPrefixFilter::~ColumnPrefixFilter() {
  SharedDtor();
}

void ColumnPrefixFilter::SharedDtor() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (this != default_instance_) {
  }
}

void ColumnPrefixFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnPrefixFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnPrefixFilter_descriptor_;
}

const ColumnPrefixFilter& ColumnPrefixFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

ColumnPrefixFilter* ColumnPrefixFilter::default_instance_ = NULL;

ColumnPrefixFilter* ColumnPrefixFilter::New() const {
  return new ColumnPrefixFilter;
}

void ColumnPrefixFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_prefix()) {
      if (prefix_ != &::google::protobuf::internal::kEmptyString) {
        prefix_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnPrefixFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes prefix = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prefix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnPrefixFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes prefix = 1;
  if (has_prefix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->prefix(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnPrefixFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes prefix = 1;
  if (has_prefix()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->prefix(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnPrefixFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes prefix = 1;
    if (has_prefix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prefix());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnPrefixFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnPrefixFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnPrefixFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnPrefixFilter::MergeFrom(const ColumnPrefixFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_prefix()) {
      set_prefix(from.prefix());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnPrefixFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnPrefixFilter::CopyFrom(const ColumnPrefixFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnPrefixFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ColumnPrefixFilter::Swap(ColumnPrefixFilter* other) {
  if (other != this) {
    std::swap(prefix_, other->prefix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnPrefixFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnPrefixFilter_descriptor_;
  metadata.reflection = ColumnPrefixFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnRangeFilter::kMinColumnFieldNumber;
const int ColumnRangeFilter::kMinColumnInclusiveFieldNumber;
const int ColumnRangeFilter::kMaxColumnFieldNumber;
const int ColumnRangeFilter::kMaxColumnInclusiveFieldNumber;
#endif  // !_MSC_VER

ColumnRangeFilter::ColumnRangeFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnRangeFilter::InitAsDefaultInstance() {
}

ColumnRangeFilter::ColumnRangeFilter(const ColumnRangeFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnRangeFilter::SharedCtor() {
  _cached_size_ = 0;
  min_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  min_column_inclusive_ = false;
  max_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  max_column_inclusive_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnRangeFilter::~ColumnRangeFilter() {
  SharedDtor();
}

void ColumnRangeFilter::SharedDtor() {
  if (min_column_ != &::google::protobuf::internal::kEmptyString) {
    delete min_column_;
  }
  if (max_column_ != &::google::protobuf::internal::kEmptyString) {
    delete max_column_;
  }
  if (this != default_instance_) {
  }
}

void ColumnRangeFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnRangeFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnRangeFilter_descriptor_;
}

const ColumnRangeFilter& ColumnRangeFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

ColumnRangeFilter* ColumnRangeFilter::default_instance_ = NULL;

ColumnRangeFilter* ColumnRangeFilter::New() const {
  return new ColumnRangeFilter;
}

void ColumnRangeFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_min_column()) {
      if (min_column_ != &::google::protobuf::internal::kEmptyString) {
        min_column_->clear();
      }
    }
    min_column_inclusive_ = false;
    if (has_max_column()) {
      if (max_column_ != &::google::protobuf::internal::kEmptyString) {
        max_column_->clear();
      }
    }
    max_column_inclusive_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnRangeFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes min_column = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_min_column()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_min_column_inclusive;
        break;
      }

      // optional bool min_column_inclusive = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_min_column_inclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &min_column_inclusive_)));
          set_has_min_column_inclusive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_max_column;
        break;
      }

      // optional bytes max_column = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_column:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_max_column()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_max_column_inclusive;
        break;
      }

      // optional bool max_column_inclusive = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_column_inclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &max_column_inclusive_)));
          set_has_max_column_inclusive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnRangeFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes min_column = 1;
  if (has_min_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->min_column(), output);
  }

  // optional bool min_column_inclusive = 2;
  if (has_min_column_inclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->min_column_inclusive(), output);
  }

  // optional bytes max_column = 3;
  if (has_max_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->max_column(), output);
  }

  // optional bool max_column_inclusive = 4;
  if (has_max_column_inclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->max_column_inclusive(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnRangeFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes min_column = 1;
  if (has_min_column()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->min_column(), target);
  }

  // optional bool min_column_inclusive = 2;
  if (has_min_column_inclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->min_column_inclusive(), target);
  }

  // optional bytes max_column = 3;
  if (has_max_column()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->max_column(), target);
  }

  // optional bool max_column_inclusive = 4;
  if (has_max_column_inclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->max_column_inclusive(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnRangeFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes min_column = 1;
    if (has_min_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->min_column());
    }

    // optional bool min_column_inclusive = 2;
    if (has_min_column_inclusive()) {
      total_size += 1 + 1;
    }

    // optional bytes max_column = 3;
    if (has_max_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->max_column());
    }

    // optional bool max_column_inclusive = 4;
    if (has_max_column_inclusive()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnRangeFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnRangeFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnRangeFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnRangeFilter::MergeFrom(const ColumnRangeFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min_column()) {
      set_min_column(from.min_column());
    }
    if (from.has_min_column_inclusive()) {
      set_min_column_inclusive(from.min_column_inclusive());
    }
    if (from.has_max_column()) {
      set_max_column(from.max_column());
    }
    if (from.has_max_column_inclusive()) {
      set_max_column_inclusive(from.max_column_inclusive());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnRangeFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnRangeFilter::CopyFrom(const ColumnRangeFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnRangeFilter::IsInitialized() const {

  return true;
}

void ColumnRangeFilter::Swap(ColumnRangeFilter* other) {
  if (other != this) {
    std::swap(min_column_, other->min_column_);
    std::swap(min_column_inclusive_, other->min_column_inclusive_);
    std::swap(max_column_, other->max_column_);
    std::swap(max_column_inclusive_, other->max_column_inclusive_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnRangeFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnRangeFilter_descriptor_;
  metadata.reflection = ColumnRangeFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CompareFilter::kCompareOpFieldNumber;
const int CompareFilter::kComparatorFieldNumber;
#endif  // !_MSC_VER

CompareFilter::CompareFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CompareFilter::InitAsDefaultInstance() {
  comparator_ = const_cast< ::hbase::pb::Comparator*>(&::hbase::pb::Comparator::default_instance());
}

CompareFilter::CompareFilter(const CompareFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CompareFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_op_ = 0;
  comparator_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompareFilter::~CompareFilter() {
  SharedDtor();
}

void CompareFilter::SharedDtor() {
  if (this != default_instance_) {
    delete comparator_;
  }
}

void CompareFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CompareFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CompareFilter_descriptor_;
}

const CompareFilter& CompareFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

CompareFilter* CompareFilter::default_instance_ = NULL;

CompareFilter* CompareFilter::New() const {
  return new CompareFilter;
}

void CompareFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    compare_op_ = 0;
    if (has_comparator()) {
      if (comparator_ != NULL) comparator_->::hbase::pb::Comparator::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CompareFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareType compare_op = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::CompareType_IsValid(value)) {
            set_compare_op(static_cast< ::hbase::pb::CompareType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_comparator;
        break;
      }

      // optional .hbase.pb.Comparator comparator = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comparator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_comparator()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CompareFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareType compare_op = 1;
  if (has_compare_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->compare_op(), output);
  }

  // optional .hbase.pb.Comparator comparator = 2;
  if (has_comparator()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->comparator(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CompareFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareType compare_op = 1;
  if (has_compare_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->compare_op(), target);
  }

  // optional .hbase.pb.Comparator comparator = 2;
  if (has_comparator()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->comparator(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CompareFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareType compare_op = 1;
    if (has_compare_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compare_op());
    }

    // optional .hbase.pb.Comparator comparator = 2;
    if (has_comparator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->comparator());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompareFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CompareFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CompareFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CompareFilter::MergeFrom(const CompareFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_op()) {
      set_compare_op(from.compare_op());
    }
    if (from.has_comparator()) {
      mutable_comparator()->::hbase::pb::Comparator::MergeFrom(from.comparator());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CompareFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CompareFilter::CopyFrom(const CompareFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompareFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_comparator()) {
    if (!this->comparator().IsInitialized()) return false;
  }
  return true;
}

void CompareFilter::Swap(CompareFilter* other) {
  if (other != this) {
    std::swap(compare_op_, other->compare_op_);
    std::swap(comparator_, other->comparator_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CompareFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CompareFilter_descriptor_;
  metadata.reflection = CompareFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DependentColumnFilter::kCompareFilterFieldNumber;
const int DependentColumnFilter::kColumnFamilyFieldNumber;
const int DependentColumnFilter::kColumnQualifierFieldNumber;
const int DependentColumnFilter::kDropDependentColumnFieldNumber;
#endif  // !_MSC_VER

DependentColumnFilter::DependentColumnFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DependentColumnFilter::InitAsDefaultInstance() {
  compare_filter_ = const_cast< ::hbase::pb::CompareFilter*>(&::hbase::pb::CompareFilter::default_instance());
}

DependentColumnFilter::DependentColumnFilter(const DependentColumnFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DependentColumnFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_filter_ = NULL;
  column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  drop_dependent_column_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DependentColumnFilter::~DependentColumnFilter() {
  SharedDtor();
}

void DependentColumnFilter::SharedDtor() {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    delete column_family_;
  }
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete column_qualifier_;
  }
  if (this != default_instance_) {
    delete compare_filter_;
  }
}

void DependentColumnFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DependentColumnFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DependentColumnFilter_descriptor_;
}

const DependentColumnFilter& DependentColumnFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

DependentColumnFilter* DependentColumnFilter::default_instance_ = NULL;

DependentColumnFilter* DependentColumnFilter::New() const {
  return new DependentColumnFilter;
}

void DependentColumnFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_compare_filter()) {
      if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
    }
    if (has_column_family()) {
      if (column_family_ != &::google::protobuf::internal::kEmptyString) {
        column_family_->clear();
      }
    }
    if (has_column_qualifier()) {
      if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
        column_qualifier_->clear();
      }
    }
    drop_dependent_column_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DependentColumnFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareFilter compare_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compare_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_column_family;
        break;
      }

      // optional bytes column_family = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column_family:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_family()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_column_qualifier;
        break;
      }

      // optional bytes column_qualifier = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column_qualifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_qualifier()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_drop_dependent_column;
        break;
      }

      // optional bool drop_dependent_column = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_drop_dependent_column:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &drop_dependent_column_)));
          set_has_drop_dependent_column();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DependentColumnFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->compare_filter(), output);
  }

  // optional bytes column_family = 2;
  if (has_column_family()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->column_family(), output);
  }

  // optional bytes column_qualifier = 3;
  if (has_column_qualifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->column_qualifier(), output);
  }

  // optional bool drop_dependent_column = 4;
  if (has_drop_dependent_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->drop_dependent_column(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DependentColumnFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->compare_filter(), target);
  }

  // optional bytes column_family = 2;
  if (has_column_family()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->column_family(), target);
  }

  // optional bytes column_qualifier = 3;
  if (has_column_qualifier()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->column_qualifier(), target);
  }

  // optional bool drop_dependent_column = 4;
  if (has_drop_dependent_column()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->drop_dependent_column(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DependentColumnFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareFilter compare_filter = 1;
    if (has_compare_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compare_filter());
    }

    // optional bytes column_family = 2;
    if (has_column_family()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->column_family());
    }

    // optional bytes column_qualifier = 3;
    if (has_column_qualifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->column_qualifier());
    }

    // optional bool drop_dependent_column = 4;
    if (has_drop_dependent_column()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DependentColumnFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DependentColumnFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DependentColumnFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DependentColumnFilter::MergeFrom(const DependentColumnFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_filter()) {
      mutable_compare_filter()->::hbase::pb::CompareFilter::MergeFrom(from.compare_filter());
    }
    if (from.has_column_family()) {
      set_column_family(from.column_family());
    }
    if (from.has_column_qualifier()) {
      set_column_qualifier(from.column_qualifier());
    }
    if (from.has_drop_dependent_column()) {
      set_drop_dependent_column(from.drop_dependent_column());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DependentColumnFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DependentColumnFilter::CopyFrom(const DependentColumnFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DependentColumnFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_compare_filter()) {
    if (!this->compare_filter().IsInitialized()) return false;
  }
  return true;
}

void DependentColumnFilter::Swap(DependentColumnFilter* other) {
  if (other != this) {
    std::swap(compare_filter_, other->compare_filter_);
    std::swap(column_family_, other->column_family_);
    std::swap(column_qualifier_, other->column_qualifier_);
    std::swap(drop_dependent_column_, other->drop_dependent_column_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DependentColumnFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DependentColumnFilter_descriptor_;
  metadata.reflection = DependentColumnFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FamilyFilter::kCompareFilterFieldNumber;
#endif  // !_MSC_VER

FamilyFilter::FamilyFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FamilyFilter::InitAsDefaultInstance() {
  compare_filter_ = const_cast< ::hbase::pb::CompareFilter*>(&::hbase::pb::CompareFilter::default_instance());
}

FamilyFilter::FamilyFilter(const FamilyFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FamilyFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FamilyFilter::~FamilyFilter() {
  SharedDtor();
}

void FamilyFilter::SharedDtor() {
  if (this != default_instance_) {
    delete compare_filter_;
  }
}

void FamilyFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FamilyFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FamilyFilter_descriptor_;
}

const FamilyFilter& FamilyFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FamilyFilter* FamilyFilter::default_instance_ = NULL;

FamilyFilter* FamilyFilter::New() const {
  return new FamilyFilter;
}

void FamilyFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_compare_filter()) {
      if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FamilyFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareFilter compare_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compare_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FamilyFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->compare_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FamilyFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->compare_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FamilyFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareFilter compare_filter = 1;
    if (has_compare_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compare_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FamilyFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FamilyFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FamilyFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FamilyFilter::MergeFrom(const FamilyFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_filter()) {
      mutable_compare_filter()->::hbase::pb::CompareFilter::MergeFrom(from.compare_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FamilyFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FamilyFilter::CopyFrom(const FamilyFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FamilyFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_compare_filter()) {
    if (!this->compare_filter().IsInitialized()) return false;
  }
  return true;
}

void FamilyFilter::Swap(FamilyFilter* other) {
  if (other != this) {
    std::swap(compare_filter_, other->compare_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FamilyFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FamilyFilter_descriptor_;
  metadata.reflection = FamilyFilter_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FilterList_Operator_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterList_Operator_descriptor_;
}
bool FilterList_Operator_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FilterList_Operator FilterList::MUST_PASS_ALL;
const FilterList_Operator FilterList::MUST_PASS_ONE;
const FilterList_Operator FilterList::Operator_MIN;
const FilterList_Operator FilterList::Operator_MAX;
const int FilterList::Operator_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FilterList::kOperatorFieldNumber;
const int FilterList::kFiltersFieldNumber;
#endif  // !_MSC_VER

FilterList::FilterList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FilterList::InitAsDefaultInstance() {
}

FilterList::FilterList(const FilterList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FilterList::SharedCtor() {
  _cached_size_ = 0;
  operator__ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterList::~FilterList() {
  SharedDtor();
}

void FilterList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FilterList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilterList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterList_descriptor_;
}

const FilterList& FilterList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FilterList* FilterList::default_instance_ = NULL;

FilterList* FilterList::New() const {
  return new FilterList;
}

void FilterList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    operator__ = 1;
  }
  filters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilterList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.FilterList.Operator operator = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::FilterList_Operator_IsValid(value)) {
            set_operator_(static_cast< ::hbase::pb::FilterList_Operator >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filters;
        break;
      }

      // repeated .hbase.pb.Filter filters = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_filters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filters;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilterList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.FilterList.Operator operator = 1;
  if (has_operator_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->operator_(), output);
  }

  // repeated .hbase.pb.Filter filters = 2;
  for (int i = 0; i < this->filters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->filters(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FilterList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.FilterList.Operator operator = 1;
  if (has_operator_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->operator_(), target);
  }

  // repeated .hbase.pb.Filter filters = 2;
  for (int i = 0; i < this->filters_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->filters(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FilterList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.FilterList.Operator operator = 1;
    if (has_operator_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operator_());
    }

  }
  // repeated .hbase.pb.Filter filters = 2;
  total_size += 1 * this->filters_size();
  for (int i = 0; i < this->filters_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->filters(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilterList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilterList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilterList::MergeFrom(const FilterList& from) {
  GOOGLE_CHECK_NE(&from, this);
  filters_.MergeFrom(from.filters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_operator_()) {
      set_operator_(from.operator_());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilterList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilterList::CopyFrom(const FilterList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < filters_size(); i++) {
    if (!this->filters(i).IsInitialized()) return false;
  }
  return true;
}

void FilterList::Swap(FilterList* other) {
  if (other != this) {
    std::swap(operator__, other->operator__);
    filters_.Swap(&other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilterList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilterList_descriptor_;
  metadata.reflection = FilterList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FilterWrapper::kFilterFieldNumber;
#endif  // !_MSC_VER

FilterWrapper::FilterWrapper()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FilterWrapper::InitAsDefaultInstance() {
  filter_ = const_cast< ::hbase::pb::Filter*>(&::hbase::pb::Filter::default_instance());
}

FilterWrapper::FilterWrapper(const FilterWrapper& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FilterWrapper::SharedCtor() {
  _cached_size_ = 0;
  filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterWrapper::~FilterWrapper() {
  SharedDtor();
}

void FilterWrapper::SharedDtor() {
  if (this != default_instance_) {
    delete filter_;
  }
}

void FilterWrapper::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilterWrapper::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterWrapper_descriptor_;
}

const FilterWrapper& FilterWrapper::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FilterWrapper* FilterWrapper::default_instance_ = NULL;

FilterWrapper* FilterWrapper::New() const {
  return new FilterWrapper;
}

void FilterWrapper::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter()) {
      if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilterWrapper::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.Filter filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilterWrapper::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FilterWrapper::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FilterWrapper::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.Filter filter = 1;
    if (has_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterWrapper::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilterWrapper* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilterWrapper*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilterWrapper::MergeFrom(const FilterWrapper& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter()) {
      mutable_filter()->::hbase::pb::Filter::MergeFrom(from.filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilterWrapper::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilterWrapper::CopyFrom(const FilterWrapper& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterWrapper::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_filter()) {
    if (!this->filter().IsInitialized()) return false;
  }
  return true;
}

void FilterWrapper::Swap(FilterWrapper* other) {
  if (other != this) {
    std::swap(filter_, other->filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilterWrapper::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilterWrapper_descriptor_;
  metadata.reflection = FilterWrapper_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

FirstKeyOnlyFilter::FirstKeyOnlyFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirstKeyOnlyFilter::InitAsDefaultInstance() {
}

FirstKeyOnlyFilter::FirstKeyOnlyFilter(const FirstKeyOnlyFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirstKeyOnlyFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstKeyOnlyFilter::~FirstKeyOnlyFilter() {
  SharedDtor();
}

void FirstKeyOnlyFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FirstKeyOnlyFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirstKeyOnlyFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstKeyOnlyFilter_descriptor_;
}

const FirstKeyOnlyFilter& FirstKeyOnlyFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FirstKeyOnlyFilter* FirstKeyOnlyFilter::default_instance_ = NULL;

FirstKeyOnlyFilter* FirstKeyOnlyFilter::New() const {
  return new FirstKeyOnlyFilter;
}

void FirstKeyOnlyFilter::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirstKeyOnlyFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void FirstKeyOnlyFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirstKeyOnlyFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirstKeyOnlyFilter::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstKeyOnlyFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirstKeyOnlyFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirstKeyOnlyFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirstKeyOnlyFilter::MergeFrom(const FirstKeyOnlyFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirstKeyOnlyFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstKeyOnlyFilter::CopyFrom(const FirstKeyOnlyFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstKeyOnlyFilter::IsInitialized() const {

  return true;
}

void FirstKeyOnlyFilter::Swap(FirstKeyOnlyFilter* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirstKeyOnlyFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirstKeyOnlyFilter_descriptor_;
  metadata.reflection = FirstKeyOnlyFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FirstKeyValueMatchingQualifiersFilter::kQualifiersFieldNumber;
#endif  // !_MSC_VER

FirstKeyValueMatchingQualifiersFilter::FirstKeyValueMatchingQualifiersFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirstKeyValueMatchingQualifiersFilter::InitAsDefaultInstance() {
}

FirstKeyValueMatchingQualifiersFilter::FirstKeyValueMatchingQualifiersFilter(const FirstKeyValueMatchingQualifiersFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirstKeyValueMatchingQualifiersFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstKeyValueMatchingQualifiersFilter::~FirstKeyValueMatchingQualifiersFilter() {
  SharedDtor();
}

void FirstKeyValueMatchingQualifiersFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FirstKeyValueMatchingQualifiersFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirstKeyValueMatchingQualifiersFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstKeyValueMatchingQualifiersFilter_descriptor_;
}

const FirstKeyValueMatchingQualifiersFilter& FirstKeyValueMatchingQualifiersFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FirstKeyValueMatchingQualifiersFilter* FirstKeyValueMatchingQualifiersFilter::default_instance_ = NULL;

FirstKeyValueMatchingQualifiersFilter* FirstKeyValueMatchingQualifiersFilter::New() const {
  return new FirstKeyValueMatchingQualifiersFilter;
}

void FirstKeyValueMatchingQualifiersFilter::Clear() {
  qualifiers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirstKeyValueMatchingQualifiersFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes qualifiers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_qualifiers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_qualifiers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_qualifiers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirstKeyValueMatchingQualifiersFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes qualifiers = 1;
  for (int i = 0; i < this->qualifiers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->qualifiers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirstKeyValueMatchingQualifiersFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated bytes qualifiers = 1;
  for (int i = 0; i < this->qualifiers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->qualifiers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirstKeyValueMatchingQualifiersFilter::ByteSize() const {
  int total_size = 0;

  // repeated bytes qualifiers = 1;
  total_size += 1 * this->qualifiers_size();
  for (int i = 0; i < this->qualifiers_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->qualifiers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstKeyValueMatchingQualifiersFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirstKeyValueMatchingQualifiersFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirstKeyValueMatchingQualifiersFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirstKeyValueMatchingQualifiersFilter::MergeFrom(const FirstKeyValueMatchingQualifiersFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  qualifiers_.MergeFrom(from.qualifiers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirstKeyValueMatchingQualifiersFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstKeyValueMatchingQualifiersFilter::CopyFrom(const FirstKeyValueMatchingQualifiersFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstKeyValueMatchingQualifiersFilter::IsInitialized() const {

  return true;
}

void FirstKeyValueMatchingQualifiersFilter::Swap(FirstKeyValueMatchingQualifiersFilter* other) {
  if (other != this) {
    qualifiers_.Swap(&other->qualifiers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirstKeyValueMatchingQualifiersFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirstKeyValueMatchingQualifiersFilter_descriptor_;
  metadata.reflection = FirstKeyValueMatchingQualifiersFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FuzzyRowFilter::kFuzzyKeysDataFieldNumber;
#endif  // !_MSC_VER

FuzzyRowFilter::FuzzyRowFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FuzzyRowFilter::InitAsDefaultInstance() {
}

FuzzyRowFilter::FuzzyRowFilter(const FuzzyRowFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FuzzyRowFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FuzzyRowFilter::~FuzzyRowFilter() {
  SharedDtor();
}

void FuzzyRowFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FuzzyRowFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FuzzyRowFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FuzzyRowFilter_descriptor_;
}

const FuzzyRowFilter& FuzzyRowFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FuzzyRowFilter* FuzzyRowFilter::default_instance_ = NULL;

FuzzyRowFilter* FuzzyRowFilter::New() const {
  return new FuzzyRowFilter;
}

void FuzzyRowFilter::Clear() {
  fuzzy_keys_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FuzzyRowFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fuzzy_keys_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fuzzy_keys_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_fuzzy_keys_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FuzzyRowFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
  for (int i = 0; i < this->fuzzy_keys_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->fuzzy_keys_data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FuzzyRowFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
  for (int i = 0; i < this->fuzzy_keys_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->fuzzy_keys_data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FuzzyRowFilter::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
  total_size += 1 * this->fuzzy_keys_data_size();
  for (int i = 0; i < this->fuzzy_keys_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fuzzy_keys_data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FuzzyRowFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FuzzyRowFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FuzzyRowFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FuzzyRowFilter::MergeFrom(const FuzzyRowFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  fuzzy_keys_data_.MergeFrom(from.fuzzy_keys_data_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FuzzyRowFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FuzzyRowFilter::CopyFrom(const FuzzyRowFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FuzzyRowFilter::IsInitialized() const {

  for (int i = 0; i < fuzzy_keys_data_size(); i++) {
    if (!this->fuzzy_keys_data(i).IsInitialized()) return false;
  }
  return true;
}

void FuzzyRowFilter::Swap(FuzzyRowFilter* other) {
  if (other != this) {
    fuzzy_keys_data_.Swap(&other->fuzzy_keys_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FuzzyRowFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FuzzyRowFilter_descriptor_;
  metadata.reflection = FuzzyRowFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InclusiveStopFilter::kStopRowKeyFieldNumber;
#endif  // !_MSC_VER

InclusiveStopFilter::InclusiveStopFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InclusiveStopFilter::InitAsDefaultInstance() {
}

InclusiveStopFilter::InclusiveStopFilter(const InclusiveStopFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InclusiveStopFilter::SharedCtor() {
  _cached_size_ = 0;
  stop_row_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InclusiveStopFilter::~InclusiveStopFilter() {
  SharedDtor();
}

void InclusiveStopFilter::SharedDtor() {
  if (stop_row_key_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_row_key_;
  }
  if (this != default_instance_) {
  }
}

void InclusiveStopFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InclusiveStopFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InclusiveStopFilter_descriptor_;
}

const InclusiveStopFilter& InclusiveStopFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

InclusiveStopFilter* InclusiveStopFilter::default_instance_ = NULL;

InclusiveStopFilter* InclusiveStopFilter::New() const {
  return new InclusiveStopFilter;
}

void InclusiveStopFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_stop_row_key()) {
      if (stop_row_key_ != &::google::protobuf::internal::kEmptyString) {
        stop_row_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InclusiveStopFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes stop_row_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stop_row_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InclusiveStopFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes stop_row_key = 1;
  if (has_stop_row_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->stop_row_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InclusiveStopFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes stop_row_key = 1;
  if (has_stop_row_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->stop_row_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InclusiveStopFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes stop_row_key = 1;
    if (has_stop_row_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->stop_row_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InclusiveStopFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InclusiveStopFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InclusiveStopFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InclusiveStopFilter::MergeFrom(const InclusiveStopFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stop_row_key()) {
      set_stop_row_key(from.stop_row_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InclusiveStopFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InclusiveStopFilter::CopyFrom(const InclusiveStopFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InclusiveStopFilter::IsInitialized() const {

  return true;
}

void InclusiveStopFilter::Swap(InclusiveStopFilter* other) {
  if (other != this) {
    std::swap(stop_row_key_, other->stop_row_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InclusiveStopFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InclusiveStopFilter_descriptor_;
  metadata.reflection = InclusiveStopFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyOnlyFilter::kLenAsValFieldNumber;
#endif  // !_MSC_VER

KeyOnlyFilter::KeyOnlyFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyOnlyFilter::InitAsDefaultInstance() {
}

KeyOnlyFilter::KeyOnlyFilter(const KeyOnlyFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyOnlyFilter::SharedCtor() {
  _cached_size_ = 0;
  len_as_val_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyOnlyFilter::~KeyOnlyFilter() {
  SharedDtor();
}

void KeyOnlyFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KeyOnlyFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyOnlyFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyOnlyFilter_descriptor_;
}

const KeyOnlyFilter& KeyOnlyFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

KeyOnlyFilter* KeyOnlyFilter::default_instance_ = NULL;

KeyOnlyFilter* KeyOnlyFilter::New() const {
  return new KeyOnlyFilter;
}

void KeyOnlyFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    len_as_val_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyOnlyFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool len_as_val = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &len_as_val_)));
          set_has_len_as_val();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyOnlyFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool len_as_val = 1;
  if (has_len_as_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->len_as_val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyOnlyFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool len_as_val = 1;
  if (has_len_as_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->len_as_val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyOnlyFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool len_as_val = 1;
    if (has_len_as_val()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyOnlyFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyOnlyFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyOnlyFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyOnlyFilter::MergeFrom(const KeyOnlyFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_len_as_val()) {
      set_len_as_val(from.len_as_val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyOnlyFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyOnlyFilter::CopyFrom(const KeyOnlyFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyOnlyFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void KeyOnlyFilter::Swap(KeyOnlyFilter* other) {
  if (other != this) {
    std::swap(len_as_val_, other->len_as_val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyOnlyFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyOnlyFilter_descriptor_;
  metadata.reflection = KeyOnlyFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MultipleColumnPrefixFilter::kSortedPrefixesFieldNumber;
#endif  // !_MSC_VER

MultipleColumnPrefixFilter::MultipleColumnPrefixFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MultipleColumnPrefixFilter::InitAsDefaultInstance() {
}

MultipleColumnPrefixFilter::MultipleColumnPrefixFilter(const MultipleColumnPrefixFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MultipleColumnPrefixFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultipleColumnPrefixFilter::~MultipleColumnPrefixFilter() {
  SharedDtor();
}

void MultipleColumnPrefixFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MultipleColumnPrefixFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultipleColumnPrefixFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultipleColumnPrefixFilter_descriptor_;
}

const MultipleColumnPrefixFilter& MultipleColumnPrefixFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

MultipleColumnPrefixFilter* MultipleColumnPrefixFilter::default_instance_ = NULL;

MultipleColumnPrefixFilter* MultipleColumnPrefixFilter::New() const {
  return new MultipleColumnPrefixFilter;
}

void MultipleColumnPrefixFilter::Clear() {
  sorted_prefixes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultipleColumnPrefixFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes sorted_prefixes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sorted_prefixes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sorted_prefixes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sorted_prefixes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MultipleColumnPrefixFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes sorted_prefixes = 1;
  for (int i = 0; i < this->sorted_prefixes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->sorted_prefixes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MultipleColumnPrefixFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated bytes sorted_prefixes = 1;
  for (int i = 0; i < this->sorted_prefixes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->sorted_prefixes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MultipleColumnPrefixFilter::ByteSize() const {
  int total_size = 0;

  // repeated bytes sorted_prefixes = 1;
  total_size += 1 * this->sorted_prefixes_size();
  for (int i = 0; i < this->sorted_prefixes_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sorted_prefixes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultipleColumnPrefixFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultipleColumnPrefixFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultipleColumnPrefixFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultipleColumnPrefixFilter::MergeFrom(const MultipleColumnPrefixFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  sorted_prefixes_.MergeFrom(from.sorted_prefixes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultipleColumnPrefixFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultipleColumnPrefixFilter::CopyFrom(const MultipleColumnPrefixFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultipleColumnPrefixFilter::IsInitialized() const {

  return true;
}

void MultipleColumnPrefixFilter::Swap(MultipleColumnPrefixFilter* other) {
  if (other != this) {
    sorted_prefixes_.Swap(&other->sorted_prefixes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultipleColumnPrefixFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultipleColumnPrefixFilter_descriptor_;
  metadata.reflection = MultipleColumnPrefixFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PageFilter::kPageSizeFieldNumber;
#endif  // !_MSC_VER

PageFilter::PageFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PageFilter::InitAsDefaultInstance() {
}

PageFilter::PageFilter(const PageFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PageFilter::SharedCtor() {
  _cached_size_ = 0;
  page_size_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PageFilter::~PageFilter() {
  SharedDtor();
}

void PageFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PageFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PageFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PageFilter_descriptor_;
}

const PageFilter& PageFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

PageFilter* PageFilter::default_instance_ = NULL;

PageFilter* PageFilter::New() const {
  return new PageFilter;
}

void PageFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_size_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PageFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 page_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &page_size_)));
          set_has_page_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PageFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 page_size = 1;
  if (has_page_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->page_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PageFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 page_size = 1;
  if (has_page_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->page_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PageFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 page_size = 1;
    if (has_page_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->page_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PageFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PageFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PageFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PageFilter::MergeFrom(const PageFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page_size()) {
      set_page_size(from.page_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PageFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PageFilter::CopyFrom(const PageFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PageFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PageFilter::Swap(PageFilter* other) {
  if (other != this) {
    std::swap(page_size_, other->page_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PageFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PageFilter_descriptor_;
  metadata.reflection = PageFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PrefixFilter::kPrefixFieldNumber;
#endif  // !_MSC_VER

PrefixFilter::PrefixFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PrefixFilter::InitAsDefaultInstance() {
}

PrefixFilter::PrefixFilter(const PrefixFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PrefixFilter::SharedCtor() {
  _cached_size_ = 0;
  prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PrefixFilter::~PrefixFilter() {
  SharedDtor();
}

void PrefixFilter::SharedDtor() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (this != default_instance_) {
  }
}

void PrefixFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PrefixFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PrefixFilter_descriptor_;
}

const PrefixFilter& PrefixFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

PrefixFilter* PrefixFilter::default_instance_ = NULL;

PrefixFilter* PrefixFilter::New() const {
  return new PrefixFilter;
}

void PrefixFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_prefix()) {
      if (prefix_ != &::google::protobuf::internal::kEmptyString) {
        prefix_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PrefixFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes prefix = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prefix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PrefixFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes prefix = 1;
  if (has_prefix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->prefix(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PrefixFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes prefix = 1;
  if (has_prefix()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->prefix(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PrefixFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes prefix = 1;
    if (has_prefix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prefix());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PrefixFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PrefixFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PrefixFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PrefixFilter::MergeFrom(const PrefixFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_prefix()) {
      set_prefix(from.prefix());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PrefixFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrefixFilter::CopyFrom(const PrefixFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrefixFilter::IsInitialized() const {

  return true;
}

void PrefixFilter::Swap(PrefixFilter* other) {
  if (other != this) {
    std::swap(prefix_, other->prefix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PrefixFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PrefixFilter_descriptor_;
  metadata.reflection = PrefixFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QualifierFilter::kCompareFilterFieldNumber;
#endif  // !_MSC_VER

QualifierFilter::QualifierFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void QualifierFilter::InitAsDefaultInstance() {
  compare_filter_ = const_cast< ::hbase::pb::CompareFilter*>(&::hbase::pb::CompareFilter::default_instance());
}

QualifierFilter::QualifierFilter(const QualifierFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void QualifierFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QualifierFilter::~QualifierFilter() {
  SharedDtor();
}

void QualifierFilter::SharedDtor() {
  if (this != default_instance_) {
    delete compare_filter_;
  }
}

void QualifierFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QualifierFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QualifierFilter_descriptor_;
}

const QualifierFilter& QualifierFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

QualifierFilter* QualifierFilter::default_instance_ = NULL;

QualifierFilter* QualifierFilter::New() const {
  return new QualifierFilter;
}

void QualifierFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_compare_filter()) {
      if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QualifierFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareFilter compare_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compare_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QualifierFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->compare_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* QualifierFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->compare_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int QualifierFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareFilter compare_filter = 1;
    if (has_compare_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compare_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QualifierFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QualifierFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QualifierFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QualifierFilter::MergeFrom(const QualifierFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_filter()) {
      mutable_compare_filter()->::hbase::pb::CompareFilter::MergeFrom(from.compare_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QualifierFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QualifierFilter::CopyFrom(const QualifierFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QualifierFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_compare_filter()) {
    if (!this->compare_filter().IsInitialized()) return false;
  }
  return true;
}

void QualifierFilter::Swap(QualifierFilter* other) {
  if (other != this) {
    std::swap(compare_filter_, other->compare_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QualifierFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QualifierFilter_descriptor_;
  metadata.reflection = QualifierFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RandomRowFilter::kChanceFieldNumber;
#endif  // !_MSC_VER

RandomRowFilter::RandomRowFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RandomRowFilter::InitAsDefaultInstance() {
}

RandomRowFilter::RandomRowFilter(const RandomRowFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RandomRowFilter::SharedCtor() {
  _cached_size_ = 0;
  chance_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RandomRowFilter::~RandomRowFilter() {
  SharedDtor();
}

void RandomRowFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RandomRowFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RandomRowFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RandomRowFilter_descriptor_;
}

const RandomRowFilter& RandomRowFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

RandomRowFilter* RandomRowFilter::default_instance_ = NULL;

RandomRowFilter* RandomRowFilter::New() const {
  return new RandomRowFilter;
}

void RandomRowFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chance_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RandomRowFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float chance = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &chance_)));
          set_has_chance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RandomRowFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float chance = 1;
  if (has_chance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->chance(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RandomRowFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float chance = 1;
  if (has_chance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->chance(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RandomRowFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float chance = 1;
    if (has_chance()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RandomRowFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RandomRowFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RandomRowFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RandomRowFilter::MergeFrom(const RandomRowFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chance()) {
      set_chance(from.chance());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RandomRowFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RandomRowFilter::CopyFrom(const RandomRowFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomRowFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RandomRowFilter::Swap(RandomRowFilter* other) {
  if (other != this) {
    std::swap(chance_, other->chance_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RandomRowFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RandomRowFilter_descriptor_;
  metadata.reflection = RandomRowFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RowFilter::kCompareFilterFieldNumber;
#endif  // !_MSC_VER

RowFilter::RowFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RowFilter::InitAsDefaultInstance() {
  compare_filter_ = const_cast< ::hbase::pb::CompareFilter*>(&::hbase::pb::CompareFilter::default_instance());
}

RowFilter::RowFilter(const RowFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RowFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RowFilter::~RowFilter() {
  SharedDtor();
}

void RowFilter::SharedDtor() {
  if (this != default_instance_) {
    delete compare_filter_;
  }
}

void RowFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RowFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RowFilter_descriptor_;
}

const RowFilter& RowFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

RowFilter* RowFilter::default_instance_ = NULL;

RowFilter* RowFilter::New() const {
  return new RowFilter;
}

void RowFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_compare_filter()) {
      if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RowFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareFilter compare_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compare_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RowFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->compare_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RowFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->compare_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RowFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareFilter compare_filter = 1;
    if (has_compare_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compare_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RowFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RowFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RowFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RowFilter::MergeFrom(const RowFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_filter()) {
      mutable_compare_filter()->::hbase::pb::CompareFilter::MergeFrom(from.compare_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RowFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RowFilter::CopyFrom(const RowFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_compare_filter()) {
    if (!this->compare_filter().IsInitialized()) return false;
  }
  return true;
}

void RowFilter::Swap(RowFilter* other) {
  if (other != this) {
    std::swap(compare_filter_, other->compare_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RowFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RowFilter_descriptor_;
  metadata.reflection = RowFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SingleColumnValueExcludeFilter::kSingleColumnValueFilterFieldNumber;
#endif  // !_MSC_VER

SingleColumnValueExcludeFilter::SingleColumnValueExcludeFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SingleColumnValueExcludeFilter::InitAsDefaultInstance() {
  single_column_value_filter_ = const_cast< ::hbase::pb::SingleColumnValueFilter*>(&::hbase::pb::SingleColumnValueFilter::default_instance());
}

SingleColumnValueExcludeFilter::SingleColumnValueExcludeFilter(const SingleColumnValueExcludeFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SingleColumnValueExcludeFilter::SharedCtor() {
  _cached_size_ = 0;
  single_column_value_filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SingleColumnValueExcludeFilter::~SingleColumnValueExcludeFilter() {
  SharedDtor();
}

void SingleColumnValueExcludeFilter::SharedDtor() {
  if (this != default_instance_) {
    delete single_column_value_filter_;
  }
}

void SingleColumnValueExcludeFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SingleColumnValueExcludeFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SingleColumnValueExcludeFilter_descriptor_;
}

const SingleColumnValueExcludeFilter& SingleColumnValueExcludeFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

SingleColumnValueExcludeFilter* SingleColumnValueExcludeFilter::default_instance_ = NULL;

SingleColumnValueExcludeFilter* SingleColumnValueExcludeFilter::New() const {
  return new SingleColumnValueExcludeFilter;
}

void SingleColumnValueExcludeFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_single_column_value_filter()) {
      if (single_column_value_filter_ != NULL) single_column_value_filter_->::hbase::pb::SingleColumnValueFilter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SingleColumnValueExcludeFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_single_column_value_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SingleColumnValueExcludeFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
  if (has_single_column_value_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->single_column_value_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SingleColumnValueExcludeFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
  if (has_single_column_value_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->single_column_value_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SingleColumnValueExcludeFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
    if (has_single_column_value_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->single_column_value_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleColumnValueExcludeFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SingleColumnValueExcludeFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SingleColumnValueExcludeFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SingleColumnValueExcludeFilter::MergeFrom(const SingleColumnValueExcludeFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_single_column_value_filter()) {
      mutable_single_column_value_filter()->::hbase::pb::SingleColumnValueFilter::MergeFrom(from.single_column_value_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SingleColumnValueExcludeFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SingleColumnValueExcludeFilter::CopyFrom(const SingleColumnValueExcludeFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleColumnValueExcludeFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_single_column_value_filter()) {
    if (!this->single_column_value_filter().IsInitialized()) return false;
  }
  return true;
}

void SingleColumnValueExcludeFilter::Swap(SingleColumnValueExcludeFilter* other) {
  if (other != this) {
    std::swap(single_column_value_filter_, other->single_column_value_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SingleColumnValueExcludeFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SingleColumnValueExcludeFilter_descriptor_;
  metadata.reflection = SingleColumnValueExcludeFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SingleColumnValueFilter::kColumnFamilyFieldNumber;
const int SingleColumnValueFilter::kColumnQualifierFieldNumber;
const int SingleColumnValueFilter::kCompareOpFieldNumber;
const int SingleColumnValueFilter::kComparatorFieldNumber;
const int SingleColumnValueFilter::kFilterIfMissingFieldNumber;
const int SingleColumnValueFilter::kLatestVersionOnlyFieldNumber;
#endif  // !_MSC_VER

SingleColumnValueFilter::SingleColumnValueFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SingleColumnValueFilter::InitAsDefaultInstance() {
  comparator_ = const_cast< ::hbase::pb::Comparator*>(&::hbase::pb::Comparator::default_instance());
}

SingleColumnValueFilter::SingleColumnValueFilter(const SingleColumnValueFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SingleColumnValueFilter::SharedCtor() {
  _cached_size_ = 0;
  column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  compare_op_ = 0;
  comparator_ = NULL;
  filter_if_missing_ = false;
  latest_version_only_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SingleColumnValueFilter::~SingleColumnValueFilter() {
  SharedDtor();
}

void SingleColumnValueFilter::SharedDtor() {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    delete column_family_;
  }
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete column_qualifier_;
  }
  if (this != default_instance_) {
    delete comparator_;
  }
}

void SingleColumnValueFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SingleColumnValueFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SingleColumnValueFilter_descriptor_;
}

const SingleColumnValueFilter& SingleColumnValueFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

SingleColumnValueFilter* SingleColumnValueFilter::default_instance_ = NULL;

SingleColumnValueFilter* SingleColumnValueFilter::New() const {
  return new SingleColumnValueFilter;
}

void SingleColumnValueFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_column_family()) {
      if (column_family_ != &::google::protobuf::internal::kEmptyString) {
        column_family_->clear();
      }
    }
    if (has_column_qualifier()) {
      if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
        column_qualifier_->clear();
      }
    }
    compare_op_ = 0;
    if (has_comparator()) {
      if (comparator_ != NULL) comparator_->::hbase::pb::Comparator::Clear();
    }
    filter_if_missing_ = false;
    latest_version_only_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SingleColumnValueFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes column_family = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_family()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_column_qualifier;
        break;
      }

      // optional bytes column_qualifier = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column_qualifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_qualifier()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_compare_op;
        break;
      }

      // required .hbase.pb.CompareType compare_op = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_compare_op:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::CompareType_IsValid(value)) {
            set_compare_op(static_cast< ::hbase::pb::CompareType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_comparator;
        break;
      }

      // required .hbase.pb.Comparator comparator = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comparator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_comparator()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_filter_if_missing;
        break;
      }

      // optional bool filter_if_missing = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_if_missing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &filter_if_missing_)));
          set_has_filter_if_missing();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_latest_version_only;
        break;
      }

      // optional bool latest_version_only = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_latest_version_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &latest_version_only_)));
          set_has_latest_version_only();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SingleColumnValueFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes column_family = 1;
  if (has_column_family()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->column_family(), output);
  }

  // optional bytes column_qualifier = 2;
  if (has_column_qualifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->column_qualifier(), output);
  }

  // required .hbase.pb.CompareType compare_op = 3;
  if (has_compare_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->compare_op(), output);
  }

  // required .hbase.pb.Comparator comparator = 4;
  if (has_comparator()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->comparator(), output);
  }

  // optional bool filter_if_missing = 5;
  if (has_filter_if_missing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->filter_if_missing(), output);
  }

  // optional bool latest_version_only = 6;
  if (has_latest_version_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->latest_version_only(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SingleColumnValueFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes column_family = 1;
  if (has_column_family()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->column_family(), target);
  }

  // optional bytes column_qualifier = 2;
  if (has_column_qualifier()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->column_qualifier(), target);
  }

  // required .hbase.pb.CompareType compare_op = 3;
  if (has_compare_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->compare_op(), target);
  }

  // required .hbase.pb.Comparator comparator = 4;
  if (has_comparator()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->comparator(), target);
  }

  // optional bool filter_if_missing = 5;
  if (has_filter_if_missing()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->filter_if_missing(), target);
  }

  // optional bool latest_version_only = 6;
  if (has_latest_version_only()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->latest_version_only(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SingleColumnValueFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes column_family = 1;
    if (has_column_family()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->column_family());
    }

    // optional bytes column_qualifier = 2;
    if (has_column_qualifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->column_qualifier());
    }

    // required .hbase.pb.CompareType compare_op = 3;
    if (has_compare_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compare_op());
    }

    // required .hbase.pb.Comparator comparator = 4;
    if (has_comparator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->comparator());
    }

    // optional bool filter_if_missing = 5;
    if (has_filter_if_missing()) {
      total_size += 1 + 1;
    }

    // optional bool latest_version_only = 6;
    if (has_latest_version_only()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleColumnValueFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SingleColumnValueFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SingleColumnValueFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SingleColumnValueFilter::MergeFrom(const SingleColumnValueFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_column_family()) {
      set_column_family(from.column_family());
    }
    if (from.has_column_qualifier()) {
      set_column_qualifier(from.column_qualifier());
    }
    if (from.has_compare_op()) {
      set_compare_op(from.compare_op());
    }
    if (from.has_comparator()) {
      mutable_comparator()->::hbase::pb::Comparator::MergeFrom(from.comparator());
    }
    if (from.has_filter_if_missing()) {
      set_filter_if_missing(from.filter_if_missing());
    }
    if (from.has_latest_version_only()) {
      set_latest_version_only(from.latest_version_only());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SingleColumnValueFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SingleColumnValueFilter::CopyFrom(const SingleColumnValueFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleColumnValueFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  if (has_comparator()) {
    if (!this->comparator().IsInitialized()) return false;
  }
  return true;
}

void SingleColumnValueFilter::Swap(SingleColumnValueFilter* other) {
  if (other != this) {
    std::swap(column_family_, other->column_family_);
    std::swap(column_qualifier_, other->column_qualifier_);
    std::swap(compare_op_, other->compare_op_);
    std::swap(comparator_, other->comparator_);
    std::swap(filter_if_missing_, other->filter_if_missing_);
    std::swap(latest_version_only_, other->latest_version_only_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SingleColumnValueFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SingleColumnValueFilter_descriptor_;
  metadata.reflection = SingleColumnValueFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SkipFilter::kFilterFieldNumber;
#endif  // !_MSC_VER

SkipFilter::SkipFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SkipFilter::InitAsDefaultInstance() {
  filter_ = const_cast< ::hbase::pb::Filter*>(&::hbase::pb::Filter::default_instance());
}

SkipFilter::SkipFilter(const SkipFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SkipFilter::SharedCtor() {
  _cached_size_ = 0;
  filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkipFilter::~SkipFilter() {
  SharedDtor();
}

void SkipFilter::SharedDtor() {
  if (this != default_instance_) {
    delete filter_;
  }
}

void SkipFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SkipFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SkipFilter_descriptor_;
}

const SkipFilter& SkipFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

SkipFilter* SkipFilter::default_instance_ = NULL;

SkipFilter* SkipFilter::New() const {
  return new SkipFilter;
}

void SkipFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter()) {
      if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SkipFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.Filter filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SkipFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SkipFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SkipFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.Filter filter = 1;
    if (has_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkipFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SkipFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SkipFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SkipFilter::MergeFrom(const SkipFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter()) {
      mutable_filter()->::hbase::pb::Filter::MergeFrom(from.filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SkipFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SkipFilter::CopyFrom(const SkipFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkipFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_filter()) {
    if (!this->filter().IsInitialized()) return false;
  }
  return true;
}

void SkipFilter::Swap(SkipFilter* other) {
  if (other != this) {
    std::swap(filter_, other->filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SkipFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SkipFilter_descriptor_;
  metadata.reflection = SkipFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimestampsFilter::kTimestampsFieldNumber;
#endif  // !_MSC_VER

TimestampsFilter::TimestampsFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TimestampsFilter::InitAsDefaultInstance() {
}

TimestampsFilter::TimestampsFilter(const TimestampsFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TimestampsFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimestampsFilter::~TimestampsFilter() {
  SharedDtor();
}

void TimestampsFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimestampsFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimestampsFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimestampsFilter_descriptor_;
}

const TimestampsFilter& TimestampsFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

TimestampsFilter* TimestampsFilter::default_instance_ = NULL;

TimestampsFilter* TimestampsFilter::New() const {
  return new TimestampsFilter;
}

void TimestampsFilter::Clear() {
  timestamps_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimestampsFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 timestamps = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_timestamps())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10, input, this->mutable_timestamps())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TimestampsFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int64 timestamps = 1 [packed = true];
  if (this->timestamps_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_timestamps_cached_byte_size_);
  }
  for (int i = 0; i < this->timestamps_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->timestamps(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TimestampsFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int64 timestamps = 1 [packed = true];
  if (this->timestamps_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _timestamps_cached_byte_size_, target);
  }
  for (int i = 0; i < this->timestamps_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt64NoTagToArray(this->timestamps(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TimestampsFilter::ByteSize() const {
  int total_size = 0;

  // repeated int64 timestamps = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->timestamps_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->timestamps(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _timestamps_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimestampsFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimestampsFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimestampsFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimestampsFilter::MergeFrom(const TimestampsFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  timestamps_.MergeFrom(from.timestamps_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimestampsFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimestampsFilter::CopyFrom(const TimestampsFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampsFilter::IsInitialized() const {

  return true;
}

void TimestampsFilter::Swap(TimestampsFilter* other) {
  if (other != this) {
    timestamps_.Swap(&other->timestamps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimestampsFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimestampsFilter_descriptor_;
  metadata.reflection = TimestampsFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ValueFilter::kCompareFilterFieldNumber;
#endif  // !_MSC_VER

ValueFilter::ValueFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ValueFilter::InitAsDefaultInstance() {
  compare_filter_ = const_cast< ::hbase::pb::CompareFilter*>(&::hbase::pb::CompareFilter::default_instance());
}

ValueFilter::ValueFilter(const ValueFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ValueFilter::SharedCtor() {
  _cached_size_ = 0;
  compare_filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ValueFilter::~ValueFilter() {
  SharedDtor();
}

void ValueFilter::SharedDtor() {
  if (this != default_instance_) {
    delete compare_filter_;
  }
}

void ValueFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ValueFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ValueFilter_descriptor_;
}

const ValueFilter& ValueFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

ValueFilter* ValueFilter::default_instance_ = NULL;

ValueFilter* ValueFilter::New() const {
  return new ValueFilter;
}

void ValueFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_compare_filter()) {
      if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ValueFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.CompareFilter compare_filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compare_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ValueFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->compare_filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ValueFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.CompareFilter compare_filter = 1;
  if (has_compare_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->compare_filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ValueFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.CompareFilter compare_filter = 1;
    if (has_compare_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compare_filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ValueFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ValueFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ValueFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ValueFilter::MergeFrom(const ValueFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_compare_filter()) {
      mutable_compare_filter()->::hbase::pb::CompareFilter::MergeFrom(from.compare_filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ValueFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ValueFilter::CopyFrom(const ValueFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_compare_filter()) {
    if (!this->compare_filter().IsInitialized()) return false;
  }
  return true;
}

void ValueFilter::Swap(ValueFilter* other) {
  if (other != this) {
    std::swap(compare_filter_, other->compare_filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ValueFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ValueFilter_descriptor_;
  metadata.reflection = ValueFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WhileMatchFilter::kFilterFieldNumber;
#endif  // !_MSC_VER

WhileMatchFilter::WhileMatchFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WhileMatchFilter::InitAsDefaultInstance() {
  filter_ = const_cast< ::hbase::pb::Filter*>(&::hbase::pb::Filter::default_instance());
}

WhileMatchFilter::WhileMatchFilter(const WhileMatchFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WhileMatchFilter::SharedCtor() {
  _cached_size_ = 0;
  filter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WhileMatchFilter::~WhileMatchFilter() {
  SharedDtor();
}

void WhileMatchFilter::SharedDtor() {
  if (this != default_instance_) {
    delete filter_;
  }
}

void WhileMatchFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WhileMatchFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WhileMatchFilter_descriptor_;
}

const WhileMatchFilter& WhileMatchFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

WhileMatchFilter* WhileMatchFilter::default_instance_ = NULL;

WhileMatchFilter* WhileMatchFilter::New() const {
  return new WhileMatchFilter;
}

void WhileMatchFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter()) {
      if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WhileMatchFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.Filter filter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WhileMatchFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->filter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WhileMatchFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.Filter filter = 1;
  if (has_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->filter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WhileMatchFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.Filter filter = 1;
    if (has_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WhileMatchFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WhileMatchFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WhileMatchFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WhileMatchFilter::MergeFrom(const WhileMatchFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter()) {
      mutable_filter()->::hbase::pb::Filter::MergeFrom(from.filter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WhileMatchFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WhileMatchFilter::CopyFrom(const WhileMatchFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhileMatchFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_filter()) {
    if (!this->filter().IsInitialized()) return false;
  }
  return true;
}

void WhileMatchFilter::Swap(WhileMatchFilter* other) {
  if (other != this) {
    std::swap(filter_, other->filter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WhileMatchFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WhileMatchFilter_descriptor_;
  metadata.reflection = WhileMatchFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

FilterAllFilter::FilterAllFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FilterAllFilter::InitAsDefaultInstance() {
}

FilterAllFilter::FilterAllFilter(const FilterAllFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FilterAllFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterAllFilter::~FilterAllFilter() {
  SharedDtor();
}

void FilterAllFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FilterAllFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilterAllFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterAllFilter_descriptor_;
}

const FilterAllFilter& FilterAllFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

FilterAllFilter* FilterAllFilter::default_instance_ = NULL;

FilterAllFilter* FilterAllFilter::New() const {
  return new FilterAllFilter;
}

void FilterAllFilter::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilterAllFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void FilterAllFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FilterAllFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FilterAllFilter::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterAllFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilterAllFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilterAllFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilterAllFilter::MergeFrom(const FilterAllFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilterAllFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilterAllFilter::CopyFrom(const FilterAllFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterAllFilter::IsInitialized() const {

  return true;
}

void FilterAllFilter::Swap(FilterAllFilter* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilterAllFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilterAllFilter_descriptor_;
  metadata.reflection = FilterAllFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RowRange::kStartRowFieldNumber;
const int RowRange::kStartRowInclusiveFieldNumber;
const int RowRange::kStopRowFieldNumber;
const int RowRange::kStopRowInclusiveFieldNumber;
#endif  // !_MSC_VER

RowRange::RowRange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RowRange::InitAsDefaultInstance() {
}

RowRange::RowRange(const RowRange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RowRange::SharedCtor() {
  _cached_size_ = 0;
  start_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  start_row_inclusive_ = false;
  stop_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  stop_row_inclusive_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RowRange::~RowRange() {
  SharedDtor();
}

void RowRange::SharedDtor() {
  if (start_row_ != &::google::protobuf::internal::kEmptyString) {
    delete start_row_;
  }
  if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_row_;
  }
  if (this != default_instance_) {
  }
}

void RowRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RowRange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RowRange_descriptor_;
}

const RowRange& RowRange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

RowRange* RowRange::default_instance_ = NULL;

RowRange* RowRange::New() const {
  return new RowRange;
}

void RowRange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_start_row()) {
      if (start_row_ != &::google::protobuf::internal::kEmptyString) {
        start_row_->clear();
      }
    }
    start_row_inclusive_ = false;
    if (has_stop_row()) {
      if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
        stop_row_->clear();
      }
    }
    stop_row_inclusive_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RowRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes start_row = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_start_row()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_row_inclusive;
        break;
      }

      // optional bool start_row_inclusive = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_row_inclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &start_row_inclusive_)));
          set_has_start_row_inclusive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_stop_row;
        break;
      }

      // optional bytes stop_row = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stop_row:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stop_row()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_stop_row_inclusive;
        break;
      }

      // optional bool stop_row_inclusive = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stop_row_inclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stop_row_inclusive_)));
          set_has_stop_row_inclusive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RowRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes start_row = 1;
  if (has_start_row()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->start_row(), output);
  }

  // optional bool start_row_inclusive = 2;
  if (has_start_row_inclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->start_row_inclusive(), output);
  }

  // optional bytes stop_row = 3;
  if (has_stop_row()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->stop_row(), output);
  }

  // optional bool stop_row_inclusive = 4;
  if (has_stop_row_inclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->stop_row_inclusive(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RowRange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes start_row = 1;
  if (has_start_row()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->start_row(), target);
  }

  // optional bool start_row_inclusive = 2;
  if (has_start_row_inclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->start_row_inclusive(), target);
  }

  // optional bytes stop_row = 3;
  if (has_stop_row()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->stop_row(), target);
  }

  // optional bool stop_row_inclusive = 4;
  if (has_stop_row_inclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->stop_row_inclusive(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RowRange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes start_row = 1;
    if (has_start_row()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->start_row());
    }

    // optional bool start_row_inclusive = 2;
    if (has_start_row_inclusive()) {
      total_size += 1 + 1;
    }

    // optional bytes stop_row = 3;
    if (has_stop_row()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->stop_row());
    }

    // optional bool stop_row_inclusive = 4;
    if (has_stop_row_inclusive()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RowRange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RowRange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RowRange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RowRange::MergeFrom(const RowRange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_row()) {
      set_start_row(from.start_row());
    }
    if (from.has_start_row_inclusive()) {
      set_start_row_inclusive(from.start_row_inclusive());
    }
    if (from.has_stop_row()) {
      set_stop_row(from.stop_row());
    }
    if (from.has_stop_row_inclusive()) {
      set_stop_row_inclusive(from.stop_row_inclusive());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RowRange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RowRange::CopyFrom(const RowRange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowRange::IsInitialized() const {

  return true;
}

void RowRange::Swap(RowRange* other) {
  if (other != this) {
    std::swap(start_row_, other->start_row_);
    std::swap(start_row_inclusive_, other->start_row_inclusive_);
    std::swap(stop_row_, other->stop_row_);
    std::swap(stop_row_inclusive_, other->stop_row_inclusive_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RowRange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RowRange_descriptor_;
  metadata.reflection = RowRange_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MultiRowRangeFilter::kRowRangeListFieldNumber;
#endif  // !_MSC_VER

MultiRowRangeFilter::MultiRowRangeFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MultiRowRangeFilter::InitAsDefaultInstance() {
}

MultiRowRangeFilter::MultiRowRangeFilter(const MultiRowRangeFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MultiRowRangeFilter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultiRowRangeFilter::~MultiRowRangeFilter() {
  SharedDtor();
}

void MultiRowRangeFilter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MultiRowRangeFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultiRowRangeFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultiRowRangeFilter_descriptor_;
}

const MultiRowRangeFilter& MultiRowRangeFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Filter_2eproto();
  return *default_instance_;
}

MultiRowRangeFilter* MultiRowRangeFilter::default_instance_ = NULL;

MultiRowRangeFilter* MultiRowRangeFilter::New() const {
  return new MultiRowRangeFilter;
}

void MultiRowRangeFilter::Clear() {
  row_range_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultiRowRangeFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.RowRange row_range_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_row_range_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_row_range_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_row_range_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MultiRowRangeFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.RowRange row_range_list = 1;
  for (int i = 0; i < this->row_range_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->row_range_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MultiRowRangeFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.RowRange row_range_list = 1;
  for (int i = 0; i < this->row_range_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->row_range_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MultiRowRangeFilter::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.RowRange row_range_list = 1;
  total_size += 1 * this->row_range_list_size();
  for (int i = 0; i < this->row_range_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->row_range_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultiRowRangeFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultiRowRangeFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultiRowRangeFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultiRowRangeFilter::MergeFrom(const MultiRowRangeFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  row_range_list_.MergeFrom(from.row_range_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultiRowRangeFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultiRowRangeFilter::CopyFrom(const MultiRowRangeFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiRowRangeFilter::IsInitialized() const {

  return true;
}

void MultiRowRangeFilter::Swap(MultiRowRangeFilter* other) {
  if (other != this) {
    row_range_list_.Swap(&other->row_range_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultiRowRangeFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultiRowRangeFilter_descriptor_;
  metadata.reflection = MultiRowRangeFilter_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

// @@protoc_insertion_point(global_scope)
