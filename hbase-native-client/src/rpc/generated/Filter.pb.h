// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Filter.proto

#ifndef PROTOBUF_Filter_2eproto__INCLUDED
#define PROTOBUF_Filter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Comparator.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Filter_2eproto();
void protobuf_AssignDesc_Filter_2eproto();
void protobuf_ShutdownFile_Filter_2eproto();

class Filter;
class ColumnCountGetFilter;
class ColumnPaginationFilter;
class ColumnPrefixFilter;
class ColumnRangeFilter;
class CompareFilter;
class DependentColumnFilter;
class FamilyFilter;
class FilterList;
class FilterWrapper;
class FirstKeyOnlyFilter;
class FirstKeyValueMatchingQualifiersFilter;
class FuzzyRowFilter;
class InclusiveStopFilter;
class KeyOnlyFilter;
class MultipleColumnPrefixFilter;
class PageFilter;
class PrefixFilter;
class QualifierFilter;
class RandomRowFilter;
class RowFilter;
class SingleColumnValueExcludeFilter;
class SingleColumnValueFilter;
class SkipFilter;
class TimestampsFilter;
class ValueFilter;
class WhileMatchFilter;
class FilterAllFilter;
class RowRange;
class MultiRowRangeFilter;

enum FilterList_Operator {
  FilterList_Operator_MUST_PASS_ALL = 1,
  FilterList_Operator_MUST_PASS_ONE = 2
};
bool FilterList_Operator_IsValid(int value);
const FilterList_Operator FilterList_Operator_Operator_MIN = FilterList_Operator_MUST_PASS_ALL;
const FilterList_Operator FilterList_Operator_Operator_MAX = FilterList_Operator_MUST_PASS_ONE;
const int FilterList_Operator_Operator_ARRAYSIZE = FilterList_Operator_Operator_MAX + 1;

const ::google::protobuf::EnumDescriptor* FilterList_Operator_descriptor();
inline const ::std::string& FilterList_Operator_Name(FilterList_Operator value) {
  return ::google::protobuf::internal::NameOfEnum(
    FilterList_Operator_descriptor(), value);
}
inline bool FilterList_Operator_Parse(
    const ::std::string& name, FilterList_Operator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterList_Operator>(
    FilterList_Operator_descriptor(), name, value);
}
// ===================================================================

class Filter : public ::google::protobuf::Message {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Filter& default_instance();

  void Swap(Filter* other);

  // implements Message ----------------------------------------------

  Filter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes serialized_filter = 2;
  inline bool has_serialized_filter() const;
  inline void clear_serialized_filter();
  static const int kSerializedFilterFieldNumber = 2;
  inline const ::std::string& serialized_filter() const;
  inline void set_serialized_filter(const ::std::string& value);
  inline void set_serialized_filter(const char* value);
  inline void set_serialized_filter(const void* value, size_t size);
  inline ::std::string* mutable_serialized_filter();
  inline ::std::string* release_serialized_filter();
  inline void set_allocated_serialized_filter(::std::string* serialized_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.Filter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_serialized_filter();
  inline void clear_has_serialized_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* serialized_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static Filter* default_instance_;
};
// -------------------------------------------------------------------

class ColumnCountGetFilter : public ::google::protobuf::Message {
 public:
  ColumnCountGetFilter();
  virtual ~ColumnCountGetFilter();

  ColumnCountGetFilter(const ColumnCountGetFilter& from);

  inline ColumnCountGetFilter& operator=(const ColumnCountGetFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnCountGetFilter& default_instance();

  void Swap(ColumnCountGetFilter* other);

  // implements Message ----------------------------------------------

  ColumnCountGetFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnCountGetFilter& from);
  void MergeFrom(const ColumnCountGetFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnCountGetFilter)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static ColumnCountGetFilter* default_instance_;
};
// -------------------------------------------------------------------

class ColumnPaginationFilter : public ::google::protobuf::Message {
 public:
  ColumnPaginationFilter();
  virtual ~ColumnPaginationFilter();

  ColumnPaginationFilter(const ColumnPaginationFilter& from);

  inline ColumnPaginationFilter& operator=(const ColumnPaginationFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnPaginationFilter& default_instance();

  void Swap(ColumnPaginationFilter* other);

  // implements Message ----------------------------------------------

  ColumnPaginationFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnPaginationFilter& from);
  void MergeFrom(const ColumnPaginationFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // optional int32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional bytes column_offset = 3;
  inline bool has_column_offset() const;
  inline void clear_column_offset();
  static const int kColumnOffsetFieldNumber = 3;
  inline const ::std::string& column_offset() const;
  inline void set_column_offset(const ::std::string& value);
  inline void set_column_offset(const char* value);
  inline void set_column_offset(const void* value, size_t size);
  inline ::std::string* mutable_column_offset();
  inline ::std::string* release_column_offset();
  inline void set_allocated_column_offset(::std::string* column_offset);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnPaginationFilter)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_column_offset();
  inline void clear_has_column_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 offset_;
  ::std::string* column_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static ColumnPaginationFilter* default_instance_;
};
// -------------------------------------------------------------------

class ColumnPrefixFilter : public ::google::protobuf::Message {
 public:
  ColumnPrefixFilter();
  virtual ~ColumnPrefixFilter();

  ColumnPrefixFilter(const ColumnPrefixFilter& from);

  inline ColumnPrefixFilter& operator=(const ColumnPrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnPrefixFilter& default_instance();

  void Swap(ColumnPrefixFilter* other);

  // implements Message ----------------------------------------------

  ColumnPrefixFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnPrefixFilter& from);
  void MergeFrom(const ColumnPrefixFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const void* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnPrefixFilter)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static ColumnPrefixFilter* default_instance_;
};
// -------------------------------------------------------------------

class ColumnRangeFilter : public ::google::protobuf::Message {
 public:
  ColumnRangeFilter();
  virtual ~ColumnRangeFilter();

  ColumnRangeFilter(const ColumnRangeFilter& from);

  inline ColumnRangeFilter& operator=(const ColumnRangeFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnRangeFilter& default_instance();

  void Swap(ColumnRangeFilter* other);

  // implements Message ----------------------------------------------

  ColumnRangeFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnRangeFilter& from);
  void MergeFrom(const ColumnRangeFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes min_column = 1;
  inline bool has_min_column() const;
  inline void clear_min_column();
  static const int kMinColumnFieldNumber = 1;
  inline const ::std::string& min_column() const;
  inline void set_min_column(const ::std::string& value);
  inline void set_min_column(const char* value);
  inline void set_min_column(const void* value, size_t size);
  inline ::std::string* mutable_min_column();
  inline ::std::string* release_min_column();
  inline void set_allocated_min_column(::std::string* min_column);

  // optional bool min_column_inclusive = 2;
  inline bool has_min_column_inclusive() const;
  inline void clear_min_column_inclusive();
  static const int kMinColumnInclusiveFieldNumber = 2;
  inline bool min_column_inclusive() const;
  inline void set_min_column_inclusive(bool value);

  // optional bytes max_column = 3;
  inline bool has_max_column() const;
  inline void clear_max_column();
  static const int kMaxColumnFieldNumber = 3;
  inline const ::std::string& max_column() const;
  inline void set_max_column(const ::std::string& value);
  inline void set_max_column(const char* value);
  inline void set_max_column(const void* value, size_t size);
  inline ::std::string* mutable_max_column();
  inline ::std::string* release_max_column();
  inline void set_allocated_max_column(::std::string* max_column);

  // optional bool max_column_inclusive = 4;
  inline bool has_max_column_inclusive() const;
  inline void clear_max_column_inclusive();
  static const int kMaxColumnInclusiveFieldNumber = 4;
  inline bool max_column_inclusive() const;
  inline void set_max_column_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnRangeFilter)
 private:
  inline void set_has_min_column();
  inline void clear_has_min_column();
  inline void set_has_min_column_inclusive();
  inline void clear_has_min_column_inclusive();
  inline void set_has_max_column();
  inline void clear_has_max_column();
  inline void set_has_max_column_inclusive();
  inline void clear_has_max_column_inclusive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* min_column_;
  ::std::string* max_column_;
  bool min_column_inclusive_;
  bool max_column_inclusive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static ColumnRangeFilter* default_instance_;
};
// -------------------------------------------------------------------

class CompareFilter : public ::google::protobuf::Message {
 public:
  CompareFilter();
  virtual ~CompareFilter();

  CompareFilter(const CompareFilter& from);

  inline CompareFilter& operator=(const CompareFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompareFilter& default_instance();

  void Swap(CompareFilter* other);

  // implements Message ----------------------------------------------

  CompareFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompareFilter& from);
  void MergeFrom(const CompareFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareType compare_op = 1;
  inline bool has_compare_op() const;
  inline void clear_compare_op();
  static const int kCompareOpFieldNumber = 1;
  inline ::hbase::pb::CompareType compare_op() const;
  inline void set_compare_op(::hbase::pb::CompareType value);

  // optional .hbase.pb.Comparator comparator = 2;
  inline bool has_comparator() const;
  inline void clear_comparator();
  static const int kComparatorFieldNumber = 2;
  inline const ::hbase::pb::Comparator& comparator() const;
  inline ::hbase::pb::Comparator* mutable_comparator();
  inline ::hbase::pb::Comparator* release_comparator();
  inline void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // @@protoc_insertion_point(class_scope:hbase.pb.CompareFilter)
 private:
  inline void set_has_compare_op();
  inline void clear_has_compare_op();
  inline void set_has_comparator();
  inline void clear_has_comparator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Comparator* comparator_;
  int compare_op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static CompareFilter* default_instance_;
};
// -------------------------------------------------------------------

class DependentColumnFilter : public ::google::protobuf::Message {
 public:
  DependentColumnFilter();
  virtual ~DependentColumnFilter();

  DependentColumnFilter(const DependentColumnFilter& from);

  inline DependentColumnFilter& operator=(const DependentColumnFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DependentColumnFilter& default_instance();

  void Swap(DependentColumnFilter* other);

  // implements Message ----------------------------------------------

  DependentColumnFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DependentColumnFilter& from);
  void MergeFrom(const DependentColumnFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareFilter compare_filter = 1;
  inline bool has_compare_filter() const;
  inline void clear_compare_filter();
  static const int kCompareFilterFieldNumber = 1;
  inline const ::hbase::pb::CompareFilter& compare_filter() const;
  inline ::hbase::pb::CompareFilter* mutable_compare_filter();
  inline ::hbase::pb::CompareFilter* release_compare_filter();
  inline void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // optional bytes column_family = 2;
  inline bool has_column_family() const;
  inline void clear_column_family();
  static const int kColumnFamilyFieldNumber = 2;
  inline const ::std::string& column_family() const;
  inline void set_column_family(const ::std::string& value);
  inline void set_column_family(const char* value);
  inline void set_column_family(const void* value, size_t size);
  inline ::std::string* mutable_column_family();
  inline ::std::string* release_column_family();
  inline void set_allocated_column_family(::std::string* column_family);

  // optional bytes column_qualifier = 3;
  inline bool has_column_qualifier() const;
  inline void clear_column_qualifier();
  static const int kColumnQualifierFieldNumber = 3;
  inline const ::std::string& column_qualifier() const;
  inline void set_column_qualifier(const ::std::string& value);
  inline void set_column_qualifier(const char* value);
  inline void set_column_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_column_qualifier();
  inline ::std::string* release_column_qualifier();
  inline void set_allocated_column_qualifier(::std::string* column_qualifier);

  // optional bool drop_dependent_column = 4;
  inline bool has_drop_dependent_column() const;
  inline void clear_drop_dependent_column();
  static const int kDropDependentColumnFieldNumber = 4;
  inline bool drop_dependent_column() const;
  inline void set_drop_dependent_column(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DependentColumnFilter)
 private:
  inline void set_has_compare_filter();
  inline void clear_has_compare_filter();
  inline void set_has_column_family();
  inline void clear_has_column_family();
  inline void set_has_column_qualifier();
  inline void clear_has_column_qualifier();
  inline void set_has_drop_dependent_column();
  inline void clear_has_drop_dependent_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::CompareFilter* compare_filter_;
  ::std::string* column_family_;
  ::std::string* column_qualifier_;
  bool drop_dependent_column_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static DependentColumnFilter* default_instance_;
};
// -------------------------------------------------------------------

class FamilyFilter : public ::google::protobuf::Message {
 public:
  FamilyFilter();
  virtual ~FamilyFilter();

  FamilyFilter(const FamilyFilter& from);

  inline FamilyFilter& operator=(const FamilyFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FamilyFilter& default_instance();

  void Swap(FamilyFilter* other);

  // implements Message ----------------------------------------------

  FamilyFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FamilyFilter& from);
  void MergeFrom(const FamilyFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareFilter compare_filter = 1;
  inline bool has_compare_filter() const;
  inline void clear_compare_filter();
  static const int kCompareFilterFieldNumber = 1;
  inline const ::hbase::pb::CompareFilter& compare_filter() const;
  inline ::hbase::pb::CompareFilter* mutable_compare_filter();
  inline ::hbase::pb::CompareFilter* release_compare_filter();
  inline void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.FamilyFilter)
 private:
  inline void set_has_compare_filter();
  inline void clear_has_compare_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::CompareFilter* compare_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FamilyFilter* default_instance_;
};
// -------------------------------------------------------------------

class FilterList : public ::google::protobuf::Message {
 public:
  FilterList();
  virtual ~FilterList();

  FilterList(const FilterList& from);

  inline FilterList& operator=(const FilterList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterList& default_instance();

  void Swap(FilterList* other);

  // implements Message ----------------------------------------------

  FilterList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterList& from);
  void MergeFrom(const FilterList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FilterList_Operator Operator;
  static const Operator MUST_PASS_ALL = FilterList_Operator_MUST_PASS_ALL;
  static const Operator MUST_PASS_ONE = FilterList_Operator_MUST_PASS_ONE;
  static inline bool Operator_IsValid(int value) {
    return FilterList_Operator_IsValid(value);
  }
  static const Operator Operator_MIN =
    FilterList_Operator_Operator_MIN;
  static const Operator Operator_MAX =
    FilterList_Operator_Operator_MAX;
  static const int Operator_ARRAYSIZE =
    FilterList_Operator_Operator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operator_descriptor() {
    return FilterList_Operator_descriptor();
  }
  static inline const ::std::string& Operator_Name(Operator value) {
    return FilterList_Operator_Name(value);
  }
  static inline bool Operator_Parse(const ::std::string& name,
      Operator* value) {
    return FilterList_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.FilterList.Operator operator = 1;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 1;
  inline ::hbase::pb::FilterList_Operator operator_() const;
  inline void set_operator_(::hbase::pb::FilterList_Operator value);

  // repeated .hbase.pb.Filter filters = 2;
  inline int filters_size() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 2;
  inline const ::hbase::pb::Filter& filters(int index) const;
  inline ::hbase::pb::Filter* mutable_filters(int index);
  inline ::hbase::pb::Filter* add_filters();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Filter >&
      filters() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Filter >*
      mutable_filters();

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterList)
 private:
  inline void set_has_operator_();
  inline void clear_has_operator_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Filter > filters_;
  int operator__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FilterList* default_instance_;
};
// -------------------------------------------------------------------

class FilterWrapper : public ::google::protobuf::Message {
 public:
  FilterWrapper();
  virtual ~FilterWrapper();

  FilterWrapper(const FilterWrapper& from);

  inline FilterWrapper& operator=(const FilterWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterWrapper& default_instance();

  void Swap(FilterWrapper* other);

  // implements Message ----------------------------------------------

  FilterWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterWrapper& from);
  void MergeFrom(const FilterWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.Filter filter = 1;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 1;
  inline const ::hbase::pb::Filter& filter() const;
  inline ::hbase::pb::Filter* mutable_filter();
  inline ::hbase::pb::Filter* release_filter();
  inline void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterWrapper)
 private:
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Filter* filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FilterWrapper* default_instance_;
};
// -------------------------------------------------------------------

class FirstKeyOnlyFilter : public ::google::protobuf::Message {
 public:
  FirstKeyOnlyFilter();
  virtual ~FirstKeyOnlyFilter();

  FirstKeyOnlyFilter(const FirstKeyOnlyFilter& from);

  inline FirstKeyOnlyFilter& operator=(const FirstKeyOnlyFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirstKeyOnlyFilter& default_instance();

  void Swap(FirstKeyOnlyFilter* other);

  // implements Message ----------------------------------------------

  FirstKeyOnlyFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FirstKeyOnlyFilter& from);
  void MergeFrom(const FirstKeyOnlyFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.FirstKeyOnlyFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FirstKeyOnlyFilter* default_instance_;
};
// -------------------------------------------------------------------

class FirstKeyValueMatchingQualifiersFilter : public ::google::protobuf::Message {
 public:
  FirstKeyValueMatchingQualifiersFilter();
  virtual ~FirstKeyValueMatchingQualifiersFilter();

  FirstKeyValueMatchingQualifiersFilter(const FirstKeyValueMatchingQualifiersFilter& from);

  inline FirstKeyValueMatchingQualifiersFilter& operator=(const FirstKeyValueMatchingQualifiersFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirstKeyValueMatchingQualifiersFilter& default_instance();

  void Swap(FirstKeyValueMatchingQualifiersFilter* other);

  // implements Message ----------------------------------------------

  FirstKeyValueMatchingQualifiersFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FirstKeyValueMatchingQualifiersFilter& from);
  void MergeFrom(const FirstKeyValueMatchingQualifiersFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes qualifiers = 1;
  inline int qualifiers_size() const;
  inline void clear_qualifiers();
  static const int kQualifiersFieldNumber = 1;
  inline const ::std::string& qualifiers(int index) const;
  inline ::std::string* mutable_qualifiers(int index);
  inline void set_qualifiers(int index, const ::std::string& value);
  inline void set_qualifiers(int index, const char* value);
  inline void set_qualifiers(int index, const void* value, size_t size);
  inline ::std::string* add_qualifiers();
  inline void add_qualifiers(const ::std::string& value);
  inline void add_qualifiers(const char* value);
  inline void add_qualifiers(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& qualifiers() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_qualifiers();

  // @@protoc_insertion_point(class_scope:hbase.pb.FirstKeyValueMatchingQualifiersFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> qualifiers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FirstKeyValueMatchingQualifiersFilter* default_instance_;
};
// -------------------------------------------------------------------

class FuzzyRowFilter : public ::google::protobuf::Message {
 public:
  FuzzyRowFilter();
  virtual ~FuzzyRowFilter();

  FuzzyRowFilter(const FuzzyRowFilter& from);

  inline FuzzyRowFilter& operator=(const FuzzyRowFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuzzyRowFilter& default_instance();

  void Swap(FuzzyRowFilter* other);

  // implements Message ----------------------------------------------

  FuzzyRowFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuzzyRowFilter& from);
  void MergeFrom(const FuzzyRowFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
  inline int fuzzy_keys_data_size() const;
  inline void clear_fuzzy_keys_data();
  static const int kFuzzyKeysDataFieldNumber = 1;
  inline const ::hbase::pb::BytesBytesPair& fuzzy_keys_data(int index) const;
  inline ::hbase::pb::BytesBytesPair* mutable_fuzzy_keys_data(int index);
  inline ::hbase::pb::BytesBytesPair* add_fuzzy_keys_data();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      fuzzy_keys_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_fuzzy_keys_data();

  // @@protoc_insertion_point(class_scope:hbase.pb.FuzzyRowFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair > fuzzy_keys_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FuzzyRowFilter* default_instance_;
};
// -------------------------------------------------------------------

class InclusiveStopFilter : public ::google::protobuf::Message {
 public:
  InclusiveStopFilter();
  virtual ~InclusiveStopFilter();

  InclusiveStopFilter(const InclusiveStopFilter& from);

  inline InclusiveStopFilter& operator=(const InclusiveStopFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InclusiveStopFilter& default_instance();

  void Swap(InclusiveStopFilter* other);

  // implements Message ----------------------------------------------

  InclusiveStopFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InclusiveStopFilter& from);
  void MergeFrom(const InclusiveStopFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes stop_row_key = 1;
  inline bool has_stop_row_key() const;
  inline void clear_stop_row_key();
  static const int kStopRowKeyFieldNumber = 1;
  inline const ::std::string& stop_row_key() const;
  inline void set_stop_row_key(const ::std::string& value);
  inline void set_stop_row_key(const char* value);
  inline void set_stop_row_key(const void* value, size_t size);
  inline ::std::string* mutable_stop_row_key();
  inline ::std::string* release_stop_row_key();
  inline void set_allocated_stop_row_key(::std::string* stop_row_key);

  // @@protoc_insertion_point(class_scope:hbase.pb.InclusiveStopFilter)
 private:
  inline void set_has_stop_row_key();
  inline void clear_has_stop_row_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stop_row_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static InclusiveStopFilter* default_instance_;
};
// -------------------------------------------------------------------

class KeyOnlyFilter : public ::google::protobuf::Message {
 public:
  KeyOnlyFilter();
  virtual ~KeyOnlyFilter();

  KeyOnlyFilter(const KeyOnlyFilter& from);

  inline KeyOnlyFilter& operator=(const KeyOnlyFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyOnlyFilter& default_instance();

  void Swap(KeyOnlyFilter* other);

  // implements Message ----------------------------------------------

  KeyOnlyFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyOnlyFilter& from);
  void MergeFrom(const KeyOnlyFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool len_as_val = 1;
  inline bool has_len_as_val() const;
  inline void clear_len_as_val();
  static const int kLenAsValFieldNumber = 1;
  inline bool len_as_val() const;
  inline void set_len_as_val(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.KeyOnlyFilter)
 private:
  inline void set_has_len_as_val();
  inline void clear_has_len_as_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool len_as_val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static KeyOnlyFilter* default_instance_;
};
// -------------------------------------------------------------------

class MultipleColumnPrefixFilter : public ::google::protobuf::Message {
 public:
  MultipleColumnPrefixFilter();
  virtual ~MultipleColumnPrefixFilter();

  MultipleColumnPrefixFilter(const MultipleColumnPrefixFilter& from);

  inline MultipleColumnPrefixFilter& operator=(const MultipleColumnPrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultipleColumnPrefixFilter& default_instance();

  void Swap(MultipleColumnPrefixFilter* other);

  // implements Message ----------------------------------------------

  MultipleColumnPrefixFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultipleColumnPrefixFilter& from);
  void MergeFrom(const MultipleColumnPrefixFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes sorted_prefixes = 1;
  inline int sorted_prefixes_size() const;
  inline void clear_sorted_prefixes();
  static const int kSortedPrefixesFieldNumber = 1;
  inline const ::std::string& sorted_prefixes(int index) const;
  inline ::std::string* mutable_sorted_prefixes(int index);
  inline void set_sorted_prefixes(int index, const ::std::string& value);
  inline void set_sorted_prefixes(int index, const char* value);
  inline void set_sorted_prefixes(int index, const void* value, size_t size);
  inline ::std::string* add_sorted_prefixes();
  inline void add_sorted_prefixes(const ::std::string& value);
  inline void add_sorted_prefixes(const char* value);
  inline void add_sorted_prefixes(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sorted_prefixes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sorted_prefixes();

  // @@protoc_insertion_point(class_scope:hbase.pb.MultipleColumnPrefixFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> sorted_prefixes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static MultipleColumnPrefixFilter* default_instance_;
};
// -------------------------------------------------------------------

class PageFilter : public ::google::protobuf::Message {
 public:
  PageFilter();
  virtual ~PageFilter();

  PageFilter(const PageFilter& from);

  inline PageFilter& operator=(const PageFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PageFilter& default_instance();

  void Swap(PageFilter* other);

  // implements Message ----------------------------------------------

  PageFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PageFilter& from);
  void MergeFrom(const PageFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 page_size = 1;
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 1;
  inline ::google::protobuf::int64 page_size() const;
  inline void set_page_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.PageFilter)
 private:
  inline void set_has_page_size();
  inline void clear_has_page_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 page_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static PageFilter* default_instance_;
};
// -------------------------------------------------------------------

class PrefixFilter : public ::google::protobuf::Message {
 public:
  PrefixFilter();
  virtual ~PrefixFilter();

  PrefixFilter(const PrefixFilter& from);

  inline PrefixFilter& operator=(const PrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrefixFilter& default_instance();

  void Swap(PrefixFilter* other);

  // implements Message ----------------------------------------------

  PrefixFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrefixFilter& from);
  void MergeFrom(const PrefixFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const void* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrefixFilter)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static PrefixFilter* default_instance_;
};
// -------------------------------------------------------------------

class QualifierFilter : public ::google::protobuf::Message {
 public:
  QualifierFilter();
  virtual ~QualifierFilter();

  QualifierFilter(const QualifierFilter& from);

  inline QualifierFilter& operator=(const QualifierFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QualifierFilter& default_instance();

  void Swap(QualifierFilter* other);

  // implements Message ----------------------------------------------

  QualifierFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QualifierFilter& from);
  void MergeFrom(const QualifierFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareFilter compare_filter = 1;
  inline bool has_compare_filter() const;
  inline void clear_compare_filter();
  static const int kCompareFilterFieldNumber = 1;
  inline const ::hbase::pb::CompareFilter& compare_filter() const;
  inline ::hbase::pb::CompareFilter* mutable_compare_filter();
  inline ::hbase::pb::CompareFilter* release_compare_filter();
  inline void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.QualifierFilter)
 private:
  inline void set_has_compare_filter();
  inline void clear_has_compare_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::CompareFilter* compare_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static QualifierFilter* default_instance_;
};
// -------------------------------------------------------------------

class RandomRowFilter : public ::google::protobuf::Message {
 public:
  RandomRowFilter();
  virtual ~RandomRowFilter();

  RandomRowFilter(const RandomRowFilter& from);

  inline RandomRowFilter& operator=(const RandomRowFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomRowFilter& default_instance();

  void Swap(RandomRowFilter* other);

  // implements Message ----------------------------------------------

  RandomRowFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RandomRowFilter& from);
  void MergeFrom(const RandomRowFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float chance = 1;
  inline bool has_chance() const;
  inline void clear_chance();
  static const int kChanceFieldNumber = 1;
  inline float chance() const;
  inline void set_chance(float value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RandomRowFilter)
 private:
  inline void set_has_chance();
  inline void clear_has_chance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float chance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static RandomRowFilter* default_instance_;
};
// -------------------------------------------------------------------

class RowFilter : public ::google::protobuf::Message {
 public:
  RowFilter();
  virtual ~RowFilter();

  RowFilter(const RowFilter& from);

  inline RowFilter& operator=(const RowFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RowFilter& default_instance();

  void Swap(RowFilter* other);

  // implements Message ----------------------------------------------

  RowFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RowFilter& from);
  void MergeFrom(const RowFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareFilter compare_filter = 1;
  inline bool has_compare_filter() const;
  inline void clear_compare_filter();
  static const int kCompareFilterFieldNumber = 1;
  inline const ::hbase::pb::CompareFilter& compare_filter() const;
  inline ::hbase::pb::CompareFilter* mutable_compare_filter();
  inline ::hbase::pb::CompareFilter* release_compare_filter();
  inline void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.RowFilter)
 private:
  inline void set_has_compare_filter();
  inline void clear_has_compare_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::CompareFilter* compare_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static RowFilter* default_instance_;
};
// -------------------------------------------------------------------

class SingleColumnValueExcludeFilter : public ::google::protobuf::Message {
 public:
  SingleColumnValueExcludeFilter();
  virtual ~SingleColumnValueExcludeFilter();

  SingleColumnValueExcludeFilter(const SingleColumnValueExcludeFilter& from);

  inline SingleColumnValueExcludeFilter& operator=(const SingleColumnValueExcludeFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleColumnValueExcludeFilter& default_instance();

  void Swap(SingleColumnValueExcludeFilter* other);

  // implements Message ----------------------------------------------

  SingleColumnValueExcludeFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleColumnValueExcludeFilter& from);
  void MergeFrom(const SingleColumnValueExcludeFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
  inline bool has_single_column_value_filter() const;
  inline void clear_single_column_value_filter();
  static const int kSingleColumnValueFilterFieldNumber = 1;
  inline const ::hbase::pb::SingleColumnValueFilter& single_column_value_filter() const;
  inline ::hbase::pb::SingleColumnValueFilter* mutable_single_column_value_filter();
  inline ::hbase::pb::SingleColumnValueFilter* release_single_column_value_filter();
  inline void set_allocated_single_column_value_filter(::hbase::pb::SingleColumnValueFilter* single_column_value_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.SingleColumnValueExcludeFilter)
 private:
  inline void set_has_single_column_value_filter();
  inline void clear_has_single_column_value_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::SingleColumnValueFilter* single_column_value_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static SingleColumnValueExcludeFilter* default_instance_;
};
// -------------------------------------------------------------------

class SingleColumnValueFilter : public ::google::protobuf::Message {
 public:
  SingleColumnValueFilter();
  virtual ~SingleColumnValueFilter();

  SingleColumnValueFilter(const SingleColumnValueFilter& from);

  inline SingleColumnValueFilter& operator=(const SingleColumnValueFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleColumnValueFilter& default_instance();

  void Swap(SingleColumnValueFilter* other);

  // implements Message ----------------------------------------------

  SingleColumnValueFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleColumnValueFilter& from);
  void MergeFrom(const SingleColumnValueFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes column_family = 1;
  inline bool has_column_family() const;
  inline void clear_column_family();
  static const int kColumnFamilyFieldNumber = 1;
  inline const ::std::string& column_family() const;
  inline void set_column_family(const ::std::string& value);
  inline void set_column_family(const char* value);
  inline void set_column_family(const void* value, size_t size);
  inline ::std::string* mutable_column_family();
  inline ::std::string* release_column_family();
  inline void set_allocated_column_family(::std::string* column_family);

  // optional bytes column_qualifier = 2;
  inline bool has_column_qualifier() const;
  inline void clear_column_qualifier();
  static const int kColumnQualifierFieldNumber = 2;
  inline const ::std::string& column_qualifier() const;
  inline void set_column_qualifier(const ::std::string& value);
  inline void set_column_qualifier(const char* value);
  inline void set_column_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_column_qualifier();
  inline ::std::string* release_column_qualifier();
  inline void set_allocated_column_qualifier(::std::string* column_qualifier);

  // required .hbase.pb.CompareType compare_op = 3;
  inline bool has_compare_op() const;
  inline void clear_compare_op();
  static const int kCompareOpFieldNumber = 3;
  inline ::hbase::pb::CompareType compare_op() const;
  inline void set_compare_op(::hbase::pb::CompareType value);

  // required .hbase.pb.Comparator comparator = 4;
  inline bool has_comparator() const;
  inline void clear_comparator();
  static const int kComparatorFieldNumber = 4;
  inline const ::hbase::pb::Comparator& comparator() const;
  inline ::hbase::pb::Comparator* mutable_comparator();
  inline ::hbase::pb::Comparator* release_comparator();
  inline void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // optional bool filter_if_missing = 5;
  inline bool has_filter_if_missing() const;
  inline void clear_filter_if_missing();
  static const int kFilterIfMissingFieldNumber = 5;
  inline bool filter_if_missing() const;
  inline void set_filter_if_missing(bool value);

  // optional bool latest_version_only = 6;
  inline bool has_latest_version_only() const;
  inline void clear_latest_version_only();
  static const int kLatestVersionOnlyFieldNumber = 6;
  inline bool latest_version_only() const;
  inline void set_latest_version_only(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SingleColumnValueFilter)
 private:
  inline void set_has_column_family();
  inline void clear_has_column_family();
  inline void set_has_column_qualifier();
  inline void clear_has_column_qualifier();
  inline void set_has_compare_op();
  inline void clear_has_compare_op();
  inline void set_has_comparator();
  inline void clear_has_comparator();
  inline void set_has_filter_if_missing();
  inline void clear_has_filter_if_missing();
  inline void set_has_latest_version_only();
  inline void clear_has_latest_version_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* column_family_;
  ::std::string* column_qualifier_;
  ::hbase::pb::Comparator* comparator_;
  int compare_op_;
  bool filter_if_missing_;
  bool latest_version_only_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static SingleColumnValueFilter* default_instance_;
};
// -------------------------------------------------------------------

class SkipFilter : public ::google::protobuf::Message {
 public:
  SkipFilter();
  virtual ~SkipFilter();

  SkipFilter(const SkipFilter& from);

  inline SkipFilter& operator=(const SkipFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkipFilter& default_instance();

  void Swap(SkipFilter* other);

  // implements Message ----------------------------------------------

  SkipFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkipFilter& from);
  void MergeFrom(const SkipFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.Filter filter = 1;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 1;
  inline const ::hbase::pb::Filter& filter() const;
  inline ::hbase::pb::Filter* mutable_filter();
  inline ::hbase::pb::Filter* release_filter();
  inline void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.SkipFilter)
 private:
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Filter* filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static SkipFilter* default_instance_;
};
// -------------------------------------------------------------------

class TimestampsFilter : public ::google::protobuf::Message {
 public:
  TimestampsFilter();
  virtual ~TimestampsFilter();

  TimestampsFilter(const TimestampsFilter& from);

  inline TimestampsFilter& operator=(const TimestampsFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimestampsFilter& default_instance();

  void Swap(TimestampsFilter* other);

  // implements Message ----------------------------------------------

  TimestampsFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimestampsFilter& from);
  void MergeFrom(const TimestampsFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 timestamps = 1 [packed = true];
  inline int timestamps_size() const;
  inline void clear_timestamps();
  static const int kTimestampsFieldNumber = 1;
  inline ::google::protobuf::int64 timestamps(int index) const;
  inline void set_timestamps(int index, ::google::protobuf::int64 value);
  inline void add_timestamps(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      timestamps() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_timestamps();

  // @@protoc_insertion_point(class_scope:hbase.pb.TimestampsFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > timestamps_;
  mutable int _timestamps_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static TimestampsFilter* default_instance_;
};
// -------------------------------------------------------------------

class ValueFilter : public ::google::protobuf::Message {
 public:
  ValueFilter();
  virtual ~ValueFilter();

  ValueFilter(const ValueFilter& from);

  inline ValueFilter& operator=(const ValueFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueFilter& default_instance();

  void Swap(ValueFilter* other);

  // implements Message ----------------------------------------------

  ValueFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValueFilter& from);
  void MergeFrom(const ValueFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.CompareFilter compare_filter = 1;
  inline bool has_compare_filter() const;
  inline void clear_compare_filter();
  static const int kCompareFilterFieldNumber = 1;
  inline const ::hbase::pb::CompareFilter& compare_filter() const;
  inline ::hbase::pb::CompareFilter* mutable_compare_filter();
  inline ::hbase::pb::CompareFilter* release_compare_filter();
  inline void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.ValueFilter)
 private:
  inline void set_has_compare_filter();
  inline void clear_has_compare_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::CompareFilter* compare_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static ValueFilter* default_instance_;
};
// -------------------------------------------------------------------

class WhileMatchFilter : public ::google::protobuf::Message {
 public:
  WhileMatchFilter();
  virtual ~WhileMatchFilter();

  WhileMatchFilter(const WhileMatchFilter& from);

  inline WhileMatchFilter& operator=(const WhileMatchFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WhileMatchFilter& default_instance();

  void Swap(WhileMatchFilter* other);

  // implements Message ----------------------------------------------

  WhileMatchFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WhileMatchFilter& from);
  void MergeFrom(const WhileMatchFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.Filter filter = 1;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 1;
  inline const ::hbase::pb::Filter& filter() const;
  inline ::hbase::pb::Filter* mutable_filter();
  inline ::hbase::pb::Filter* release_filter();
  inline void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.WhileMatchFilter)
 private:
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Filter* filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static WhileMatchFilter* default_instance_;
};
// -------------------------------------------------------------------

class FilterAllFilter : public ::google::protobuf::Message {
 public:
  FilterAllFilter();
  virtual ~FilterAllFilter();

  FilterAllFilter(const FilterAllFilter& from);

  inline FilterAllFilter& operator=(const FilterAllFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterAllFilter& default_instance();

  void Swap(FilterAllFilter* other);

  // implements Message ----------------------------------------------

  FilterAllFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterAllFilter& from);
  void MergeFrom(const FilterAllFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterAllFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static FilterAllFilter* default_instance_;
};
// -------------------------------------------------------------------

class RowRange : public ::google::protobuf::Message {
 public:
  RowRange();
  virtual ~RowRange();

  RowRange(const RowRange& from);

  inline RowRange& operator=(const RowRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RowRange& default_instance();

  void Swap(RowRange* other);

  // implements Message ----------------------------------------------

  RowRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RowRange& from);
  void MergeFrom(const RowRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_row = 1;
  inline bool has_start_row() const;
  inline void clear_start_row();
  static const int kStartRowFieldNumber = 1;
  inline const ::std::string& start_row() const;
  inline void set_start_row(const ::std::string& value);
  inline void set_start_row(const char* value);
  inline void set_start_row(const void* value, size_t size);
  inline ::std::string* mutable_start_row();
  inline ::std::string* release_start_row();
  inline void set_allocated_start_row(::std::string* start_row);

  // optional bool start_row_inclusive = 2;
  inline bool has_start_row_inclusive() const;
  inline void clear_start_row_inclusive();
  static const int kStartRowInclusiveFieldNumber = 2;
  inline bool start_row_inclusive() const;
  inline void set_start_row_inclusive(bool value);

  // optional bytes stop_row = 3;
  inline bool has_stop_row() const;
  inline void clear_stop_row();
  static const int kStopRowFieldNumber = 3;
  inline const ::std::string& stop_row() const;
  inline void set_stop_row(const ::std::string& value);
  inline void set_stop_row(const char* value);
  inline void set_stop_row(const void* value, size_t size);
  inline ::std::string* mutable_stop_row();
  inline ::std::string* release_stop_row();
  inline void set_allocated_stop_row(::std::string* stop_row);

  // optional bool stop_row_inclusive = 4;
  inline bool has_stop_row_inclusive() const;
  inline void clear_stop_row_inclusive();
  static const int kStopRowInclusiveFieldNumber = 4;
  inline bool stop_row_inclusive() const;
  inline void set_stop_row_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RowRange)
 private:
  inline void set_has_start_row();
  inline void clear_has_start_row();
  inline void set_has_start_row_inclusive();
  inline void clear_has_start_row_inclusive();
  inline void set_has_stop_row();
  inline void clear_has_stop_row();
  inline void set_has_stop_row_inclusive();
  inline void clear_has_stop_row_inclusive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* start_row_;
  ::std::string* stop_row_;
  bool start_row_inclusive_;
  bool stop_row_inclusive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static RowRange* default_instance_;
};
// -------------------------------------------------------------------

class MultiRowRangeFilter : public ::google::protobuf::Message {
 public:
  MultiRowRangeFilter();
  virtual ~MultiRowRangeFilter();

  MultiRowRangeFilter(const MultiRowRangeFilter& from);

  inline MultiRowRangeFilter& operator=(const MultiRowRangeFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiRowRangeFilter& default_instance();

  void Swap(MultiRowRangeFilter* other);

  // implements Message ----------------------------------------------

  MultiRowRangeFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiRowRangeFilter& from);
  void MergeFrom(const MultiRowRangeFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.RowRange row_range_list = 1;
  inline int row_range_list_size() const;
  inline void clear_row_range_list();
  static const int kRowRangeListFieldNumber = 1;
  inline const ::hbase::pb::RowRange& row_range_list(int index) const;
  inline ::hbase::pb::RowRange* mutable_row_range_list(int index);
  inline ::hbase::pb::RowRange* add_row_range_list();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RowRange >&
      row_range_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RowRange >*
      mutable_row_range_list();

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRowRangeFilter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RowRange > row_range_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Filter_2eproto();
  friend void protobuf_AssignDesc_Filter_2eproto();
  friend void protobuf_ShutdownFile_Filter_2eproto();

  void InitAsDefaultInstance();
  static MultiRowRangeFilter* default_instance_;
};
// ===================================================================


// ===================================================================

// Filter

// required string name = 1;
inline bool Filter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Filter::name() const {
  return *name_;
}
inline void Filter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Filter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Filter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Filter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Filter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Filter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes serialized_filter = 2;
inline bool Filter::has_serialized_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Filter::set_has_serialized_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Filter::clear_has_serialized_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Filter::clear_serialized_filter() {
  if (serialized_filter_ != &::google::protobuf::internal::kEmptyString) {
    serialized_filter_->clear();
  }
  clear_has_serialized_filter();
}
inline const ::std::string& Filter::serialized_filter() const {
  return *serialized_filter_;
}
inline void Filter::set_serialized_filter(const ::std::string& value) {
  set_has_serialized_filter();
  if (serialized_filter_ == &::google::protobuf::internal::kEmptyString) {
    serialized_filter_ = new ::std::string;
  }
  serialized_filter_->assign(value);
}
inline void Filter::set_serialized_filter(const char* value) {
  set_has_serialized_filter();
  if (serialized_filter_ == &::google::protobuf::internal::kEmptyString) {
    serialized_filter_ = new ::std::string;
  }
  serialized_filter_->assign(value);
}
inline void Filter::set_serialized_filter(const void* value, size_t size) {
  set_has_serialized_filter();
  if (serialized_filter_ == &::google::protobuf::internal::kEmptyString) {
    serialized_filter_ = new ::std::string;
  }
  serialized_filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Filter::mutable_serialized_filter() {
  set_has_serialized_filter();
  if (serialized_filter_ == &::google::protobuf::internal::kEmptyString) {
    serialized_filter_ = new ::std::string;
  }
  return serialized_filter_;
}
inline ::std::string* Filter::release_serialized_filter() {
  clear_has_serialized_filter();
  if (serialized_filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_filter_;
    serialized_filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Filter::set_allocated_serialized_filter(::std::string* serialized_filter) {
  if (serialized_filter_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_filter_;
  }
  if (serialized_filter) {
    set_has_serialized_filter();
    serialized_filter_ = serialized_filter;
  } else {
    clear_has_serialized_filter();
    serialized_filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ColumnCountGetFilter

// required int32 limit = 1;
inline bool ColumnCountGetFilter::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnCountGetFilter::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnCountGetFilter::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnCountGetFilter::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ColumnCountGetFilter::limit() const {
  return limit_;
}
inline void ColumnCountGetFilter::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// ColumnPaginationFilter

// required int32 limit = 1;
inline bool ColumnPaginationFilter::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnPaginationFilter::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnPaginationFilter::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnPaginationFilter::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ColumnPaginationFilter::limit() const {
  return limit_;
}
inline void ColumnPaginationFilter::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 offset = 2;
inline bool ColumnPaginationFilter::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnPaginationFilter::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnPaginationFilter::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnPaginationFilter::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 ColumnPaginationFilter::offset() const {
  return offset_;
}
inline void ColumnPaginationFilter::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes column_offset = 3;
inline bool ColumnPaginationFilter::has_column_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnPaginationFilter::set_has_column_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnPaginationFilter::clear_has_column_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnPaginationFilter::clear_column_offset() {
  if (column_offset_ != &::google::protobuf::internal::kEmptyString) {
    column_offset_->clear();
  }
  clear_has_column_offset();
}
inline const ::std::string& ColumnPaginationFilter::column_offset() const {
  return *column_offset_;
}
inline void ColumnPaginationFilter::set_column_offset(const ::std::string& value) {
  set_has_column_offset();
  if (column_offset_ == &::google::protobuf::internal::kEmptyString) {
    column_offset_ = new ::std::string;
  }
  column_offset_->assign(value);
}
inline void ColumnPaginationFilter::set_column_offset(const char* value) {
  set_has_column_offset();
  if (column_offset_ == &::google::protobuf::internal::kEmptyString) {
    column_offset_ = new ::std::string;
  }
  column_offset_->assign(value);
}
inline void ColumnPaginationFilter::set_column_offset(const void* value, size_t size) {
  set_has_column_offset();
  if (column_offset_ == &::google::protobuf::internal::kEmptyString) {
    column_offset_ = new ::std::string;
  }
  column_offset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnPaginationFilter::mutable_column_offset() {
  set_has_column_offset();
  if (column_offset_ == &::google::protobuf::internal::kEmptyString) {
    column_offset_ = new ::std::string;
  }
  return column_offset_;
}
inline ::std::string* ColumnPaginationFilter::release_column_offset() {
  clear_has_column_offset();
  if (column_offset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_offset_;
    column_offset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnPaginationFilter::set_allocated_column_offset(::std::string* column_offset) {
  if (column_offset_ != &::google::protobuf::internal::kEmptyString) {
    delete column_offset_;
  }
  if (column_offset) {
    set_has_column_offset();
    column_offset_ = column_offset;
  } else {
    clear_has_column_offset();
    column_offset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ColumnPrefixFilter

// required bytes prefix = 1;
inline bool ColumnPrefixFilter::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnPrefixFilter::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnPrefixFilter::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnPrefixFilter::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& ColumnPrefixFilter::prefix() const {
  return *prefix_;
}
inline void ColumnPrefixFilter::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void ColumnPrefixFilter::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void ColumnPrefixFilter::set_prefix(const void* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnPrefixFilter::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* ColumnPrefixFilter::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnPrefixFilter::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ColumnRangeFilter

// optional bytes min_column = 1;
inline bool ColumnRangeFilter::has_min_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnRangeFilter::set_has_min_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnRangeFilter::clear_has_min_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnRangeFilter::clear_min_column() {
  if (min_column_ != &::google::protobuf::internal::kEmptyString) {
    min_column_->clear();
  }
  clear_has_min_column();
}
inline const ::std::string& ColumnRangeFilter::min_column() const {
  return *min_column_;
}
inline void ColumnRangeFilter::set_min_column(const ::std::string& value) {
  set_has_min_column();
  if (min_column_ == &::google::protobuf::internal::kEmptyString) {
    min_column_ = new ::std::string;
  }
  min_column_->assign(value);
}
inline void ColumnRangeFilter::set_min_column(const char* value) {
  set_has_min_column();
  if (min_column_ == &::google::protobuf::internal::kEmptyString) {
    min_column_ = new ::std::string;
  }
  min_column_->assign(value);
}
inline void ColumnRangeFilter::set_min_column(const void* value, size_t size) {
  set_has_min_column();
  if (min_column_ == &::google::protobuf::internal::kEmptyString) {
    min_column_ = new ::std::string;
  }
  min_column_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnRangeFilter::mutable_min_column() {
  set_has_min_column();
  if (min_column_ == &::google::protobuf::internal::kEmptyString) {
    min_column_ = new ::std::string;
  }
  return min_column_;
}
inline ::std::string* ColumnRangeFilter::release_min_column() {
  clear_has_min_column();
  if (min_column_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = min_column_;
    min_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnRangeFilter::set_allocated_min_column(::std::string* min_column) {
  if (min_column_ != &::google::protobuf::internal::kEmptyString) {
    delete min_column_;
  }
  if (min_column) {
    set_has_min_column();
    min_column_ = min_column;
  } else {
    clear_has_min_column();
    min_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool min_column_inclusive = 2;
inline bool ColumnRangeFilter::has_min_column_inclusive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnRangeFilter::set_has_min_column_inclusive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnRangeFilter::clear_has_min_column_inclusive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnRangeFilter::clear_min_column_inclusive() {
  min_column_inclusive_ = false;
  clear_has_min_column_inclusive();
}
inline bool ColumnRangeFilter::min_column_inclusive() const {
  return min_column_inclusive_;
}
inline void ColumnRangeFilter::set_min_column_inclusive(bool value) {
  set_has_min_column_inclusive();
  min_column_inclusive_ = value;
}

// optional bytes max_column = 3;
inline bool ColumnRangeFilter::has_max_column() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnRangeFilter::set_has_max_column() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnRangeFilter::clear_has_max_column() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnRangeFilter::clear_max_column() {
  if (max_column_ != &::google::protobuf::internal::kEmptyString) {
    max_column_->clear();
  }
  clear_has_max_column();
}
inline const ::std::string& ColumnRangeFilter::max_column() const {
  return *max_column_;
}
inline void ColumnRangeFilter::set_max_column(const ::std::string& value) {
  set_has_max_column();
  if (max_column_ == &::google::protobuf::internal::kEmptyString) {
    max_column_ = new ::std::string;
  }
  max_column_->assign(value);
}
inline void ColumnRangeFilter::set_max_column(const char* value) {
  set_has_max_column();
  if (max_column_ == &::google::protobuf::internal::kEmptyString) {
    max_column_ = new ::std::string;
  }
  max_column_->assign(value);
}
inline void ColumnRangeFilter::set_max_column(const void* value, size_t size) {
  set_has_max_column();
  if (max_column_ == &::google::protobuf::internal::kEmptyString) {
    max_column_ = new ::std::string;
  }
  max_column_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnRangeFilter::mutable_max_column() {
  set_has_max_column();
  if (max_column_ == &::google::protobuf::internal::kEmptyString) {
    max_column_ = new ::std::string;
  }
  return max_column_;
}
inline ::std::string* ColumnRangeFilter::release_max_column() {
  clear_has_max_column();
  if (max_column_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = max_column_;
    max_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnRangeFilter::set_allocated_max_column(::std::string* max_column) {
  if (max_column_ != &::google::protobuf::internal::kEmptyString) {
    delete max_column_;
  }
  if (max_column) {
    set_has_max_column();
    max_column_ = max_column;
  } else {
    clear_has_max_column();
    max_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool max_column_inclusive = 4;
inline bool ColumnRangeFilter::has_max_column_inclusive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnRangeFilter::set_has_max_column_inclusive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnRangeFilter::clear_has_max_column_inclusive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnRangeFilter::clear_max_column_inclusive() {
  max_column_inclusive_ = false;
  clear_has_max_column_inclusive();
}
inline bool ColumnRangeFilter::max_column_inclusive() const {
  return max_column_inclusive_;
}
inline void ColumnRangeFilter::set_max_column_inclusive(bool value) {
  set_has_max_column_inclusive();
  max_column_inclusive_ = value;
}

// -------------------------------------------------------------------

// CompareFilter

// required .hbase.pb.CompareType compare_op = 1;
inline bool CompareFilter::has_compare_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompareFilter::set_has_compare_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompareFilter::clear_has_compare_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompareFilter::clear_compare_op() {
  compare_op_ = 0;
  clear_has_compare_op();
}
inline ::hbase::pb::CompareType CompareFilter::compare_op() const {
  return static_cast< ::hbase::pb::CompareType >(compare_op_);
}
inline void CompareFilter::set_compare_op(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  set_has_compare_op();
  compare_op_ = value;
}

// optional .hbase.pb.Comparator comparator = 2;
inline bool CompareFilter::has_comparator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompareFilter::set_has_comparator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompareFilter::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompareFilter::clear_comparator() {
  if (comparator_ != NULL) comparator_->::hbase::pb::Comparator::Clear();
  clear_has_comparator();
}
inline const ::hbase::pb::Comparator& CompareFilter::comparator() const {
  return comparator_ != NULL ? *comparator_ : *default_instance_->comparator_;
}
inline ::hbase::pb::Comparator* CompareFilter::mutable_comparator() {
  set_has_comparator();
  if (comparator_ == NULL) comparator_ = new ::hbase::pb::Comparator;
  return comparator_;
}
inline ::hbase::pb::Comparator* CompareFilter::release_comparator() {
  clear_has_comparator();
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = NULL;
  return temp;
}
inline void CompareFilter::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  delete comparator_;
  comparator_ = comparator;
  if (comparator) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
}

// -------------------------------------------------------------------

// DependentColumnFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool DependentColumnFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DependentColumnFilter::set_has_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DependentColumnFilter::clear_has_compare_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DependentColumnFilter::clear_compare_filter() {
  if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
  clear_has_compare_filter();
}
inline const ::hbase::pb::CompareFilter& DependentColumnFilter::compare_filter() const {
  return compare_filter_ != NULL ? *compare_filter_ : *default_instance_->compare_filter_;
}
inline ::hbase::pb::CompareFilter* DependentColumnFilter::mutable_compare_filter() {
  set_has_compare_filter();
  if (compare_filter_ == NULL) compare_filter_ = new ::hbase::pb::CompareFilter;
  return compare_filter_;
}
inline ::hbase::pb::CompareFilter* DependentColumnFilter::release_compare_filter() {
  clear_has_compare_filter();
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = NULL;
  return temp;
}
inline void DependentColumnFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  delete compare_filter_;
  compare_filter_ = compare_filter;
  if (compare_filter) {
    set_has_compare_filter();
  } else {
    clear_has_compare_filter();
  }
}

// optional bytes column_family = 2;
inline bool DependentColumnFilter::has_column_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DependentColumnFilter::set_has_column_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DependentColumnFilter::clear_has_column_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DependentColumnFilter::clear_column_family() {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    column_family_->clear();
  }
  clear_has_column_family();
}
inline const ::std::string& DependentColumnFilter::column_family() const {
  return *column_family_;
}
inline void DependentColumnFilter::set_column_family(const ::std::string& value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void DependentColumnFilter::set_column_family(const char* value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void DependentColumnFilter::set_column_family(const void* value, size_t size) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DependentColumnFilter::mutable_column_family() {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  return column_family_;
}
inline ::std::string* DependentColumnFilter::release_column_family() {
  clear_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_family_;
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DependentColumnFilter::set_allocated_column_family(::std::string* column_family) {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    delete column_family_;
  }
  if (column_family) {
    set_has_column_family();
    column_family_ = column_family;
  } else {
    clear_has_column_family();
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes column_qualifier = 3;
inline bool DependentColumnFilter::has_column_qualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DependentColumnFilter::set_has_column_qualifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DependentColumnFilter::clear_has_column_qualifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DependentColumnFilter::clear_column_qualifier() {
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    column_qualifier_->clear();
  }
  clear_has_column_qualifier();
}
inline const ::std::string& DependentColumnFilter::column_qualifier() const {
  return *column_qualifier_;
}
inline void DependentColumnFilter::set_column_qualifier(const ::std::string& value) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(value);
}
inline void DependentColumnFilter::set_column_qualifier(const char* value) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(value);
}
inline void DependentColumnFilter::set_column_qualifier(const void* value, size_t size) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DependentColumnFilter::mutable_column_qualifier() {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  return column_qualifier_;
}
inline ::std::string* DependentColumnFilter::release_column_qualifier() {
  clear_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_qualifier_;
    column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DependentColumnFilter::set_allocated_column_qualifier(::std::string* column_qualifier) {
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete column_qualifier_;
  }
  if (column_qualifier) {
    set_has_column_qualifier();
    column_qualifier_ = column_qualifier;
  } else {
    clear_has_column_qualifier();
    column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool drop_dependent_column = 4;
inline bool DependentColumnFilter::has_drop_dependent_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DependentColumnFilter::set_has_drop_dependent_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DependentColumnFilter::clear_has_drop_dependent_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DependentColumnFilter::clear_drop_dependent_column() {
  drop_dependent_column_ = false;
  clear_has_drop_dependent_column();
}
inline bool DependentColumnFilter::drop_dependent_column() const {
  return drop_dependent_column_;
}
inline void DependentColumnFilter::set_drop_dependent_column(bool value) {
  set_has_drop_dependent_column();
  drop_dependent_column_ = value;
}

// -------------------------------------------------------------------

// FamilyFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool FamilyFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FamilyFilter::set_has_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FamilyFilter::clear_has_compare_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FamilyFilter::clear_compare_filter() {
  if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
  clear_has_compare_filter();
}
inline const ::hbase::pb::CompareFilter& FamilyFilter::compare_filter() const {
  return compare_filter_ != NULL ? *compare_filter_ : *default_instance_->compare_filter_;
}
inline ::hbase::pb::CompareFilter* FamilyFilter::mutable_compare_filter() {
  set_has_compare_filter();
  if (compare_filter_ == NULL) compare_filter_ = new ::hbase::pb::CompareFilter;
  return compare_filter_;
}
inline ::hbase::pb::CompareFilter* FamilyFilter::release_compare_filter() {
  clear_has_compare_filter();
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = NULL;
  return temp;
}
inline void FamilyFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  delete compare_filter_;
  compare_filter_ = compare_filter;
  if (compare_filter) {
    set_has_compare_filter();
  } else {
    clear_has_compare_filter();
  }
}

// -------------------------------------------------------------------

// FilterList

// required .hbase.pb.FilterList.Operator operator = 1;
inline bool FilterList::has_operator_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterList::set_has_operator_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterList::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterList::clear_operator_() {
  operator__ = 1;
  clear_has_operator_();
}
inline ::hbase::pb::FilterList_Operator FilterList::operator_() const {
  return static_cast< ::hbase::pb::FilterList_Operator >(operator__);
}
inline void FilterList::set_operator_(::hbase::pb::FilterList_Operator value) {
  assert(::hbase::pb::FilterList_Operator_IsValid(value));
  set_has_operator_();
  operator__ = value;
}

// repeated .hbase.pb.Filter filters = 2;
inline int FilterList::filters_size() const {
  return filters_.size();
}
inline void FilterList::clear_filters() {
  filters_.Clear();
}
inline const ::hbase::pb::Filter& FilterList::filters(int index) const {
  return filters_.Get(index);
}
inline ::hbase::pb::Filter* FilterList::mutable_filters(int index) {
  return filters_.Mutable(index);
}
inline ::hbase::pb::Filter* FilterList::add_filters() {
  return filters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Filter >&
FilterList::filters() const {
  return filters_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Filter >*
FilterList::mutable_filters() {
  return &filters_;
}

// -------------------------------------------------------------------

// FilterWrapper

// required .hbase.pb.Filter filter = 1;
inline bool FilterWrapper::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterWrapper::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterWrapper::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterWrapper::clear_filter() {
  if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
  clear_has_filter();
}
inline const ::hbase::pb::Filter& FilterWrapper::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::hbase::pb::Filter* FilterWrapper::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::hbase::pb::Filter;
  return filter_;
}
inline ::hbase::pb::Filter* FilterWrapper::release_filter() {
  clear_has_filter();
  ::hbase::pb::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void FilterWrapper::set_allocated_filter(::hbase::pb::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// -------------------------------------------------------------------

// FirstKeyOnlyFilter

// -------------------------------------------------------------------

// FirstKeyValueMatchingQualifiersFilter

// repeated bytes qualifiers = 1;
inline int FirstKeyValueMatchingQualifiersFilter::qualifiers_size() const {
  return qualifiers_.size();
}
inline void FirstKeyValueMatchingQualifiersFilter::clear_qualifiers() {
  qualifiers_.Clear();
}
inline const ::std::string& FirstKeyValueMatchingQualifiersFilter::qualifiers(int index) const {
  return qualifiers_.Get(index);
}
inline ::std::string* FirstKeyValueMatchingQualifiersFilter::mutable_qualifiers(int index) {
  return qualifiers_.Mutable(index);
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const ::std::string& value) {
  qualifiers_.Mutable(index)->assign(value);
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const char* value) {
  qualifiers_.Mutable(index)->assign(value);
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const void* value, size_t size) {
  qualifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirstKeyValueMatchingQualifiersFilter::add_qualifiers() {
  return qualifiers_.Add();
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const ::std::string& value) {
  qualifiers_.Add()->assign(value);
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const char* value) {
  qualifiers_.Add()->assign(value);
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const void* value, size_t size) {
  qualifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FirstKeyValueMatchingQualifiersFilter::qualifiers() const {
  return qualifiers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FirstKeyValueMatchingQualifiersFilter::mutable_qualifiers() {
  return &qualifiers_;
}

// -------------------------------------------------------------------

// FuzzyRowFilter

// repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
inline int FuzzyRowFilter::fuzzy_keys_data_size() const {
  return fuzzy_keys_data_.size();
}
inline void FuzzyRowFilter::clear_fuzzy_keys_data() {
  fuzzy_keys_data_.Clear();
}
inline const ::hbase::pb::BytesBytesPair& FuzzyRowFilter::fuzzy_keys_data(int index) const {
  return fuzzy_keys_data_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* FuzzyRowFilter::mutable_fuzzy_keys_data(int index) {
  return fuzzy_keys_data_.Mutable(index);
}
inline ::hbase::pb::BytesBytesPair* FuzzyRowFilter::add_fuzzy_keys_data() {
  return fuzzy_keys_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
FuzzyRowFilter::fuzzy_keys_data() const {
  return fuzzy_keys_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
FuzzyRowFilter::mutable_fuzzy_keys_data() {
  return &fuzzy_keys_data_;
}

// -------------------------------------------------------------------

// InclusiveStopFilter

// optional bytes stop_row_key = 1;
inline bool InclusiveStopFilter::has_stop_row_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InclusiveStopFilter::set_has_stop_row_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InclusiveStopFilter::clear_has_stop_row_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InclusiveStopFilter::clear_stop_row_key() {
  if (stop_row_key_ != &::google::protobuf::internal::kEmptyString) {
    stop_row_key_->clear();
  }
  clear_has_stop_row_key();
}
inline const ::std::string& InclusiveStopFilter::stop_row_key() const {
  return *stop_row_key_;
}
inline void InclusiveStopFilter::set_stop_row_key(const ::std::string& value) {
  set_has_stop_row_key();
  if (stop_row_key_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_key_ = new ::std::string;
  }
  stop_row_key_->assign(value);
}
inline void InclusiveStopFilter::set_stop_row_key(const char* value) {
  set_has_stop_row_key();
  if (stop_row_key_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_key_ = new ::std::string;
  }
  stop_row_key_->assign(value);
}
inline void InclusiveStopFilter::set_stop_row_key(const void* value, size_t size) {
  set_has_stop_row_key();
  if (stop_row_key_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_key_ = new ::std::string;
  }
  stop_row_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InclusiveStopFilter::mutable_stop_row_key() {
  set_has_stop_row_key();
  if (stop_row_key_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_key_ = new ::std::string;
  }
  return stop_row_key_;
}
inline ::std::string* InclusiveStopFilter::release_stop_row_key() {
  clear_has_stop_row_key();
  if (stop_row_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_row_key_;
    stop_row_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InclusiveStopFilter::set_allocated_stop_row_key(::std::string* stop_row_key) {
  if (stop_row_key_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_row_key_;
  }
  if (stop_row_key) {
    set_has_stop_row_key();
    stop_row_key_ = stop_row_key;
  } else {
    clear_has_stop_row_key();
    stop_row_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KeyOnlyFilter

// required bool len_as_val = 1;
inline bool KeyOnlyFilter::has_len_as_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyOnlyFilter::set_has_len_as_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyOnlyFilter::clear_has_len_as_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyOnlyFilter::clear_len_as_val() {
  len_as_val_ = false;
  clear_has_len_as_val();
}
inline bool KeyOnlyFilter::len_as_val() const {
  return len_as_val_;
}
inline void KeyOnlyFilter::set_len_as_val(bool value) {
  set_has_len_as_val();
  len_as_val_ = value;
}

// -------------------------------------------------------------------

// MultipleColumnPrefixFilter

// repeated bytes sorted_prefixes = 1;
inline int MultipleColumnPrefixFilter::sorted_prefixes_size() const {
  return sorted_prefixes_.size();
}
inline void MultipleColumnPrefixFilter::clear_sorted_prefixes() {
  sorted_prefixes_.Clear();
}
inline const ::std::string& MultipleColumnPrefixFilter::sorted_prefixes(int index) const {
  return sorted_prefixes_.Get(index);
}
inline ::std::string* MultipleColumnPrefixFilter::mutable_sorted_prefixes(int index) {
  return sorted_prefixes_.Mutable(index);
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const ::std::string& value) {
  sorted_prefixes_.Mutable(index)->assign(value);
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const char* value) {
  sorted_prefixes_.Mutable(index)->assign(value);
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const void* value, size_t size) {
  sorted_prefixes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MultipleColumnPrefixFilter::add_sorted_prefixes() {
  return sorted_prefixes_.Add();
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const ::std::string& value) {
  sorted_prefixes_.Add()->assign(value);
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const char* value) {
  sorted_prefixes_.Add()->assign(value);
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const void* value, size_t size) {
  sorted_prefixes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultipleColumnPrefixFilter::sorted_prefixes() const {
  return sorted_prefixes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultipleColumnPrefixFilter::mutable_sorted_prefixes() {
  return &sorted_prefixes_;
}

// -------------------------------------------------------------------

// PageFilter

// required int64 page_size = 1;
inline bool PageFilter::has_page_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageFilter::set_has_page_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PageFilter::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PageFilter::clear_page_size() {
  page_size_ = GOOGLE_LONGLONG(0);
  clear_has_page_size();
}
inline ::google::protobuf::int64 PageFilter::page_size() const {
  return page_size_;
}
inline void PageFilter::set_page_size(::google::protobuf::int64 value) {
  set_has_page_size();
  page_size_ = value;
}

// -------------------------------------------------------------------

// PrefixFilter

// optional bytes prefix = 1;
inline bool PrefixFilter::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrefixFilter::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrefixFilter::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrefixFilter::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& PrefixFilter::prefix() const {
  return *prefix_;
}
inline void PrefixFilter::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void PrefixFilter::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void PrefixFilter::set_prefix(const void* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrefixFilter::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* PrefixFilter::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrefixFilter::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QualifierFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool QualifierFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QualifierFilter::set_has_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QualifierFilter::clear_has_compare_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QualifierFilter::clear_compare_filter() {
  if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
  clear_has_compare_filter();
}
inline const ::hbase::pb::CompareFilter& QualifierFilter::compare_filter() const {
  return compare_filter_ != NULL ? *compare_filter_ : *default_instance_->compare_filter_;
}
inline ::hbase::pb::CompareFilter* QualifierFilter::mutable_compare_filter() {
  set_has_compare_filter();
  if (compare_filter_ == NULL) compare_filter_ = new ::hbase::pb::CompareFilter;
  return compare_filter_;
}
inline ::hbase::pb::CompareFilter* QualifierFilter::release_compare_filter() {
  clear_has_compare_filter();
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = NULL;
  return temp;
}
inline void QualifierFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  delete compare_filter_;
  compare_filter_ = compare_filter;
  if (compare_filter) {
    set_has_compare_filter();
  } else {
    clear_has_compare_filter();
  }
}

// -------------------------------------------------------------------

// RandomRowFilter

// required float chance = 1;
inline bool RandomRowFilter::has_chance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomRowFilter::set_has_chance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomRowFilter::clear_has_chance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomRowFilter::clear_chance() {
  chance_ = 0;
  clear_has_chance();
}
inline float RandomRowFilter::chance() const {
  return chance_;
}
inline void RandomRowFilter::set_chance(float value) {
  set_has_chance();
  chance_ = value;
}

// -------------------------------------------------------------------

// RowFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool RowFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowFilter::set_has_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RowFilter::clear_has_compare_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RowFilter::clear_compare_filter() {
  if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
  clear_has_compare_filter();
}
inline const ::hbase::pb::CompareFilter& RowFilter::compare_filter() const {
  return compare_filter_ != NULL ? *compare_filter_ : *default_instance_->compare_filter_;
}
inline ::hbase::pb::CompareFilter* RowFilter::mutable_compare_filter() {
  set_has_compare_filter();
  if (compare_filter_ == NULL) compare_filter_ = new ::hbase::pb::CompareFilter;
  return compare_filter_;
}
inline ::hbase::pb::CompareFilter* RowFilter::release_compare_filter() {
  clear_has_compare_filter();
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = NULL;
  return temp;
}
inline void RowFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  delete compare_filter_;
  compare_filter_ = compare_filter;
  if (compare_filter) {
    set_has_compare_filter();
  } else {
    clear_has_compare_filter();
  }
}

// -------------------------------------------------------------------

// SingleColumnValueExcludeFilter

// required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
inline bool SingleColumnValueExcludeFilter::has_single_column_value_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleColumnValueExcludeFilter::set_has_single_column_value_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleColumnValueExcludeFilter::clear_has_single_column_value_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleColumnValueExcludeFilter::clear_single_column_value_filter() {
  if (single_column_value_filter_ != NULL) single_column_value_filter_->::hbase::pb::SingleColumnValueFilter::Clear();
  clear_has_single_column_value_filter();
}
inline const ::hbase::pb::SingleColumnValueFilter& SingleColumnValueExcludeFilter::single_column_value_filter() const {
  return single_column_value_filter_ != NULL ? *single_column_value_filter_ : *default_instance_->single_column_value_filter_;
}
inline ::hbase::pb::SingleColumnValueFilter* SingleColumnValueExcludeFilter::mutable_single_column_value_filter() {
  set_has_single_column_value_filter();
  if (single_column_value_filter_ == NULL) single_column_value_filter_ = new ::hbase::pb::SingleColumnValueFilter;
  return single_column_value_filter_;
}
inline ::hbase::pb::SingleColumnValueFilter* SingleColumnValueExcludeFilter::release_single_column_value_filter() {
  clear_has_single_column_value_filter();
  ::hbase::pb::SingleColumnValueFilter* temp = single_column_value_filter_;
  single_column_value_filter_ = NULL;
  return temp;
}
inline void SingleColumnValueExcludeFilter::set_allocated_single_column_value_filter(::hbase::pb::SingleColumnValueFilter* single_column_value_filter) {
  delete single_column_value_filter_;
  single_column_value_filter_ = single_column_value_filter;
  if (single_column_value_filter) {
    set_has_single_column_value_filter();
  } else {
    clear_has_single_column_value_filter();
  }
}

// -------------------------------------------------------------------

// SingleColumnValueFilter

// optional bytes column_family = 1;
inline bool SingleColumnValueFilter::has_column_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleColumnValueFilter::set_has_column_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleColumnValueFilter::clear_has_column_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleColumnValueFilter::clear_column_family() {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    column_family_->clear();
  }
  clear_has_column_family();
}
inline const ::std::string& SingleColumnValueFilter::column_family() const {
  return *column_family_;
}
inline void SingleColumnValueFilter::set_column_family(const ::std::string& value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void SingleColumnValueFilter::set_column_family(const char* value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void SingleColumnValueFilter::set_column_family(const void* value, size_t size) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleColumnValueFilter::mutable_column_family() {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  return column_family_;
}
inline ::std::string* SingleColumnValueFilter::release_column_family() {
  clear_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_family_;
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleColumnValueFilter::set_allocated_column_family(::std::string* column_family) {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    delete column_family_;
  }
  if (column_family) {
    set_has_column_family();
    column_family_ = column_family;
  } else {
    clear_has_column_family();
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes column_qualifier = 2;
inline bool SingleColumnValueFilter::has_column_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleColumnValueFilter::set_has_column_qualifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleColumnValueFilter::clear_has_column_qualifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleColumnValueFilter::clear_column_qualifier() {
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    column_qualifier_->clear();
  }
  clear_has_column_qualifier();
}
inline const ::std::string& SingleColumnValueFilter::column_qualifier() const {
  return *column_qualifier_;
}
inline void SingleColumnValueFilter::set_column_qualifier(const ::std::string& value) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(value);
}
inline void SingleColumnValueFilter::set_column_qualifier(const char* value) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(value);
}
inline void SingleColumnValueFilter::set_column_qualifier(const void* value, size_t size) {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  column_qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleColumnValueFilter::mutable_column_qualifier() {
  set_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    column_qualifier_ = new ::std::string;
  }
  return column_qualifier_;
}
inline ::std::string* SingleColumnValueFilter::release_column_qualifier() {
  clear_has_column_qualifier();
  if (column_qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_qualifier_;
    column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleColumnValueFilter::set_allocated_column_qualifier(::std::string* column_qualifier) {
  if (column_qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete column_qualifier_;
  }
  if (column_qualifier) {
    set_has_column_qualifier();
    column_qualifier_ = column_qualifier;
  } else {
    clear_has_column_qualifier();
    column_qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hbase.pb.CompareType compare_op = 3;
inline bool SingleColumnValueFilter::has_compare_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleColumnValueFilter::set_has_compare_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleColumnValueFilter::clear_has_compare_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleColumnValueFilter::clear_compare_op() {
  compare_op_ = 0;
  clear_has_compare_op();
}
inline ::hbase::pb::CompareType SingleColumnValueFilter::compare_op() const {
  return static_cast< ::hbase::pb::CompareType >(compare_op_);
}
inline void SingleColumnValueFilter::set_compare_op(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  set_has_compare_op();
  compare_op_ = value;
}

// required .hbase.pb.Comparator comparator = 4;
inline bool SingleColumnValueFilter::has_comparator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleColumnValueFilter::set_has_comparator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleColumnValueFilter::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleColumnValueFilter::clear_comparator() {
  if (comparator_ != NULL) comparator_->::hbase::pb::Comparator::Clear();
  clear_has_comparator();
}
inline const ::hbase::pb::Comparator& SingleColumnValueFilter::comparator() const {
  return comparator_ != NULL ? *comparator_ : *default_instance_->comparator_;
}
inline ::hbase::pb::Comparator* SingleColumnValueFilter::mutable_comparator() {
  set_has_comparator();
  if (comparator_ == NULL) comparator_ = new ::hbase::pb::Comparator;
  return comparator_;
}
inline ::hbase::pb::Comparator* SingleColumnValueFilter::release_comparator() {
  clear_has_comparator();
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = NULL;
  return temp;
}
inline void SingleColumnValueFilter::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  delete comparator_;
  comparator_ = comparator;
  if (comparator) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
}

// optional bool filter_if_missing = 5;
inline bool SingleColumnValueFilter::has_filter_if_missing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleColumnValueFilter::set_has_filter_if_missing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleColumnValueFilter::clear_has_filter_if_missing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleColumnValueFilter::clear_filter_if_missing() {
  filter_if_missing_ = false;
  clear_has_filter_if_missing();
}
inline bool SingleColumnValueFilter::filter_if_missing() const {
  return filter_if_missing_;
}
inline void SingleColumnValueFilter::set_filter_if_missing(bool value) {
  set_has_filter_if_missing();
  filter_if_missing_ = value;
}

// optional bool latest_version_only = 6;
inline bool SingleColumnValueFilter::has_latest_version_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleColumnValueFilter::set_has_latest_version_only() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleColumnValueFilter::clear_has_latest_version_only() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleColumnValueFilter::clear_latest_version_only() {
  latest_version_only_ = false;
  clear_has_latest_version_only();
}
inline bool SingleColumnValueFilter::latest_version_only() const {
  return latest_version_only_;
}
inline void SingleColumnValueFilter::set_latest_version_only(bool value) {
  set_has_latest_version_only();
  latest_version_only_ = value;
}

// -------------------------------------------------------------------

// SkipFilter

// required .hbase.pb.Filter filter = 1;
inline bool SkipFilter::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkipFilter::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkipFilter::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkipFilter::clear_filter() {
  if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
  clear_has_filter();
}
inline const ::hbase::pb::Filter& SkipFilter::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::hbase::pb::Filter* SkipFilter::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::hbase::pb::Filter;
  return filter_;
}
inline ::hbase::pb::Filter* SkipFilter::release_filter() {
  clear_has_filter();
  ::hbase::pb::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void SkipFilter::set_allocated_filter(::hbase::pb::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// -------------------------------------------------------------------

// TimestampsFilter

// repeated int64 timestamps = 1 [packed = true];
inline int TimestampsFilter::timestamps_size() const {
  return timestamps_.size();
}
inline void TimestampsFilter::clear_timestamps() {
  timestamps_.Clear();
}
inline ::google::protobuf::int64 TimestampsFilter::timestamps(int index) const {
  return timestamps_.Get(index);
}
inline void TimestampsFilter::set_timestamps(int index, ::google::protobuf::int64 value) {
  timestamps_.Set(index, value);
}
inline void TimestampsFilter::add_timestamps(::google::protobuf::int64 value) {
  timestamps_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TimestampsFilter::timestamps() const {
  return timestamps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TimestampsFilter::mutable_timestamps() {
  return &timestamps_;
}

// -------------------------------------------------------------------

// ValueFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool ValueFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValueFilter::set_has_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValueFilter::clear_has_compare_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValueFilter::clear_compare_filter() {
  if (compare_filter_ != NULL) compare_filter_->::hbase::pb::CompareFilter::Clear();
  clear_has_compare_filter();
}
inline const ::hbase::pb::CompareFilter& ValueFilter::compare_filter() const {
  return compare_filter_ != NULL ? *compare_filter_ : *default_instance_->compare_filter_;
}
inline ::hbase::pb::CompareFilter* ValueFilter::mutable_compare_filter() {
  set_has_compare_filter();
  if (compare_filter_ == NULL) compare_filter_ = new ::hbase::pb::CompareFilter;
  return compare_filter_;
}
inline ::hbase::pb::CompareFilter* ValueFilter::release_compare_filter() {
  clear_has_compare_filter();
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = NULL;
  return temp;
}
inline void ValueFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  delete compare_filter_;
  compare_filter_ = compare_filter;
  if (compare_filter) {
    set_has_compare_filter();
  } else {
    clear_has_compare_filter();
  }
}

// -------------------------------------------------------------------

// WhileMatchFilter

// required .hbase.pb.Filter filter = 1;
inline bool WhileMatchFilter::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhileMatchFilter::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WhileMatchFilter::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WhileMatchFilter::clear_filter() {
  if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
  clear_has_filter();
}
inline const ::hbase::pb::Filter& WhileMatchFilter::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::hbase::pb::Filter* WhileMatchFilter::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::hbase::pb::Filter;
  return filter_;
}
inline ::hbase::pb::Filter* WhileMatchFilter::release_filter() {
  clear_has_filter();
  ::hbase::pb::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void WhileMatchFilter::set_allocated_filter(::hbase::pb::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// -------------------------------------------------------------------

// FilterAllFilter

// -------------------------------------------------------------------

// RowRange

// optional bytes start_row = 1;
inline bool RowRange::has_start_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowRange::set_has_start_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RowRange::clear_has_start_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RowRange::clear_start_row() {
  if (start_row_ != &::google::protobuf::internal::kEmptyString) {
    start_row_->clear();
  }
  clear_has_start_row();
}
inline const ::std::string& RowRange::start_row() const {
  return *start_row_;
}
inline void RowRange::set_start_row(const ::std::string& value) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(value);
}
inline void RowRange::set_start_row(const char* value) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(value);
}
inline void RowRange::set_start_row(const void* value, size_t size) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RowRange::mutable_start_row() {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  return start_row_;
}
inline ::std::string* RowRange::release_start_row() {
  clear_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_row_;
    start_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RowRange::set_allocated_start_row(::std::string* start_row) {
  if (start_row_ != &::google::protobuf::internal::kEmptyString) {
    delete start_row_;
  }
  if (start_row) {
    set_has_start_row();
    start_row_ = start_row;
  } else {
    clear_has_start_row();
    start_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool start_row_inclusive = 2;
inline bool RowRange::has_start_row_inclusive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RowRange::set_has_start_row_inclusive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RowRange::clear_has_start_row_inclusive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RowRange::clear_start_row_inclusive() {
  start_row_inclusive_ = false;
  clear_has_start_row_inclusive();
}
inline bool RowRange::start_row_inclusive() const {
  return start_row_inclusive_;
}
inline void RowRange::set_start_row_inclusive(bool value) {
  set_has_start_row_inclusive();
  start_row_inclusive_ = value;
}

// optional bytes stop_row = 3;
inline bool RowRange::has_stop_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RowRange::set_has_stop_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RowRange::clear_has_stop_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RowRange::clear_stop_row() {
  if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
    stop_row_->clear();
  }
  clear_has_stop_row();
}
inline const ::std::string& RowRange::stop_row() const {
  return *stop_row_;
}
inline void RowRange::set_stop_row(const ::std::string& value) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(value);
}
inline void RowRange::set_stop_row(const char* value) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(value);
}
inline void RowRange::set_stop_row(const void* value, size_t size) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RowRange::mutable_stop_row() {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  return stop_row_;
}
inline ::std::string* RowRange::release_stop_row() {
  clear_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_row_;
    stop_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RowRange::set_allocated_stop_row(::std::string* stop_row) {
  if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_row_;
  }
  if (stop_row) {
    set_has_stop_row();
    stop_row_ = stop_row;
  } else {
    clear_has_stop_row();
    stop_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool stop_row_inclusive = 4;
inline bool RowRange::has_stop_row_inclusive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RowRange::set_has_stop_row_inclusive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RowRange::clear_has_stop_row_inclusive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RowRange::clear_stop_row_inclusive() {
  stop_row_inclusive_ = false;
  clear_has_stop_row_inclusive();
}
inline bool RowRange::stop_row_inclusive() const {
  return stop_row_inclusive_;
}
inline void RowRange::set_stop_row_inclusive(bool value) {
  set_has_stop_row_inclusive();
  stop_row_inclusive_ = value;
}

// -------------------------------------------------------------------

// MultiRowRangeFilter

// repeated .hbase.pb.RowRange row_range_list = 1;
inline int MultiRowRangeFilter::row_range_list_size() const {
  return row_range_list_.size();
}
inline void MultiRowRangeFilter::clear_row_range_list() {
  row_range_list_.Clear();
}
inline const ::hbase::pb::RowRange& MultiRowRangeFilter::row_range_list(int index) const {
  return row_range_list_.Get(index);
}
inline ::hbase::pb::RowRange* MultiRowRangeFilter::mutable_row_range_list(int index) {
  return row_range_list_.Mutable(index);
}
inline ::hbase::pb::RowRange* MultiRowRangeFilter::add_row_range_list() {
  return row_range_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RowRange >&
MultiRowRangeFilter::row_range_list() const {
  return row_range_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RowRange >*
MultiRowRangeFilter::mutable_row_range_list() {
  return &row_range_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::FilterList_Operator>() {
  return ::hbase::pb::FilterList_Operator_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Filter_2eproto__INCLUDED
