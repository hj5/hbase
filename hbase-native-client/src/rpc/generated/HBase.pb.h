// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HBase.proto

#ifndef PROTOBUF_HBase_2eproto__INCLUDED
#define PROTOBUF_HBase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Cell.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HBase_2eproto();
void protobuf_AssignDesc_HBase_2eproto();
void protobuf_ShutdownFile_HBase_2eproto();

class TableName;
class TableSchema;
class TableState;
class TableDescriptor;
class ColumnFamilySchema;
class RegionInfo;
class FavoredNodes;
class RegionSpecifier;
class TimeRange;
class ColumnFamilyTimeRange;
class ServerName;
class Coprocessor;
class NameStringPair;
class NameBytesPair;
class BytesBytesPair;
class NameInt64Pair;
class SnapshotDescription;
class ProcedureDescription;
class EmptyMsg;
class LongMsg;
class DoubleMsg;
class BigDecimalMsg;
class UUID;
class NamespaceDescriptor;
class VersionInfo;
class RegionServerInfo;

enum TableState_State {
  TableState_State_ENABLED = 0,
  TableState_State_DISABLED = 1,
  TableState_State_DISABLING = 2,
  TableState_State_ENABLING = 3
};
bool TableState_State_IsValid(int value);
const TableState_State TableState_State_State_MIN = TableState_State_ENABLED;
const TableState_State TableState_State_State_MAX = TableState_State_ENABLING;
const int TableState_State_State_ARRAYSIZE = TableState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableState_State_descriptor();
inline const ::std::string& TableState_State_Name(TableState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableState_State_descriptor(), value);
}
inline bool TableState_State_Parse(
    const ::std::string& name, TableState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableState_State>(
    TableState_State_descriptor(), name, value);
}
enum RegionSpecifier_RegionSpecifierType {
  RegionSpecifier_RegionSpecifierType_REGION_NAME = 1,
  RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME = 2
};
bool RegionSpecifier_RegionSpecifierType_IsValid(int value);
const RegionSpecifier_RegionSpecifierType RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MIN = RegionSpecifier_RegionSpecifierType_REGION_NAME;
const RegionSpecifier_RegionSpecifierType RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX = RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME;
const int RegionSpecifier_RegionSpecifierType_RegionSpecifierType_ARRAYSIZE = RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegionSpecifier_RegionSpecifierType_descriptor();
inline const ::std::string& RegionSpecifier_RegionSpecifierType_Name(RegionSpecifier_RegionSpecifierType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegionSpecifier_RegionSpecifierType_descriptor(), value);
}
inline bool RegionSpecifier_RegionSpecifierType_Parse(
    const ::std::string& name, RegionSpecifier_RegionSpecifierType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegionSpecifier_RegionSpecifierType>(
    RegionSpecifier_RegionSpecifierType_descriptor(), name, value);
}
enum SnapshotDescription_Type {
  SnapshotDescription_Type_DISABLED = 0,
  SnapshotDescription_Type_FLUSH = 1,
  SnapshotDescription_Type_SKIPFLUSH = 2
};
bool SnapshotDescription_Type_IsValid(int value);
const SnapshotDescription_Type SnapshotDescription_Type_Type_MIN = SnapshotDescription_Type_DISABLED;
const SnapshotDescription_Type SnapshotDescription_Type_Type_MAX = SnapshotDescription_Type_SKIPFLUSH;
const int SnapshotDescription_Type_Type_ARRAYSIZE = SnapshotDescription_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnapshotDescription_Type_descriptor();
inline const ::std::string& SnapshotDescription_Type_Name(SnapshotDescription_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnapshotDescription_Type_descriptor(), value);
}
inline bool SnapshotDescription_Type_Parse(
    const ::std::string& name, SnapshotDescription_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnapshotDescription_Type>(
    SnapshotDescription_Type_descriptor(), name, value);
}
enum CompareType {
  LESS = 0,
  LESS_OR_EQUAL = 1,
  EQUAL = 2,
  NOT_EQUAL = 3,
  GREATER_OR_EQUAL = 4,
  GREATER = 5,
  NO_OP = 6
};
bool CompareType_IsValid(int value);
const CompareType CompareType_MIN = LESS;
const CompareType CompareType_MAX = NO_OP;
const int CompareType_ARRAYSIZE = CompareType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompareType_descriptor();
inline const ::std::string& CompareType_Name(CompareType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompareType_descriptor(), value);
}
inline bool CompareType_Parse(
    const ::std::string& name, CompareType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompareType>(
    CompareType_descriptor(), name, value);
}
enum TimeUnit {
  NANOSECONDS = 1,
  MICROSECONDS = 2,
  MILLISECONDS = 3,
  SECONDS = 4,
  MINUTES = 5,
  HOURS = 6,
  DAYS = 7
};
bool TimeUnit_IsValid(int value);
const TimeUnit TimeUnit_MIN = NANOSECONDS;
const TimeUnit TimeUnit_MAX = DAYS;
const int TimeUnit_ARRAYSIZE = TimeUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeUnit_descriptor();
inline const ::std::string& TimeUnit_Name(TimeUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeUnit_descriptor(), value);
}
inline bool TimeUnit_Parse(
    const ::std::string& name, TimeUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeUnit>(
    TimeUnit_descriptor(), name, value);
}
// ===================================================================

class TableName : public ::google::protobuf::Message {
 public:
  TableName();
  virtual ~TableName();

  TableName(const TableName& from);

  inline TableName& operator=(const TableName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableName& default_instance();

  void Swap(TableName* other);

  // implements Message ----------------------------------------------

  TableName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableName& from);
  void MergeFrom(const TableName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes namespace = 1;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const void* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // required bytes qualifier = 2;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 2;
  inline const ::std::string& qualifier() const;
  inline void set_qualifier(const ::std::string& value);
  inline void set_qualifier(const char* value);
  inline void set_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_qualifier();
  inline ::std::string* release_qualifier();
  inline void set_allocated_qualifier(::std::string* qualifier);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableName)
 private:
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* namespace__;
  ::std::string* qualifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static TableName* default_instance_;
};
// -------------------------------------------------------------------

class TableSchema : public ::google::protobuf::Message {
 public:
  TableSchema();
  virtual ~TableSchema();

  TableSchema(const TableSchema& from);

  inline TableSchema& operator=(const TableSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSchema& default_instance();

  void Swap(TableSchema* other);

  // implements Message ----------------------------------------------

  TableSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSchema& from);
  void MergeFrom(const TableSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.TableName table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // repeated .hbase.pb.BytesBytesPair attributes = 2;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::hbase::pb::BytesBytesPair& attributes(int index) const;
  inline ::hbase::pb::BytesBytesPair* mutable_attributes(int index);
  inline ::hbase::pb::BytesBytesPair* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_attributes();

  // repeated .hbase.pb.ColumnFamilySchema column_families = 3;
  inline int column_families_size() const;
  inline void clear_column_families();
  static const int kColumnFamiliesFieldNumber = 3;
  inline const ::hbase::pb::ColumnFamilySchema& column_families(int index) const;
  inline ::hbase::pb::ColumnFamilySchema* mutable_column_families(int index);
  inline ::hbase::pb::ColumnFamilySchema* add_column_families();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >&
      column_families() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >*
      mutable_column_families();

  // repeated .hbase.pb.NameStringPair configuration = 4;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 4;
  inline const ::hbase::pb::NameStringPair& configuration(int index) const;
  inline ::hbase::pb::NameStringPair* mutable_configuration(int index);
  inline ::hbase::pb::NameStringPair* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:hbase.pb.TableSchema)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair > attributes_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema > column_families_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static TableSchema* default_instance_;
};
// -------------------------------------------------------------------

class TableState : public ::google::protobuf::Message {
 public:
  TableState();
  virtual ~TableState();

  TableState(const TableState& from);

  inline TableState& operator=(const TableState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableState& default_instance();

  void Swap(TableState* other);

  // implements Message ----------------------------------------------

  TableState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableState& from);
  void MergeFrom(const TableState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableState_State State;
  static const State ENABLED = TableState_State_ENABLED;
  static const State DISABLED = TableState_State_DISABLED;
  static const State DISABLING = TableState_State_DISABLING;
  static const State ENABLING = TableState_State_ENABLING;
  static inline bool State_IsValid(int value) {
    return TableState_State_IsValid(value);
  }
  static const State State_MIN =
    TableState_State_State_MIN;
  static const State State_MAX =
    TableState_State_State_MAX;
  static const int State_ARRAYSIZE =
    TableState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return TableState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return TableState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return TableState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.TableState.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::hbase::pb::TableState_State state() const;
  inline void set_state(::hbase::pb::TableState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableState)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static TableState* default_instance_;
};
// -------------------------------------------------------------------

class TableDescriptor : public ::google::protobuf::Message {
 public:
  TableDescriptor();
  virtual ~TableDescriptor();

  TableDescriptor(const TableDescriptor& from);

  inline TableDescriptor& operator=(const TableDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDescriptor& default_instance();

  void Swap(TableDescriptor* other);

  // implements Message ----------------------------------------------

  TableDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDescriptor& from);
  void MergeFrom(const TableDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.TableSchema schema = 1;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::hbase::pb::TableSchema& schema() const;
  inline ::hbase::pb::TableSchema* mutable_schema();
  inline ::hbase::pb::TableSchema* release_schema();
  inline void set_allocated_schema(::hbase::pb::TableSchema* schema);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableDescriptor)
 private:
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableSchema* schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static TableDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class ColumnFamilySchema : public ::google::protobuf::Message {
 public:
  ColumnFamilySchema();
  virtual ~ColumnFamilySchema();

  ColumnFamilySchema(const ColumnFamilySchema& from);

  inline ColumnFamilySchema& operator=(const ColumnFamilySchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnFamilySchema& default_instance();

  void Swap(ColumnFamilySchema* other);

  // implements Message ----------------------------------------------

  ColumnFamilySchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnFamilySchema& from);
  void MergeFrom(const ColumnFamilySchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .hbase.pb.BytesBytesPair attributes = 2;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::hbase::pb::BytesBytesPair& attributes(int index) const;
  inline ::hbase::pb::BytesBytesPair* mutable_attributes(int index);
  inline ::hbase::pb::BytesBytesPair* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_attributes();

  // repeated .hbase.pb.NameStringPair configuration = 3;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 3;
  inline const ::hbase::pb::NameStringPair& configuration(int index) const;
  inline ::hbase::pb::NameStringPair* mutable_configuration(int index);
  inline ::hbase::pb::NameStringPair* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnFamilySchema)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair > attributes_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static ColumnFamilySchema* default_instance_;
};
// -------------------------------------------------------------------

class RegionInfo : public ::google::protobuf::Message {
 public:
  RegionInfo();
  virtual ~RegionInfo();

  RegionInfo(const RegionInfo& from);

  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionInfo& default_instance();

  void Swap(RegionInfo* other);

  // implements Message ----------------------------------------------

  RegionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionInfo& from);
  void MergeFrom(const RegionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 region_id = 1;
  inline bool has_region_id() const;
  inline void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 region_id() const;
  inline void set_region_id(::google::protobuf::uint64 value);

  // required .hbase.pb.TableName table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional bytes start_key = 3;
  inline bool has_start_key() const;
  inline void clear_start_key();
  static const int kStartKeyFieldNumber = 3;
  inline const ::std::string& start_key() const;
  inline void set_start_key(const ::std::string& value);
  inline void set_start_key(const char* value);
  inline void set_start_key(const void* value, size_t size);
  inline ::std::string* mutable_start_key();
  inline ::std::string* release_start_key();
  inline void set_allocated_start_key(::std::string* start_key);

  // optional bytes end_key = 4;
  inline bool has_end_key() const;
  inline void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  inline const ::std::string& end_key() const;
  inline void set_end_key(const ::std::string& value);
  inline void set_end_key(const char* value);
  inline void set_end_key(const void* value, size_t size);
  inline ::std::string* mutable_end_key();
  inline ::std::string* release_end_key();
  inline void set_allocated_end_key(::std::string* end_key);

  // optional bool offline = 5;
  inline bool has_offline() const;
  inline void clear_offline();
  static const int kOfflineFieldNumber = 5;
  inline bool offline() const;
  inline void set_offline(bool value);

  // optional bool split = 6;
  inline bool has_split() const;
  inline void clear_split();
  static const int kSplitFieldNumber = 6;
  inline bool split() const;
  inline void set_split(bool value);

  // optional int32 replica_id = 7 [default = 0];
  inline bool has_replica_id() const;
  inline void clear_replica_id();
  static const int kReplicaIdFieldNumber = 7;
  inline ::google::protobuf::int32 replica_id() const;
  inline void set_replica_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionInfo)
 private:
  inline void set_has_region_id();
  inline void clear_has_region_id();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_start_key();
  inline void clear_has_start_key();
  inline void set_has_end_key();
  inline void clear_has_end_key();
  inline void set_has_offline();
  inline void clear_has_offline();
  inline void set_has_split();
  inline void clear_has_split();
  inline void set_has_replica_id();
  inline void clear_has_replica_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 region_id_;
  ::hbase::pb::TableName* table_name_;
  ::std::string* start_key_;
  ::std::string* end_key_;
  bool offline_;
  bool split_;
  ::google::protobuf::int32 replica_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static RegionInfo* default_instance_;
};
// -------------------------------------------------------------------

class FavoredNodes : public ::google::protobuf::Message {
 public:
  FavoredNodes();
  virtual ~FavoredNodes();

  FavoredNodes(const FavoredNodes& from);

  inline FavoredNodes& operator=(const FavoredNodes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FavoredNodes& default_instance();

  void Swap(FavoredNodes* other);

  // implements Message ----------------------------------------------

  FavoredNodes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FavoredNodes& from);
  void MergeFrom(const FavoredNodes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.ServerName favored_node = 1;
  inline int favored_node_size() const;
  inline void clear_favored_node();
  static const int kFavoredNodeFieldNumber = 1;
  inline const ::hbase::pb::ServerName& favored_node(int index) const;
  inline ::hbase::pb::ServerName* mutable_favored_node(int index);
  inline ::hbase::pb::ServerName* add_favored_node();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ServerName >&
      favored_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ServerName >*
      mutable_favored_node();

  // @@protoc_insertion_point(class_scope:hbase.pb.FavoredNodes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::ServerName > favored_node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static FavoredNodes* default_instance_;
};
// -------------------------------------------------------------------

class RegionSpecifier : public ::google::protobuf::Message {
 public:
  RegionSpecifier();
  virtual ~RegionSpecifier();

  RegionSpecifier(const RegionSpecifier& from);

  inline RegionSpecifier& operator=(const RegionSpecifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionSpecifier& default_instance();

  void Swap(RegionSpecifier* other);

  // implements Message ----------------------------------------------

  RegionSpecifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionSpecifier& from);
  void MergeFrom(const RegionSpecifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegionSpecifier_RegionSpecifierType RegionSpecifierType;
  static const RegionSpecifierType REGION_NAME = RegionSpecifier_RegionSpecifierType_REGION_NAME;
  static const RegionSpecifierType ENCODED_REGION_NAME = RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME;
  static inline bool RegionSpecifierType_IsValid(int value) {
    return RegionSpecifier_RegionSpecifierType_IsValid(value);
  }
  static const RegionSpecifierType RegionSpecifierType_MIN =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MIN;
  static const RegionSpecifierType RegionSpecifierType_MAX =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX;
  static const int RegionSpecifierType_ARRAYSIZE =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegionSpecifierType_descriptor() {
    return RegionSpecifier_RegionSpecifierType_descriptor();
  }
  static inline const ::std::string& RegionSpecifierType_Name(RegionSpecifierType value) {
    return RegionSpecifier_RegionSpecifierType_Name(value);
  }
  static inline bool RegionSpecifierType_Parse(const ::std::string& name,
      RegionSpecifierType* value) {
    return RegionSpecifier_RegionSpecifierType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier.RegionSpecifierType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::hbase::pb::RegionSpecifier_RegionSpecifierType type() const;
  inline void set_type(::hbase::pb::RegionSpecifier_RegionSpecifierType value);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionSpecifier)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static RegionSpecifier* default_instance_;
};
// -------------------------------------------------------------------

class TimeRange : public ::google::protobuf::Message {
 public:
  TimeRange();
  virtual ~TimeRange();

  TimeRange(const TimeRange& from);

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeRange& default_instance();

  void Swap(TimeRange* other);

  // implements Message ----------------------------------------------

  TimeRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline ::google::protobuf::uint64 from() const;
  inline void set_from(::google::protobuf::uint64 value);

  // optional uint64 to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline ::google::protobuf::uint64 to() const;
  inline void set_to(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TimeRange)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static TimeRange* default_instance_;
};
// -------------------------------------------------------------------

class ColumnFamilyTimeRange : public ::google::protobuf::Message {
 public:
  ColumnFamilyTimeRange();
  virtual ~ColumnFamilyTimeRange();

  ColumnFamilyTimeRange(const ColumnFamilyTimeRange& from);

  inline ColumnFamilyTimeRange& operator=(const ColumnFamilyTimeRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnFamilyTimeRange& default_instance();

  void Swap(ColumnFamilyTimeRange* other);

  // implements Message ----------------------------------------------

  ColumnFamilyTimeRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnFamilyTimeRange& from);
  void MergeFrom(const ColumnFamilyTimeRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes column_family = 1;
  inline bool has_column_family() const;
  inline void clear_column_family();
  static const int kColumnFamilyFieldNumber = 1;
  inline const ::std::string& column_family() const;
  inline void set_column_family(const ::std::string& value);
  inline void set_column_family(const char* value);
  inline void set_column_family(const void* value, size_t size);
  inline ::std::string* mutable_column_family();
  inline ::std::string* release_column_family();
  inline void set_allocated_column_family(::std::string* column_family);

  // required .hbase.pb.TimeRange time_range = 2;
  inline bool has_time_range() const;
  inline void clear_time_range();
  static const int kTimeRangeFieldNumber = 2;
  inline const ::hbase::pb::TimeRange& time_range() const;
  inline ::hbase::pb::TimeRange* mutable_time_range();
  inline ::hbase::pb::TimeRange* release_time_range();
  inline void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnFamilyTimeRange)
 private:
  inline void set_has_column_family();
  inline void clear_has_column_family();
  inline void set_has_time_range();
  inline void clear_has_time_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* column_family_;
  ::hbase::pb::TimeRange* time_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static ColumnFamilyTimeRange* default_instance_;
};
// -------------------------------------------------------------------

class ServerName : public ::google::protobuf::Message {
 public:
  ServerName();
  virtual ~ServerName();

  ServerName(const ServerName& from);

  inline ServerName& operator=(const ServerName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerName& default_instance();

  void Swap(ServerName* other);

  // implements Message ----------------------------------------------

  ServerName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerName& from);
  void MergeFrom(const ServerName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host_name = 1;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 1;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  inline void set_allocated_host_name(::std::string* host_name);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint64 start_code = 3;
  inline bool has_start_code() const;
  inline void clear_start_code();
  static const int kStartCodeFieldNumber = 3;
  inline ::google::protobuf::uint64 start_code() const;
  inline void set_start_code(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ServerName)
 private:
  inline void set_has_host_name();
  inline void clear_has_host_name();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_start_code();
  inline void clear_has_start_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_name_;
  ::google::protobuf::uint64 start_code_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static ServerName* default_instance_;
};
// -------------------------------------------------------------------

class Coprocessor : public ::google::protobuf::Message {
 public:
  Coprocessor();
  virtual ~Coprocessor();

  Coprocessor(const Coprocessor& from);

  inline Coprocessor& operator=(const Coprocessor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coprocessor& default_instance();

  void Swap(Coprocessor* other);

  // implements Message ----------------------------------------------

  Coprocessor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coprocessor& from);
  void MergeFrom(const Coprocessor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:hbase.pb.Coprocessor)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static Coprocessor* default_instance_;
};
// -------------------------------------------------------------------

class NameStringPair : public ::google::protobuf::Message {
 public:
  NameStringPair();
  virtual ~NameStringPair();

  NameStringPair(const NameStringPair& from);

  inline NameStringPair& operator=(const NameStringPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameStringPair& default_instance();

  void Swap(NameStringPair* other);

  // implements Message ----------------------------------------------

  NameStringPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameStringPair& from);
  void MergeFrom(const NameStringPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameStringPair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static NameStringPair* default_instance_;
};
// -------------------------------------------------------------------

class NameBytesPair : public ::google::protobuf::Message {
 public:
  NameBytesPair();
  virtual ~NameBytesPair();

  NameBytesPair(const NameBytesPair& from);

  inline NameBytesPair& operator=(const NameBytesPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameBytesPair& default_instance();

  void Swap(NameBytesPair* other);

  // implements Message ----------------------------------------------

  NameBytesPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameBytesPair& from);
  void MergeFrom(const NameBytesPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameBytesPair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static NameBytesPair* default_instance_;
};
// -------------------------------------------------------------------

class BytesBytesPair : public ::google::protobuf::Message {
 public:
  BytesBytesPair();
  virtual ~BytesBytesPair();

  BytesBytesPair(const BytesBytesPair& from);

  inline BytesBytesPair& operator=(const BytesBytesPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytesBytesPair& default_instance();

  void Swap(BytesBytesPair* other);

  // implements Message ----------------------------------------------

  BytesBytesPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BytesBytesPair& from);
  void MergeFrom(const BytesBytesPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes first = 1;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 1;
  inline const ::std::string& first() const;
  inline void set_first(const ::std::string& value);
  inline void set_first(const char* value);
  inline void set_first(const void* value, size_t size);
  inline ::std::string* mutable_first();
  inline ::std::string* release_first();
  inline void set_allocated_first(::std::string* first);

  // required bytes second = 2;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 2;
  inline const ::std::string& second() const;
  inline void set_second(const ::std::string& value);
  inline void set_second(const char* value);
  inline void set_second(const void* value, size_t size);
  inline ::std::string* mutable_second();
  inline ::std::string* release_second();
  inline void set_allocated_second(::std::string* second);

  // @@protoc_insertion_point(class_scope:hbase.pb.BytesBytesPair)
 private:
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_second();
  inline void clear_has_second();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* first_;
  ::std::string* second_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static BytesBytesPair* default_instance_;
};
// -------------------------------------------------------------------

class NameInt64Pair : public ::google::protobuf::Message {
 public:
  NameInt64Pair();
  virtual ~NameInt64Pair();

  NameInt64Pair(const NameInt64Pair& from);

  inline NameInt64Pair& operator=(const NameInt64Pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameInt64Pair& default_instance();

  void Swap(NameInt64Pair* other);

  // implements Message ----------------------------------------------

  NameInt64Pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameInt64Pair& from);
  void MergeFrom(const NameInt64Pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameInt64Pair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int64 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static NameInt64Pair* default_instance_;
};
// -------------------------------------------------------------------

class SnapshotDescription : public ::google::protobuf::Message {
 public:
  SnapshotDescription();
  virtual ~SnapshotDescription();

  SnapshotDescription(const SnapshotDescription& from);

  inline SnapshotDescription& operator=(const SnapshotDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapshotDescription& default_instance();

  void Swap(SnapshotDescription* other);

  // implements Message ----------------------------------------------

  SnapshotDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapshotDescription& from);
  void MergeFrom(const SnapshotDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SnapshotDescription_Type Type;
  static const Type DISABLED = SnapshotDescription_Type_DISABLED;
  static const Type FLUSH = SnapshotDescription_Type_FLUSH;
  static const Type SKIPFLUSH = SnapshotDescription_Type_SKIPFLUSH;
  static inline bool Type_IsValid(int value) {
    return SnapshotDescription_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SnapshotDescription_Type_Type_MIN;
  static const Type Type_MAX =
    SnapshotDescription_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SnapshotDescription_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SnapshotDescription_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SnapshotDescription_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SnapshotDescription_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const char* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // optional int64 creation_time = 3 [default = 0];
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 3;
  inline ::google::protobuf::int64 creation_time() const;
  inline void set_creation_time(::google::protobuf::int64 value);

  // optional .hbase.pb.SnapshotDescription.Type type = 4 [default = FLUSH];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::hbase::pb::SnapshotDescription_Type type() const;
  inline void set_type(::hbase::pb::SnapshotDescription_Type value);

  // optional int32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string owner = 6;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 6;
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const char* value, size_t size);
  inline ::std::string* mutable_owner();
  inline ::std::string* release_owner();
  inline void set_allocated_owner(::std::string* owner);

  // @@protoc_insertion_point(class_scope:hbase.pb.SnapshotDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_creation_time();
  inline void clear_has_creation_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_owner();
  inline void clear_has_owner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* table_;
  ::google::protobuf::int64 creation_time_;
  int type_;
  ::google::protobuf::int32 version_;
  ::std::string* owner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static SnapshotDescription* default_instance_;
};
// -------------------------------------------------------------------

class ProcedureDescription : public ::google::protobuf::Message {
 public:
  ProcedureDescription();
  virtual ~ProcedureDescription();

  ProcedureDescription(const ProcedureDescription& from);

  inline ProcedureDescription& operator=(const ProcedureDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureDescription& default_instance();

  void Swap(ProcedureDescription* other);

  // implements Message ----------------------------------------------

  ProcedureDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcedureDescription& from);
  void MergeFrom(const ProcedureDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional string instance = 2;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 2;
  inline const ::std::string& instance() const;
  inline void set_instance(const ::std::string& value);
  inline void set_instance(const char* value);
  inline void set_instance(const char* value, size_t size);
  inline ::std::string* mutable_instance();
  inline ::std::string* release_instance();
  inline void set_allocated_instance(::std::string* instance);

  // optional int64 creation_time = 3 [default = 0];
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 3;
  inline ::google::protobuf::int64 creation_time() const;
  inline void set_creation_time(::google::protobuf::int64 value);

  // repeated .hbase.pb.NameStringPair configuration = 4;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 4;
  inline const ::hbase::pb::NameStringPair& configuration(int index) const;
  inline ::hbase::pb::NameStringPair* mutable_configuration(int index);
  inline ::hbase::pb::NameStringPair* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:hbase.pb.ProcedureDescription)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_creation_time();
  inline void clear_has_creation_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* signature_;
  ::std::string* instance_;
  ::google::protobuf::int64 creation_time_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static ProcedureDescription* default_instance_;
};
// -------------------------------------------------------------------

class EmptyMsg : public ::google::protobuf::Message {
 public:
  EmptyMsg();
  virtual ~EmptyMsg();

  EmptyMsg(const EmptyMsg& from);

  inline EmptyMsg& operator=(const EmptyMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyMsg& default_instance();

  void Swap(EmptyMsg* other);

  // implements Message ----------------------------------------------

  EmptyMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyMsg& from);
  void MergeFrom(const EmptyMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.EmptyMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static EmptyMsg* default_instance_;
};
// -------------------------------------------------------------------

class LongMsg : public ::google::protobuf::Message {
 public:
  LongMsg();
  virtual ~LongMsg();

  LongMsg(const LongMsg& from);

  inline LongMsg& operator=(const LongMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LongMsg& default_instance();

  void Swap(LongMsg* other);

  // implements Message ----------------------------------------------

  LongMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LongMsg& from);
  void MergeFrom(const LongMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 long_msg = 1;
  inline bool has_long_msg() const;
  inline void clear_long_msg();
  static const int kLongMsgFieldNumber = 1;
  inline ::google::protobuf::int64 long_msg() const;
  inline void set_long_msg(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.LongMsg)
 private:
  inline void set_has_long_msg();
  inline void clear_has_long_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 long_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static LongMsg* default_instance_;
};
// -------------------------------------------------------------------

class DoubleMsg : public ::google::protobuf::Message {
 public:
  DoubleMsg();
  virtual ~DoubleMsg();

  DoubleMsg(const DoubleMsg& from);

  inline DoubleMsg& operator=(const DoubleMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleMsg& default_instance();

  void Swap(DoubleMsg* other);

  // implements Message ----------------------------------------------

  DoubleMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleMsg& from);
  void MergeFrom(const DoubleMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double double_msg = 1;
  inline bool has_double_msg() const;
  inline void clear_double_msg();
  static const int kDoubleMsgFieldNumber = 1;
  inline double double_msg() const;
  inline void set_double_msg(double value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DoubleMsg)
 private:
  inline void set_has_double_msg();
  inline void clear_has_double_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double double_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static DoubleMsg* default_instance_;
};
// -------------------------------------------------------------------

class BigDecimalMsg : public ::google::protobuf::Message {
 public:
  BigDecimalMsg();
  virtual ~BigDecimalMsg();

  BigDecimalMsg(const BigDecimalMsg& from);

  inline BigDecimalMsg& operator=(const BigDecimalMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigDecimalMsg& default_instance();

  void Swap(BigDecimalMsg* other);

  // implements Message ----------------------------------------------

  BigDecimalMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigDecimalMsg& from);
  void MergeFrom(const BigDecimalMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bigdecimal_msg = 1;
  inline bool has_bigdecimal_msg() const;
  inline void clear_bigdecimal_msg();
  static const int kBigdecimalMsgFieldNumber = 1;
  inline const ::std::string& bigdecimal_msg() const;
  inline void set_bigdecimal_msg(const ::std::string& value);
  inline void set_bigdecimal_msg(const char* value);
  inline void set_bigdecimal_msg(const void* value, size_t size);
  inline ::std::string* mutable_bigdecimal_msg();
  inline ::std::string* release_bigdecimal_msg();
  inline void set_allocated_bigdecimal_msg(::std::string* bigdecimal_msg);

  // @@protoc_insertion_point(class_scope:hbase.pb.BigDecimalMsg)
 private:
  inline void set_has_bigdecimal_msg();
  inline void clear_has_bigdecimal_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bigdecimal_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static BigDecimalMsg* default_instance_;
};
// -------------------------------------------------------------------

class UUID : public ::google::protobuf::Message {
 public:
  UUID();
  virtual ~UUID();

  UUID(const UUID& from);

  inline UUID& operator=(const UUID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UUID& default_instance();

  void Swap(UUID* other);

  // implements Message ----------------------------------------------

  UUID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UUID& from);
  void MergeFrom(const UUID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 least_sig_bits = 1;
  inline bool has_least_sig_bits() const;
  inline void clear_least_sig_bits();
  static const int kLeastSigBitsFieldNumber = 1;
  inline ::google::protobuf::uint64 least_sig_bits() const;
  inline void set_least_sig_bits(::google::protobuf::uint64 value);

  // required uint64 most_sig_bits = 2;
  inline bool has_most_sig_bits() const;
  inline void clear_most_sig_bits();
  static const int kMostSigBitsFieldNumber = 2;
  inline ::google::protobuf::uint64 most_sig_bits() const;
  inline void set_most_sig_bits(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.UUID)
 private:
  inline void set_has_least_sig_bits();
  inline void clear_has_least_sig_bits();
  inline void set_has_most_sig_bits();
  inline void clear_has_most_sig_bits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 least_sig_bits_;
  ::google::protobuf::uint64 most_sig_bits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static UUID* default_instance_;
};
// -------------------------------------------------------------------

class NamespaceDescriptor : public ::google::protobuf::Message {
 public:
  NamespaceDescriptor();
  virtual ~NamespaceDescriptor();

  NamespaceDescriptor(const NamespaceDescriptor& from);

  inline NamespaceDescriptor& operator=(const NamespaceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamespaceDescriptor& default_instance();

  void Swap(NamespaceDescriptor* other);

  // implements Message ----------------------------------------------

  NamespaceDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamespaceDescriptor& from);
  void MergeFrom(const NamespaceDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .hbase.pb.NameStringPair configuration = 2;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 2;
  inline const ::hbase::pb::NameStringPair& configuration(int index) const;
  inline ::hbase::pb::NameStringPair* mutable_configuration(int index);
  inline ::hbase::pb::NameStringPair* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:hbase.pb.NamespaceDescriptor)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static NamespaceDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class VersionInfo : public ::google::protobuf::Message {
 public:
  VersionInfo();
  virtual ~VersionInfo();

  VersionInfo(const VersionInfo& from);

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionInfo& default_instance();

  void Swap(VersionInfo* other);

  // implements Message ----------------------------------------------

  VersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required string revision = 3;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 3;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const char* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // required string user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // required string src_checksum = 6;
  inline bool has_src_checksum() const;
  inline void clear_src_checksum();
  static const int kSrcChecksumFieldNumber = 6;
  inline const ::std::string& src_checksum() const;
  inline void set_src_checksum(const ::std::string& value);
  inline void set_src_checksum(const char* value);
  inline void set_src_checksum(const char* value, size_t size);
  inline ::std::string* mutable_src_checksum();
  inline ::std::string* release_src_checksum();
  inline void set_allocated_src_checksum(::std::string* src_checksum);

  // optional uint32 version_major = 7;
  inline bool has_version_major() const;
  inline void clear_version_major();
  static const int kVersionMajorFieldNumber = 7;
  inline ::google::protobuf::uint32 version_major() const;
  inline void set_version_major(::google::protobuf::uint32 value);

  // optional uint32 version_minor = 8;
  inline bool has_version_minor() const;
  inline void clear_version_minor();
  static const int kVersionMinorFieldNumber = 8;
  inline ::google::protobuf::uint32 version_minor() const;
  inline void set_version_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.VersionInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_src_checksum();
  inline void clear_has_src_checksum();
  inline void set_has_version_major();
  inline void clear_has_version_major();
  inline void set_has_version_minor();
  inline void clear_has_version_minor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::std::string* url_;
  ::std::string* revision_;
  ::std::string* user_;
  ::std::string* date_;
  ::std::string* src_checksum_;
  ::google::protobuf::uint32 version_major_;
  ::google::protobuf::uint32 version_minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static VersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegionServerInfo : public ::google::protobuf::Message {
 public:
  RegionServerInfo();
  virtual ~RegionServerInfo();

  RegionServerInfo(const RegionServerInfo& from);

  inline RegionServerInfo& operator=(const RegionServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionServerInfo& default_instance();

  void Swap(RegionServerInfo* other);

  // implements Message ----------------------------------------------

  RegionServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionServerInfo& from);
  void MergeFrom(const RegionServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 infoPort = 1;
  inline bool has_infoport() const;
  inline void clear_infoport();
  static const int kInfoPortFieldNumber = 1;
  inline ::google::protobuf::int32 infoport() const;
  inline void set_infoport(::google::protobuf::int32 value);

  // optional .hbase.pb.VersionInfo version_info = 2;
  inline bool has_version_info() const;
  inline void clear_version_info();
  static const int kVersionInfoFieldNumber = 2;
  inline const ::hbase::pb::VersionInfo& version_info() const;
  inline ::hbase::pb::VersionInfo* mutable_version_info();
  inline ::hbase::pb::VersionInfo* release_version_info();
  inline void set_allocated_version_info(::hbase::pb::VersionInfo* version_info);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionServerInfo)
 private:
  inline void set_has_infoport();
  inline void clear_has_infoport();
  inline void set_has_version_info();
  inline void clear_has_version_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::VersionInfo* version_info_;
  ::google::protobuf::int32 infoport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HBase_2eproto();
  friend void protobuf_AssignDesc_HBase_2eproto();
  friend void protobuf_ShutdownFile_HBase_2eproto();

  void InitAsDefaultInstance();
  static RegionServerInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TableName

// required bytes namespace = 1;
inline bool TableName::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableName::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableName::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableName::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& TableName::namespace_() const {
  return *namespace__;
}
inline void TableName::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void TableName::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void TableName::set_namespace_(const void* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableName::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  return namespace__;
}
inline ::std::string* TableName::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableName::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes qualifier = 2;
inline bool TableName::has_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableName::set_has_qualifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableName::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableName::clear_qualifier() {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    qualifier_->clear();
  }
  clear_has_qualifier();
}
inline const ::std::string& TableName::qualifier() const {
  return *qualifier_;
}
inline void TableName::set_qualifier(const ::std::string& value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void TableName::set_qualifier(const char* value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void TableName::set_qualifier(const void* value, size_t size) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableName::mutable_qualifier() {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  return qualifier_;
}
inline ::std::string* TableName::release_qualifier() {
  clear_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualifier_;
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableName::set_allocated_qualifier(::std::string* qualifier) {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (qualifier) {
    set_has_qualifier();
    qualifier_ = qualifier;
  } else {
    clear_has_qualifier();
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TableSchema

// optional .hbase.pb.TableName table_name = 1;
inline bool TableSchema::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSchema::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSchema::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& TableSchema::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* TableSchema::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* TableSchema::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void TableSchema::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// repeated .hbase.pb.BytesBytesPair attributes = 2;
inline int TableSchema::attributes_size() const {
  return attributes_.size();
}
inline void TableSchema::clear_attributes() {
  attributes_.Clear();
}
inline const ::hbase::pb::BytesBytesPair& TableSchema::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* TableSchema::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::hbase::pb::BytesBytesPair* TableSchema::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
TableSchema::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
TableSchema::mutable_attributes() {
  return &attributes_;
}

// repeated .hbase.pb.ColumnFamilySchema column_families = 3;
inline int TableSchema::column_families_size() const {
  return column_families_.size();
}
inline void TableSchema::clear_column_families() {
  column_families_.Clear();
}
inline const ::hbase::pb::ColumnFamilySchema& TableSchema::column_families(int index) const {
  return column_families_.Get(index);
}
inline ::hbase::pb::ColumnFamilySchema* TableSchema::mutable_column_families(int index) {
  return column_families_.Mutable(index);
}
inline ::hbase::pb::ColumnFamilySchema* TableSchema::add_column_families() {
  return column_families_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >&
TableSchema::column_families() const {
  return column_families_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >*
TableSchema::mutable_column_families() {
  return &column_families_;
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int TableSchema::configuration_size() const {
  return configuration_.size();
}
inline void TableSchema::clear_configuration() {
  configuration_.Clear();
}
inline const ::hbase::pb::NameStringPair& TableSchema::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* TableSchema::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::hbase::pb::NameStringPair* TableSchema::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
TableSchema::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
TableSchema::mutable_configuration() {
  return &configuration_;
}

// -------------------------------------------------------------------

// TableState

// required .hbase.pb.TableState.State state = 1;
inline bool TableState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hbase::pb::TableState_State TableState::state() const {
  return static_cast< ::hbase::pb::TableState_State >(state_);
}
inline void TableState::set_state(::hbase::pb::TableState_State value) {
  assert(::hbase::pb::TableState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// TableDescriptor

// required .hbase.pb.TableSchema schema = 1;
inline bool TableDescriptor::has_schema() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDescriptor::set_has_schema() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDescriptor::clear_has_schema() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDescriptor::clear_schema() {
  if (schema_ != NULL) schema_->::hbase::pb::TableSchema::Clear();
  clear_has_schema();
}
inline const ::hbase::pb::TableSchema& TableDescriptor::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::hbase::pb::TableSchema* TableDescriptor::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::hbase::pb::TableSchema;
  return schema_;
}
inline ::hbase::pb::TableSchema* TableDescriptor::release_schema() {
  clear_has_schema();
  ::hbase::pb::TableSchema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void TableDescriptor::set_allocated_schema(::hbase::pb::TableSchema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// -------------------------------------------------------------------

// ColumnFamilySchema

// required bytes name = 1;
inline bool ColumnFamilySchema::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnFamilySchema::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnFamilySchema::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnFamilySchema::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ColumnFamilySchema::name() const {
  return *name_;
}
inline void ColumnFamilySchema::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ColumnFamilySchema::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ColumnFamilySchema::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnFamilySchema::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ColumnFamilySchema::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnFamilySchema::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.BytesBytesPair attributes = 2;
inline int ColumnFamilySchema::attributes_size() const {
  return attributes_.size();
}
inline void ColumnFamilySchema::clear_attributes() {
  attributes_.Clear();
}
inline const ::hbase::pb::BytesBytesPair& ColumnFamilySchema::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* ColumnFamilySchema::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::hbase::pb::BytesBytesPair* ColumnFamilySchema::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
ColumnFamilySchema::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
ColumnFamilySchema::mutable_attributes() {
  return &attributes_;
}

// repeated .hbase.pb.NameStringPair configuration = 3;
inline int ColumnFamilySchema::configuration_size() const {
  return configuration_.size();
}
inline void ColumnFamilySchema::clear_configuration() {
  configuration_.Clear();
}
inline const ::hbase::pb::NameStringPair& ColumnFamilySchema::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ColumnFamilySchema::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::hbase::pb::NameStringPair* ColumnFamilySchema::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ColumnFamilySchema::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ColumnFamilySchema::mutable_configuration() {
  return &configuration_;
}

// -------------------------------------------------------------------

// RegionInfo

// required uint64 region_id = 1;
inline bool RegionInfo::has_region_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionInfo::set_has_region_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionInfo::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionInfo::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
  clear_has_region_id();
}
inline ::google::protobuf::uint64 RegionInfo::region_id() const {
  return region_id_;
}
inline void RegionInfo::set_region_id(::google::protobuf::uint64 value) {
  set_has_region_id();
  region_id_ = value;
}

// required .hbase.pb.TableName table_name = 2;
inline bool RegionInfo::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionInfo::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionInfo::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionInfo::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& RegionInfo::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* RegionInfo::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* RegionInfo::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void RegionInfo::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// optional bytes start_key = 3;
inline bool RegionInfo::has_start_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionInfo::set_has_start_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionInfo::clear_has_start_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionInfo::clear_start_key() {
  if (start_key_ != &::google::protobuf::internal::kEmptyString) {
    start_key_->clear();
  }
  clear_has_start_key();
}
inline const ::std::string& RegionInfo::start_key() const {
  return *start_key_;
}
inline void RegionInfo::set_start_key(const ::std::string& value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::kEmptyString) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
}
inline void RegionInfo::set_start_key(const char* value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::kEmptyString) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
}
inline void RegionInfo::set_start_key(const void* value, size_t size) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::kEmptyString) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionInfo::mutable_start_key() {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::kEmptyString) {
    start_key_ = new ::std::string;
  }
  return start_key_;
}
inline ::std::string* RegionInfo::release_start_key() {
  clear_has_start_key();
  if (start_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_key_;
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionInfo::set_allocated_start_key(::std::string* start_key) {
  if (start_key_ != &::google::protobuf::internal::kEmptyString) {
    delete start_key_;
  }
  if (start_key) {
    set_has_start_key();
    start_key_ = start_key;
  } else {
    clear_has_start_key();
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes end_key = 4;
inline bool RegionInfo::has_end_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionInfo::set_has_end_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegionInfo::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegionInfo::clear_end_key() {
  if (end_key_ != &::google::protobuf::internal::kEmptyString) {
    end_key_->clear();
  }
  clear_has_end_key();
}
inline const ::std::string& RegionInfo::end_key() const {
  return *end_key_;
}
inline void RegionInfo::set_end_key(const ::std::string& value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::kEmptyString) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
}
inline void RegionInfo::set_end_key(const char* value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::kEmptyString) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
}
inline void RegionInfo::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::kEmptyString) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionInfo::mutable_end_key() {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::kEmptyString) {
    end_key_ = new ::std::string;
  }
  return end_key_;
}
inline ::std::string* RegionInfo::release_end_key() {
  clear_has_end_key();
  if (end_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_key_;
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionInfo::set_allocated_end_key(::std::string* end_key) {
  if (end_key_ != &::google::protobuf::internal::kEmptyString) {
    delete end_key_;
  }
  if (end_key) {
    set_has_end_key();
    end_key_ = end_key;
  } else {
    clear_has_end_key();
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool offline = 5;
inline bool RegionInfo::has_offline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionInfo::set_has_offline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegionInfo::clear_has_offline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegionInfo::clear_offline() {
  offline_ = false;
  clear_has_offline();
}
inline bool RegionInfo::offline() const {
  return offline_;
}
inline void RegionInfo::set_offline(bool value) {
  set_has_offline();
  offline_ = value;
}

// optional bool split = 6;
inline bool RegionInfo::has_split() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionInfo::set_has_split() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegionInfo::clear_has_split() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegionInfo::clear_split() {
  split_ = false;
  clear_has_split();
}
inline bool RegionInfo::split() const {
  return split_;
}
inline void RegionInfo::set_split(bool value) {
  set_has_split();
  split_ = value;
}

// optional int32 replica_id = 7 [default = 0];
inline bool RegionInfo::has_replica_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionInfo::set_has_replica_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegionInfo::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegionInfo::clear_replica_id() {
  replica_id_ = 0;
  clear_has_replica_id();
}
inline ::google::protobuf::int32 RegionInfo::replica_id() const {
  return replica_id_;
}
inline void RegionInfo::set_replica_id(::google::protobuf::int32 value) {
  set_has_replica_id();
  replica_id_ = value;
}

// -------------------------------------------------------------------

// FavoredNodes

// repeated .hbase.pb.ServerName favored_node = 1;
inline int FavoredNodes::favored_node_size() const {
  return favored_node_.size();
}
inline void FavoredNodes::clear_favored_node() {
  favored_node_.Clear();
}
inline const ::hbase::pb::ServerName& FavoredNodes::favored_node(int index) const {
  return favored_node_.Get(index);
}
inline ::hbase::pb::ServerName* FavoredNodes::mutable_favored_node(int index) {
  return favored_node_.Mutable(index);
}
inline ::hbase::pb::ServerName* FavoredNodes::add_favored_node() {
  return favored_node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ServerName >&
FavoredNodes::favored_node() const {
  return favored_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ServerName >*
FavoredNodes::mutable_favored_node() {
  return &favored_node_;
}

// -------------------------------------------------------------------

// RegionSpecifier

// required .hbase.pb.RegionSpecifier.RegionSpecifierType type = 1;
inline bool RegionSpecifier::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionSpecifier::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionSpecifier::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionSpecifier::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hbase::pb::RegionSpecifier_RegionSpecifierType RegionSpecifier::type() const {
  return static_cast< ::hbase::pb::RegionSpecifier_RegionSpecifierType >(type_);
}
inline void RegionSpecifier::set_type(::hbase::pb::RegionSpecifier_RegionSpecifierType value) {
  assert(::hbase::pb::RegionSpecifier_RegionSpecifierType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes value = 2;
inline bool RegionSpecifier::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionSpecifier::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionSpecifier::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionSpecifier::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RegionSpecifier::value() const {
  return *value_;
}
inline void RegionSpecifier::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RegionSpecifier::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RegionSpecifier::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegionSpecifier::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RegionSpecifier::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegionSpecifier::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 from = 1;
inline bool TimeRange::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeRange::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeRange::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeRange::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
  clear_has_from();
}
inline ::google::protobuf::uint64 TimeRange::from() const {
  return from_;
}
inline void TimeRange::set_from(::google::protobuf::uint64 value) {
  set_has_from();
  from_ = value;
}

// optional uint64 to = 2;
inline bool TimeRange::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeRange::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeRange::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeRange::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
  clear_has_to();
}
inline ::google::protobuf::uint64 TimeRange::to() const {
  return to_;
}
inline void TimeRange::set_to(::google::protobuf::uint64 value) {
  set_has_to();
  to_ = value;
}

// -------------------------------------------------------------------

// ColumnFamilyTimeRange

// required bytes column_family = 1;
inline bool ColumnFamilyTimeRange::has_column_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnFamilyTimeRange::set_has_column_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnFamilyTimeRange::clear_has_column_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnFamilyTimeRange::clear_column_family() {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    column_family_->clear();
  }
  clear_has_column_family();
}
inline const ::std::string& ColumnFamilyTimeRange::column_family() const {
  return *column_family_;
}
inline void ColumnFamilyTimeRange::set_column_family(const ::std::string& value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void ColumnFamilyTimeRange::set_column_family(const char* value) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(value);
}
inline void ColumnFamilyTimeRange::set_column_family(const void* value, size_t size) {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  column_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnFamilyTimeRange::mutable_column_family() {
  set_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    column_family_ = new ::std::string;
  }
  return column_family_;
}
inline ::std::string* ColumnFamilyTimeRange::release_column_family() {
  clear_has_column_family();
  if (column_family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_family_;
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnFamilyTimeRange::set_allocated_column_family(::std::string* column_family) {
  if (column_family_ != &::google::protobuf::internal::kEmptyString) {
    delete column_family_;
  }
  if (column_family) {
    set_has_column_family();
    column_family_ = column_family;
  } else {
    clear_has_column_family();
    column_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hbase.pb.TimeRange time_range = 2;
inline bool ColumnFamilyTimeRange::has_time_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnFamilyTimeRange::set_has_time_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnFamilyTimeRange::clear_has_time_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnFamilyTimeRange::clear_time_range() {
  if (time_range_ != NULL) time_range_->::hbase::pb::TimeRange::Clear();
  clear_has_time_range();
}
inline const ::hbase::pb::TimeRange& ColumnFamilyTimeRange::time_range() const {
  return time_range_ != NULL ? *time_range_ : *default_instance_->time_range_;
}
inline ::hbase::pb::TimeRange* ColumnFamilyTimeRange::mutable_time_range() {
  set_has_time_range();
  if (time_range_ == NULL) time_range_ = new ::hbase::pb::TimeRange;
  return time_range_;
}
inline ::hbase::pb::TimeRange* ColumnFamilyTimeRange::release_time_range() {
  clear_has_time_range();
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = NULL;
  return temp;
}
inline void ColumnFamilyTimeRange::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  delete time_range_;
  time_range_ = time_range;
  if (time_range) {
    set_has_time_range();
  } else {
    clear_has_time_range();
  }
}

// -------------------------------------------------------------------

// ServerName

// required string host_name = 1;
inline bool ServerName::has_host_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerName::set_has_host_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerName::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerName::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& ServerName::host_name() const {
  return *host_name_;
}
inline void ServerName::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void ServerName::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void ServerName::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerName::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  return host_name_;
}
inline ::std::string* ServerName::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerName::set_allocated_host_name(::std::string* host_name) {
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    delete host_name_;
  }
  if (host_name) {
    set_has_host_name();
    host_name_ = host_name;
  } else {
    clear_has_host_name();
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 2;
inline bool ServerName::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerName::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerName::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerName::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ServerName::port() const {
  return port_;
}
inline void ServerName::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint64 start_code = 3;
inline bool ServerName::has_start_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerName::set_has_start_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerName::clear_has_start_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerName::clear_start_code() {
  start_code_ = GOOGLE_ULONGLONG(0);
  clear_has_start_code();
}
inline ::google::protobuf::uint64 ServerName::start_code() const {
  return start_code_;
}
inline void ServerName::set_start_code(::google::protobuf::uint64 value) {
  set_has_start_code();
  start_code_ = value;
}

// -------------------------------------------------------------------

// Coprocessor

// required string name = 1;
inline bool Coprocessor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coprocessor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coprocessor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coprocessor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Coprocessor::name() const {
  return *name_;
}
inline void Coprocessor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Coprocessor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Coprocessor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Coprocessor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Coprocessor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Coprocessor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameStringPair

// required string name = 1;
inline bool NameStringPair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameStringPair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameStringPair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameStringPair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameStringPair::name() const {
  return *name_;
}
inline void NameStringPair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameStringPair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameStringPair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameStringPair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameStringPair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameStringPair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool NameStringPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameStringPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameStringPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameStringPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameStringPair::value() const {
  return *value_;
}
inline void NameStringPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameStringPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameStringPair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameStringPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameStringPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameStringPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameBytesPair

// required string name = 1;
inline bool NameBytesPair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameBytesPair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameBytesPair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameBytesPair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameBytesPair::name() const {
  return *name_;
}
inline void NameBytesPair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameBytesPair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameBytesPair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameBytesPair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameBytesPair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameBytesPair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 2;
inline bool NameBytesPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameBytesPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameBytesPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameBytesPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameBytesPair::value() const {
  return *value_;
}
inline void NameBytesPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameBytesPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameBytesPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameBytesPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameBytesPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameBytesPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BytesBytesPair

// required bytes first = 1;
inline bool BytesBytesPair::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytesBytesPair::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytesBytesPair::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytesBytesPair::clear_first() {
  if (first_ != &::google::protobuf::internal::kEmptyString) {
    first_->clear();
  }
  clear_has_first();
}
inline const ::std::string& BytesBytesPair::first() const {
  return *first_;
}
inline void BytesBytesPair::set_first(const ::std::string& value) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(value);
}
inline void BytesBytesPair::set_first(const char* value) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(value);
}
inline void BytesBytesPair::set_first(const void* value, size_t size) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BytesBytesPair::mutable_first() {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  return first_;
}
inline ::std::string* BytesBytesPair::release_first() {
  clear_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_;
    first_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BytesBytesPair::set_allocated_first(::std::string* first) {
  if (first_ != &::google::protobuf::internal::kEmptyString) {
    delete first_;
  }
  if (first) {
    set_has_first();
    first_ = first;
  } else {
    clear_has_first();
    first_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes second = 2;
inline bool BytesBytesPair::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytesBytesPair::set_has_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytesBytesPair::clear_has_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytesBytesPair::clear_second() {
  if (second_ != &::google::protobuf::internal::kEmptyString) {
    second_->clear();
  }
  clear_has_second();
}
inline const ::std::string& BytesBytesPair::second() const {
  return *second_;
}
inline void BytesBytesPair::set_second(const ::std::string& value) {
  set_has_second();
  if (second_ == &::google::protobuf::internal::kEmptyString) {
    second_ = new ::std::string;
  }
  second_->assign(value);
}
inline void BytesBytesPair::set_second(const char* value) {
  set_has_second();
  if (second_ == &::google::protobuf::internal::kEmptyString) {
    second_ = new ::std::string;
  }
  second_->assign(value);
}
inline void BytesBytesPair::set_second(const void* value, size_t size) {
  set_has_second();
  if (second_ == &::google::protobuf::internal::kEmptyString) {
    second_ = new ::std::string;
  }
  second_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BytesBytesPair::mutable_second() {
  set_has_second();
  if (second_ == &::google::protobuf::internal::kEmptyString) {
    second_ = new ::std::string;
  }
  return second_;
}
inline ::std::string* BytesBytesPair::release_second() {
  clear_has_second();
  if (second_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = second_;
    second_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BytesBytesPair::set_allocated_second(::std::string* second) {
  if (second_ != &::google::protobuf::internal::kEmptyString) {
    delete second_;
  }
  if (second) {
    set_has_second();
    second_ = second;
  } else {
    clear_has_second();
    second_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameInt64Pair

// optional string name = 1;
inline bool NameInt64Pair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameInt64Pair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameInt64Pair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameInt64Pair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameInt64Pair::name() const {
  return *name_;
}
inline void NameInt64Pair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameInt64Pair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameInt64Pair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameInt64Pair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameInt64Pair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameInt64Pair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 value = 2;
inline bool NameInt64Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameInt64Pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameInt64Pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameInt64Pair::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 NameInt64Pair::value() const {
  return value_;
}
inline void NameInt64Pair::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SnapshotDescription

// required string name = 1;
inline bool SnapshotDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapshotDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapshotDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapshotDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SnapshotDescription::name() const {
  return *name_;
}
inline void SnapshotDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SnapshotDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SnapshotDescription::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapshotDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SnapshotDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapshotDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string table = 2;
inline bool SnapshotDescription::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapshotDescription::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapshotDescription::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapshotDescription::clear_table() {
  if (table_ != &::google::protobuf::internal::kEmptyString) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& SnapshotDescription::table() const {
  return *table_;
}
inline void SnapshotDescription::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(value);
}
inline void SnapshotDescription::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(value);
}
inline void SnapshotDescription::set_table(const char* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapshotDescription::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  return table_;
}
inline ::std::string* SnapshotDescription::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapshotDescription::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::kEmptyString) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 creation_time = 3 [default = 0];
inline bool SnapshotDescription::has_creation_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnapshotDescription::set_has_creation_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnapshotDescription::clear_has_creation_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnapshotDescription::clear_creation_time() {
  creation_time_ = GOOGLE_LONGLONG(0);
  clear_has_creation_time();
}
inline ::google::protobuf::int64 SnapshotDescription::creation_time() const {
  return creation_time_;
}
inline void SnapshotDescription::set_creation_time(::google::protobuf::int64 value) {
  set_has_creation_time();
  creation_time_ = value;
}

// optional .hbase.pb.SnapshotDescription.Type type = 4 [default = FLUSH];
inline bool SnapshotDescription::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnapshotDescription::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnapshotDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnapshotDescription::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hbase::pb::SnapshotDescription_Type SnapshotDescription::type() const {
  return static_cast< ::hbase::pb::SnapshotDescription_Type >(type_);
}
inline void SnapshotDescription::set_type(::hbase::pb::SnapshotDescription_Type value) {
  assert(::hbase::pb::SnapshotDescription_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 version = 5;
inline bool SnapshotDescription::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnapshotDescription::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SnapshotDescription::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SnapshotDescription::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 SnapshotDescription::version() const {
  return version_;
}
inline void SnapshotDescription::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string owner = 6;
inline bool SnapshotDescription::has_owner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SnapshotDescription::set_has_owner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SnapshotDescription::clear_has_owner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SnapshotDescription::clear_owner() {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    owner_->clear();
  }
  clear_has_owner();
}
inline const ::std::string& SnapshotDescription::owner() const {
  return *owner_;
}
inline void SnapshotDescription::set_owner(const ::std::string& value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void SnapshotDescription::set_owner(const char* value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void SnapshotDescription::set_owner(const char* value, size_t size) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapshotDescription::mutable_owner() {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  return owner_;
}
inline ::std::string* SnapshotDescription::release_owner() {
  clear_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_;
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapshotDescription::set_allocated_owner(::std::string* owner) {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (owner) {
    set_has_owner();
    owner_ = owner;
  } else {
    clear_has_owner();
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProcedureDescription

// required string signature = 1;
inline bool ProcedureDescription::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcedureDescription::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcedureDescription::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcedureDescription::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ProcedureDescription::signature() const {
  return *signature_;
}
inline void ProcedureDescription::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void ProcedureDescription::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void ProcedureDescription::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcedureDescription::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* ProcedureDescription::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcedureDescription::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string instance = 2;
inline bool ProcedureDescription::has_instance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcedureDescription::set_has_instance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcedureDescription::clear_has_instance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcedureDescription::clear_instance() {
  if (instance_ != &::google::protobuf::internal::kEmptyString) {
    instance_->clear();
  }
  clear_has_instance();
}
inline const ::std::string& ProcedureDescription::instance() const {
  return *instance_;
}
inline void ProcedureDescription::set_instance(const ::std::string& value) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::kEmptyString) {
    instance_ = new ::std::string;
  }
  instance_->assign(value);
}
inline void ProcedureDescription::set_instance(const char* value) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::kEmptyString) {
    instance_ = new ::std::string;
  }
  instance_->assign(value);
}
inline void ProcedureDescription::set_instance(const char* value, size_t size) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::kEmptyString) {
    instance_ = new ::std::string;
  }
  instance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcedureDescription::mutable_instance() {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::kEmptyString) {
    instance_ = new ::std::string;
  }
  return instance_;
}
inline ::std::string* ProcedureDescription::release_instance() {
  clear_has_instance();
  if (instance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instance_;
    instance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcedureDescription::set_allocated_instance(::std::string* instance) {
  if (instance_ != &::google::protobuf::internal::kEmptyString) {
    delete instance_;
  }
  if (instance) {
    set_has_instance();
    instance_ = instance;
  } else {
    clear_has_instance();
    instance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 creation_time = 3 [default = 0];
inline bool ProcedureDescription::has_creation_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcedureDescription::set_has_creation_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcedureDescription::clear_has_creation_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcedureDescription::clear_creation_time() {
  creation_time_ = GOOGLE_LONGLONG(0);
  clear_has_creation_time();
}
inline ::google::protobuf::int64 ProcedureDescription::creation_time() const {
  return creation_time_;
}
inline void ProcedureDescription::set_creation_time(::google::protobuf::int64 value) {
  set_has_creation_time();
  creation_time_ = value;
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int ProcedureDescription::configuration_size() const {
  return configuration_.size();
}
inline void ProcedureDescription::clear_configuration() {
  configuration_.Clear();
}
inline const ::hbase::pb::NameStringPair& ProcedureDescription::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ProcedureDescription::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::hbase::pb::NameStringPair* ProcedureDescription::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ProcedureDescription::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ProcedureDescription::mutable_configuration() {
  return &configuration_;
}

// -------------------------------------------------------------------

// EmptyMsg

// -------------------------------------------------------------------

// LongMsg

// required int64 long_msg = 1;
inline bool LongMsg::has_long_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LongMsg::set_has_long_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LongMsg::clear_has_long_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LongMsg::clear_long_msg() {
  long_msg_ = GOOGLE_LONGLONG(0);
  clear_has_long_msg();
}
inline ::google::protobuf::int64 LongMsg::long_msg() const {
  return long_msg_;
}
inline void LongMsg::set_long_msg(::google::protobuf::int64 value) {
  set_has_long_msg();
  long_msg_ = value;
}

// -------------------------------------------------------------------

// DoubleMsg

// required double double_msg = 1;
inline bool DoubleMsg::has_double_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleMsg::set_has_double_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleMsg::clear_has_double_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleMsg::clear_double_msg() {
  double_msg_ = 0;
  clear_has_double_msg();
}
inline double DoubleMsg::double_msg() const {
  return double_msg_;
}
inline void DoubleMsg::set_double_msg(double value) {
  set_has_double_msg();
  double_msg_ = value;
}

// -------------------------------------------------------------------

// BigDecimalMsg

// required bytes bigdecimal_msg = 1;
inline bool BigDecimalMsg::has_bigdecimal_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigDecimalMsg::set_has_bigdecimal_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigDecimalMsg::clear_has_bigdecimal_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigDecimalMsg::clear_bigdecimal_msg() {
  if (bigdecimal_msg_ != &::google::protobuf::internal::kEmptyString) {
    bigdecimal_msg_->clear();
  }
  clear_has_bigdecimal_msg();
}
inline const ::std::string& BigDecimalMsg::bigdecimal_msg() const {
  return *bigdecimal_msg_;
}
inline void BigDecimalMsg::set_bigdecimal_msg(const ::std::string& value) {
  set_has_bigdecimal_msg();
  if (bigdecimal_msg_ == &::google::protobuf::internal::kEmptyString) {
    bigdecimal_msg_ = new ::std::string;
  }
  bigdecimal_msg_->assign(value);
}
inline void BigDecimalMsg::set_bigdecimal_msg(const char* value) {
  set_has_bigdecimal_msg();
  if (bigdecimal_msg_ == &::google::protobuf::internal::kEmptyString) {
    bigdecimal_msg_ = new ::std::string;
  }
  bigdecimal_msg_->assign(value);
}
inline void BigDecimalMsg::set_bigdecimal_msg(const void* value, size_t size) {
  set_has_bigdecimal_msg();
  if (bigdecimal_msg_ == &::google::protobuf::internal::kEmptyString) {
    bigdecimal_msg_ = new ::std::string;
  }
  bigdecimal_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigDecimalMsg::mutable_bigdecimal_msg() {
  set_has_bigdecimal_msg();
  if (bigdecimal_msg_ == &::google::protobuf::internal::kEmptyString) {
    bigdecimal_msg_ = new ::std::string;
  }
  return bigdecimal_msg_;
}
inline ::std::string* BigDecimalMsg::release_bigdecimal_msg() {
  clear_has_bigdecimal_msg();
  if (bigdecimal_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bigdecimal_msg_;
    bigdecimal_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BigDecimalMsg::set_allocated_bigdecimal_msg(::std::string* bigdecimal_msg) {
  if (bigdecimal_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete bigdecimal_msg_;
  }
  if (bigdecimal_msg) {
    set_has_bigdecimal_msg();
    bigdecimal_msg_ = bigdecimal_msg;
  } else {
    clear_has_bigdecimal_msg();
    bigdecimal_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UUID

// required uint64 least_sig_bits = 1;
inline bool UUID::has_least_sig_bits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UUID::set_has_least_sig_bits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UUID::clear_has_least_sig_bits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UUID::clear_least_sig_bits() {
  least_sig_bits_ = GOOGLE_ULONGLONG(0);
  clear_has_least_sig_bits();
}
inline ::google::protobuf::uint64 UUID::least_sig_bits() const {
  return least_sig_bits_;
}
inline void UUID::set_least_sig_bits(::google::protobuf::uint64 value) {
  set_has_least_sig_bits();
  least_sig_bits_ = value;
}

// required uint64 most_sig_bits = 2;
inline bool UUID::has_most_sig_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UUID::set_has_most_sig_bits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UUID::clear_has_most_sig_bits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UUID::clear_most_sig_bits() {
  most_sig_bits_ = GOOGLE_ULONGLONG(0);
  clear_has_most_sig_bits();
}
inline ::google::protobuf::uint64 UUID::most_sig_bits() const {
  return most_sig_bits_;
}
inline void UUID::set_most_sig_bits(::google::protobuf::uint64 value) {
  set_has_most_sig_bits();
  most_sig_bits_ = value;
}

// -------------------------------------------------------------------

// NamespaceDescriptor

// required bytes name = 1;
inline bool NamespaceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamespaceDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamespaceDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamespaceDescriptor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NamespaceDescriptor::name() const {
  return *name_;
}
inline void NamespaceDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamespaceDescriptor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamespaceDescriptor::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NamespaceDescriptor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NamespaceDescriptor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NamespaceDescriptor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.NameStringPair configuration = 2;
inline int NamespaceDescriptor::configuration_size() const {
  return configuration_.size();
}
inline void NamespaceDescriptor::clear_configuration() {
  configuration_.Clear();
}
inline const ::hbase::pb::NameStringPair& NamespaceDescriptor::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* NamespaceDescriptor::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::hbase::pb::NameStringPair* NamespaceDescriptor::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >&
NamespaceDescriptor::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameStringPair >*
NamespaceDescriptor::mutable_configuration() {
  return &configuration_;
}

// -------------------------------------------------------------------

// VersionInfo

// required string version = 1;
inline bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& VersionInfo::version() const {
  return *version_;
}
inline void VersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* VersionInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string url = 2;
inline bool VersionInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& VersionInfo::url() const {
  return *url_;
}
inline void VersionInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void VersionInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void VersionInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* VersionInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string revision = 3;
inline bool VersionInfo::has_revision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfo::set_has_revision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionInfo::clear_has_revision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionInfo::clear_revision() {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& VersionInfo::revision() const {
  return *revision_;
}
inline void VersionInfo::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void VersionInfo::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void VersionInfo::set_revision(const char* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  return revision_;
}
inline ::std::string* VersionInfo::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 4;
inline bool VersionInfo::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfo::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& VersionInfo::user() const {
  return *user_;
}
inline void VersionInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void VersionInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void VersionInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* VersionInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string date = 5;
inline bool VersionInfo::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfo::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VersionInfo::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VersionInfo::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& VersionInfo::date() const {
  return *date_;
}
inline void VersionInfo::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void VersionInfo::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void VersionInfo::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* VersionInfo::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string src_checksum = 6;
inline bool VersionInfo::has_src_checksum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VersionInfo::set_has_src_checksum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VersionInfo::clear_has_src_checksum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VersionInfo::clear_src_checksum() {
  if (src_checksum_ != &::google::protobuf::internal::kEmptyString) {
    src_checksum_->clear();
  }
  clear_has_src_checksum();
}
inline const ::std::string& VersionInfo::src_checksum() const {
  return *src_checksum_;
}
inline void VersionInfo::set_src_checksum(const ::std::string& value) {
  set_has_src_checksum();
  if (src_checksum_ == &::google::protobuf::internal::kEmptyString) {
    src_checksum_ = new ::std::string;
  }
  src_checksum_->assign(value);
}
inline void VersionInfo::set_src_checksum(const char* value) {
  set_has_src_checksum();
  if (src_checksum_ == &::google::protobuf::internal::kEmptyString) {
    src_checksum_ = new ::std::string;
  }
  src_checksum_->assign(value);
}
inline void VersionInfo::set_src_checksum(const char* value, size_t size) {
  set_has_src_checksum();
  if (src_checksum_ == &::google::protobuf::internal::kEmptyString) {
    src_checksum_ = new ::std::string;
  }
  src_checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_src_checksum() {
  set_has_src_checksum();
  if (src_checksum_ == &::google::protobuf::internal::kEmptyString) {
    src_checksum_ = new ::std::string;
  }
  return src_checksum_;
}
inline ::std::string* VersionInfo::release_src_checksum() {
  clear_has_src_checksum();
  if (src_checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_checksum_;
    src_checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionInfo::set_allocated_src_checksum(::std::string* src_checksum) {
  if (src_checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete src_checksum_;
  }
  if (src_checksum) {
    set_has_src_checksum();
    src_checksum_ = src_checksum;
  } else {
    clear_has_src_checksum();
    src_checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version_major = 7;
inline bool VersionInfo::has_version_major() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VersionInfo::set_has_version_major() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VersionInfo::clear_has_version_major() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VersionInfo::clear_version_major() {
  version_major_ = 0u;
  clear_has_version_major();
}
inline ::google::protobuf::uint32 VersionInfo::version_major() const {
  return version_major_;
}
inline void VersionInfo::set_version_major(::google::protobuf::uint32 value) {
  set_has_version_major();
  version_major_ = value;
}

// optional uint32 version_minor = 8;
inline bool VersionInfo::has_version_minor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VersionInfo::set_has_version_minor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VersionInfo::clear_has_version_minor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VersionInfo::clear_version_minor() {
  version_minor_ = 0u;
  clear_has_version_minor();
}
inline ::google::protobuf::uint32 VersionInfo::version_minor() const {
  return version_minor_;
}
inline void VersionInfo::set_version_minor(::google::protobuf::uint32 value) {
  set_has_version_minor();
  version_minor_ = value;
}

// -------------------------------------------------------------------

// RegionServerInfo

// optional int32 infoPort = 1;
inline bool RegionServerInfo::has_infoport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionServerInfo::set_has_infoport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionServerInfo::clear_has_infoport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionServerInfo::clear_infoport() {
  infoport_ = 0;
  clear_has_infoport();
}
inline ::google::protobuf::int32 RegionServerInfo::infoport() const {
  return infoport_;
}
inline void RegionServerInfo::set_infoport(::google::protobuf::int32 value) {
  set_has_infoport();
  infoport_ = value;
}

// optional .hbase.pb.VersionInfo version_info = 2;
inline bool RegionServerInfo::has_version_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionServerInfo::set_has_version_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionServerInfo::clear_has_version_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionServerInfo::clear_version_info() {
  if (version_info_ != NULL) version_info_->::hbase::pb::VersionInfo::Clear();
  clear_has_version_info();
}
inline const ::hbase::pb::VersionInfo& RegionServerInfo::version_info() const {
  return version_info_ != NULL ? *version_info_ : *default_instance_->version_info_;
}
inline ::hbase::pb::VersionInfo* RegionServerInfo::mutable_version_info() {
  set_has_version_info();
  if (version_info_ == NULL) version_info_ = new ::hbase::pb::VersionInfo;
  return version_info_;
}
inline ::hbase::pb::VersionInfo* RegionServerInfo::release_version_info() {
  clear_has_version_info();
  ::hbase::pb::VersionInfo* temp = version_info_;
  version_info_ = NULL;
  return temp;
}
inline void RegionServerInfo::set_allocated_version_info(::hbase::pb::VersionInfo* version_info) {
  delete version_info_;
  version_info_ = version_info;
  if (version_info) {
    set_has_version_info();
  } else {
    clear_has_version_info();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::TableState_State>() {
  return ::hbase::pb::TableState_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::RegionSpecifier_RegionSpecifierType>() {
  return ::hbase::pb::RegionSpecifier_RegionSpecifierType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SnapshotDescription_Type>() {
  return ::hbase::pb::SnapshotDescription_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::CompareType>() {
  return ::hbase::pb::CompareType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::TimeUnit>() {
  return ::hbase::pb::TimeUnit_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HBase_2eproto__INCLUDED
