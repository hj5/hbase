// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SecureBulkLoad.proto

#ifndef PROTOBUF_SecureBulkLoad_2eproto__INCLUDED
#define PROTOBUF_SecureBulkLoad_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Client.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SecureBulkLoad_2eproto();
void protobuf_AssignDesc_SecureBulkLoad_2eproto();
void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

class SecureBulkLoadHFilesRequest;
class SecureBulkLoadHFilesResponse;
class DelegationToken;
class PrepareBulkLoadRequest;
class PrepareBulkLoadResponse;
class CleanupBulkLoadRequest;
class CleanupBulkLoadResponse;

// ===================================================================

class SecureBulkLoadHFilesRequest : public ::google::protobuf::Message {
 public:
  SecureBulkLoadHFilesRequest();
  virtual ~SecureBulkLoadHFilesRequest();

  SecureBulkLoadHFilesRequest(const SecureBulkLoadHFilesRequest& from);

  inline SecureBulkLoadHFilesRequest& operator=(const SecureBulkLoadHFilesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecureBulkLoadHFilesRequest& default_instance();

  void Swap(SecureBulkLoadHFilesRequest* other);

  // implements Message ----------------------------------------------

  SecureBulkLoadHFilesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecureBulkLoadHFilesRequest& from);
  void MergeFrom(const SecureBulkLoadHFilesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 1;
  inline int family_path_size() const;
  inline void clear_family_path();
  static const int kFamilyPathFieldNumber = 1;
  inline const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& family_path(int index) const;
  inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* mutable_family_path(int index);
  inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* add_family_path();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
      family_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
      mutable_family_path();

  // optional bool assign_seq_num = 2;
  inline bool has_assign_seq_num() const;
  inline void clear_assign_seq_num();
  static const int kAssignSeqNumFieldNumber = 2;
  inline bool assign_seq_num() const;
  inline void set_assign_seq_num(bool value);

  // required .hbase.pb.DelegationToken fs_token = 3;
  inline bool has_fs_token() const;
  inline void clear_fs_token();
  static const int kFsTokenFieldNumber = 3;
  inline const ::hbase::pb::DelegationToken& fs_token() const;
  inline ::hbase::pb::DelegationToken* mutable_fs_token();
  inline ::hbase::pb::DelegationToken* release_fs_token();
  inline void set_allocated_fs_token(::hbase::pb::DelegationToken* fs_token);

  // required string bulk_token = 4;
  inline bool has_bulk_token() const;
  inline void clear_bulk_token();
  static const int kBulkTokenFieldNumber = 4;
  inline const ::std::string& bulk_token() const;
  inline void set_bulk_token(const ::std::string& value);
  inline void set_bulk_token(const char* value);
  inline void set_bulk_token(const char* value, size_t size);
  inline ::std::string* mutable_bulk_token();
  inline ::std::string* release_bulk_token();
  inline void set_allocated_bulk_token(::std::string* bulk_token);

  // @@protoc_insertion_point(class_scope:hbase.pb.SecureBulkLoadHFilesRequest)
 private:
  inline void set_has_assign_seq_num();
  inline void clear_has_assign_seq_num();
  inline void set_has_fs_token();
  inline void clear_has_fs_token();
  inline void set_has_bulk_token();
  inline void clear_has_bulk_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath > family_path_;
  ::hbase::pb::DelegationToken* fs_token_;
  ::std::string* bulk_token_;
  bool assign_seq_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static SecureBulkLoadHFilesRequest* default_instance_;
};
// -------------------------------------------------------------------

class SecureBulkLoadHFilesResponse : public ::google::protobuf::Message {
 public:
  SecureBulkLoadHFilesResponse();
  virtual ~SecureBulkLoadHFilesResponse();

  SecureBulkLoadHFilesResponse(const SecureBulkLoadHFilesResponse& from);

  inline SecureBulkLoadHFilesResponse& operator=(const SecureBulkLoadHFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecureBulkLoadHFilesResponse& default_instance();

  void Swap(SecureBulkLoadHFilesResponse* other);

  // implements Message ----------------------------------------------

  SecureBulkLoadHFilesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecureBulkLoadHFilesResponse& from);
  void MergeFrom(const SecureBulkLoadHFilesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool loaded = 1;
  inline bool has_loaded() const;
  inline void clear_loaded();
  static const int kLoadedFieldNumber = 1;
  inline bool loaded() const;
  inline void set_loaded(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SecureBulkLoadHFilesResponse)
 private:
  inline void set_has_loaded();
  inline void clear_has_loaded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool loaded_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static SecureBulkLoadHFilesResponse* default_instance_;
};
// -------------------------------------------------------------------

class DelegationToken : public ::google::protobuf::Message {
 public:
  DelegationToken();
  virtual ~DelegationToken();

  DelegationToken(const DelegationToken& from);

  inline DelegationToken& operator=(const DelegationToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelegationToken& default_instance();

  void Swap(DelegationToken* other);

  // implements Message ----------------------------------------------

  DelegationToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelegationToken& from);
  void MergeFrom(const DelegationToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const void* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  inline void set_allocated_identifier(::std::string* identifier);

  // optional bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string kind = 3;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 3;
  inline const ::std::string& kind() const;
  inline void set_kind(const ::std::string& value);
  inline void set_kind(const char* value);
  inline void set_kind(const char* value, size_t size);
  inline ::std::string* mutable_kind();
  inline ::std::string* release_kind();
  inline void set_allocated_kind(::std::string* kind);

  // optional string service = 4;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 4;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  inline void set_allocated_service(::std::string* service);

  // @@protoc_insertion_point(class_scope:hbase.pb.DelegationToken)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_service();
  inline void clear_has_service();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* identifier_;
  ::std::string* password_;
  ::std::string* kind_;
  ::std::string* service_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static DelegationToken* default_instance_;
};
// -------------------------------------------------------------------

class PrepareBulkLoadRequest : public ::google::protobuf::Message {
 public:
  PrepareBulkLoadRequest();
  virtual ~PrepareBulkLoadRequest();

  PrepareBulkLoadRequest(const PrepareBulkLoadRequest& from);

  inline PrepareBulkLoadRequest& operator=(const PrepareBulkLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareBulkLoadRequest& default_instance();

  void Swap(PrepareBulkLoadRequest* other);

  // implements Message ----------------------------------------------

  PrepareBulkLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepareBulkLoadRequest& from);
  void MergeFrom(const PrepareBulkLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.TableName table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::hbase::pb::TableName& table_name() const;
  inline ::hbase::pb::TableName* mutable_table_name();
  inline ::hbase::pb::TableName* release_table_name();
  inline void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrepareBulkLoadRequest)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TableName* table_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static PrepareBulkLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class PrepareBulkLoadResponse : public ::google::protobuf::Message {
 public:
  PrepareBulkLoadResponse();
  virtual ~PrepareBulkLoadResponse();

  PrepareBulkLoadResponse(const PrepareBulkLoadResponse& from);

  inline PrepareBulkLoadResponse& operator=(const PrepareBulkLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareBulkLoadResponse& default_instance();

  void Swap(PrepareBulkLoadResponse* other);

  // implements Message ----------------------------------------------

  PrepareBulkLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepareBulkLoadResponse& from);
  void MergeFrom(const PrepareBulkLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bulk_token = 1;
  inline bool has_bulk_token() const;
  inline void clear_bulk_token();
  static const int kBulkTokenFieldNumber = 1;
  inline const ::std::string& bulk_token() const;
  inline void set_bulk_token(const ::std::string& value);
  inline void set_bulk_token(const char* value);
  inline void set_bulk_token(const char* value, size_t size);
  inline ::std::string* mutable_bulk_token();
  inline ::std::string* release_bulk_token();
  inline void set_allocated_bulk_token(::std::string* bulk_token);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrepareBulkLoadResponse)
 private:
  inline void set_has_bulk_token();
  inline void clear_has_bulk_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bulk_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static PrepareBulkLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class CleanupBulkLoadRequest : public ::google::protobuf::Message {
 public:
  CleanupBulkLoadRequest();
  virtual ~CleanupBulkLoadRequest();

  CleanupBulkLoadRequest(const CleanupBulkLoadRequest& from);

  inline CleanupBulkLoadRequest& operator=(const CleanupBulkLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupBulkLoadRequest& default_instance();

  void Swap(CleanupBulkLoadRequest* other);

  // implements Message ----------------------------------------------

  CleanupBulkLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupBulkLoadRequest& from);
  void MergeFrom(const CleanupBulkLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bulk_token = 1;
  inline bool has_bulk_token() const;
  inline void clear_bulk_token();
  static const int kBulkTokenFieldNumber = 1;
  inline const ::std::string& bulk_token() const;
  inline void set_bulk_token(const ::std::string& value);
  inline void set_bulk_token(const char* value);
  inline void set_bulk_token(const char* value, size_t size);
  inline ::std::string* mutable_bulk_token();
  inline ::std::string* release_bulk_token();
  inline void set_allocated_bulk_token(::std::string* bulk_token);

  // @@protoc_insertion_point(class_scope:hbase.pb.CleanupBulkLoadRequest)
 private:
  inline void set_has_bulk_token();
  inline void clear_has_bulk_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bulk_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static CleanupBulkLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class CleanupBulkLoadResponse : public ::google::protobuf::Message {
 public:
  CleanupBulkLoadResponse();
  virtual ~CleanupBulkLoadResponse();

  CleanupBulkLoadResponse(const CleanupBulkLoadResponse& from);

  inline CleanupBulkLoadResponse& operator=(const CleanupBulkLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupBulkLoadResponse& default_instance();

  void Swap(CleanupBulkLoadResponse* other);

  // implements Message ----------------------------------------------

  CleanupBulkLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupBulkLoadResponse& from);
  void MergeFrom(const CleanupBulkLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.CleanupBulkLoadResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SecureBulkLoad_2eproto();
  friend void protobuf_AssignDesc_SecureBulkLoad_2eproto();
  friend void protobuf_ShutdownFile_SecureBulkLoad_2eproto();

  void InitAsDefaultInstance();
  static CleanupBulkLoadResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// SecureBulkLoadHFilesRequest

// repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 1;
inline int SecureBulkLoadHFilesRequest::family_path_size() const {
  return family_path_.size();
}
inline void SecureBulkLoadHFilesRequest::clear_family_path() {
  family_path_.Clear();
}
inline const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& SecureBulkLoadHFilesRequest::family_path(int index) const {
  return family_path_.Get(index);
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* SecureBulkLoadHFilesRequest::mutable_family_path(int index) {
  return family_path_.Mutable(index);
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* SecureBulkLoadHFilesRequest::add_family_path() {
  return family_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
SecureBulkLoadHFilesRequest::family_path() const {
  return family_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
SecureBulkLoadHFilesRequest::mutable_family_path() {
  return &family_path_;
}

// optional bool assign_seq_num = 2;
inline bool SecureBulkLoadHFilesRequest::has_assign_seq_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecureBulkLoadHFilesRequest::set_has_assign_seq_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecureBulkLoadHFilesRequest::clear_has_assign_seq_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecureBulkLoadHFilesRequest::clear_assign_seq_num() {
  assign_seq_num_ = false;
  clear_has_assign_seq_num();
}
inline bool SecureBulkLoadHFilesRequest::assign_seq_num() const {
  return assign_seq_num_;
}
inline void SecureBulkLoadHFilesRequest::set_assign_seq_num(bool value) {
  set_has_assign_seq_num();
  assign_seq_num_ = value;
}

// required .hbase.pb.DelegationToken fs_token = 3;
inline bool SecureBulkLoadHFilesRequest::has_fs_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecureBulkLoadHFilesRequest::set_has_fs_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecureBulkLoadHFilesRequest::clear_has_fs_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecureBulkLoadHFilesRequest::clear_fs_token() {
  if (fs_token_ != NULL) fs_token_->::hbase::pb::DelegationToken::Clear();
  clear_has_fs_token();
}
inline const ::hbase::pb::DelegationToken& SecureBulkLoadHFilesRequest::fs_token() const {
  return fs_token_ != NULL ? *fs_token_ : *default_instance_->fs_token_;
}
inline ::hbase::pb::DelegationToken* SecureBulkLoadHFilesRequest::mutable_fs_token() {
  set_has_fs_token();
  if (fs_token_ == NULL) fs_token_ = new ::hbase::pb::DelegationToken;
  return fs_token_;
}
inline ::hbase::pb::DelegationToken* SecureBulkLoadHFilesRequest::release_fs_token() {
  clear_has_fs_token();
  ::hbase::pb::DelegationToken* temp = fs_token_;
  fs_token_ = NULL;
  return temp;
}
inline void SecureBulkLoadHFilesRequest::set_allocated_fs_token(::hbase::pb::DelegationToken* fs_token) {
  delete fs_token_;
  fs_token_ = fs_token;
  if (fs_token) {
    set_has_fs_token();
  } else {
    clear_has_fs_token();
  }
}

// required string bulk_token = 4;
inline bool SecureBulkLoadHFilesRequest::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecureBulkLoadHFilesRequest::set_has_bulk_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecureBulkLoadHFilesRequest::clear_has_bulk_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecureBulkLoadHFilesRequest::clear_bulk_token() {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    bulk_token_->clear();
  }
  clear_has_bulk_token();
}
inline const ::std::string& SecureBulkLoadHFilesRequest::bulk_token() const {
  return *bulk_token_;
}
inline void SecureBulkLoadHFilesRequest::set_bulk_token(const ::std::string& value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void SecureBulkLoadHFilesRequest::set_bulk_token(const char* value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void SecureBulkLoadHFilesRequest::set_bulk_token(const char* value, size_t size) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureBulkLoadHFilesRequest::mutable_bulk_token() {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  return bulk_token_;
}
inline ::std::string* SecureBulkLoadHFilesRequest::release_bulk_token() {
  clear_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulk_token_;
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecureBulkLoadHFilesRequest::set_allocated_bulk_token(::std::string* bulk_token) {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    delete bulk_token_;
  }
  if (bulk_token) {
    set_has_bulk_token();
    bulk_token_ = bulk_token;
  } else {
    clear_has_bulk_token();
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SecureBulkLoadHFilesResponse

// required bool loaded = 1;
inline bool SecureBulkLoadHFilesResponse::has_loaded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecureBulkLoadHFilesResponse::set_has_loaded() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecureBulkLoadHFilesResponse::clear_has_loaded() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecureBulkLoadHFilesResponse::clear_loaded() {
  loaded_ = false;
  clear_has_loaded();
}
inline bool SecureBulkLoadHFilesResponse::loaded() const {
  return loaded_;
}
inline void SecureBulkLoadHFilesResponse::set_loaded(bool value) {
  set_has_loaded();
  loaded_ = value;
}

// -------------------------------------------------------------------

// DelegationToken

// optional bytes identifier = 1;
inline bool DelegationToken::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelegationToken::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelegationToken::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelegationToken::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& DelegationToken::identifier() const {
  return *identifier_;
}
inline void DelegationToken::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void DelegationToken::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void DelegationToken::set_identifier(const void* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DelegationToken::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* DelegationToken::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DelegationToken::set_allocated_identifier(::std::string* identifier) {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (identifier) {
    set_has_identifier();
    identifier_ = identifier;
  } else {
    clear_has_identifier();
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes password = 2;
inline bool DelegationToken::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelegationToken::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelegationToken::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelegationToken::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& DelegationToken::password() const {
  return *password_;
}
inline void DelegationToken::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void DelegationToken::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void DelegationToken::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DelegationToken::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* DelegationToken::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DelegationToken::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string kind = 3;
inline bool DelegationToken::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DelegationToken::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DelegationToken::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DelegationToken::clear_kind() {
  if (kind_ != &::google::protobuf::internal::kEmptyString) {
    kind_->clear();
  }
  clear_has_kind();
}
inline const ::std::string& DelegationToken::kind() const {
  return *kind_;
}
inline void DelegationToken::set_kind(const ::std::string& value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void DelegationToken::set_kind(const char* value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void DelegationToken::set_kind(const char* value, size_t size) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DelegationToken::mutable_kind() {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  return kind_;
}
inline ::std::string* DelegationToken::release_kind() {
  clear_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kind_;
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DelegationToken::set_allocated_kind(::std::string* kind) {
  if (kind_ != &::google::protobuf::internal::kEmptyString) {
    delete kind_;
  }
  if (kind) {
    set_has_kind();
    kind_ = kind;
  } else {
    clear_has_kind();
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string service = 4;
inline bool DelegationToken::has_service() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DelegationToken::set_has_service() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DelegationToken::clear_has_service() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DelegationToken::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& DelegationToken::service() const {
  return *service_;
}
inline void DelegationToken::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void DelegationToken::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void DelegationToken::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DelegationToken::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* DelegationToken::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DelegationToken::set_allocated_service(::std::string* service) {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    delete service_;
  }
  if (service) {
    set_has_service();
    service_ = service;
  } else {
    clear_has_service();
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PrepareBulkLoadRequest

// required .hbase.pb.TableName table_name = 1;
inline bool PrepareBulkLoadRequest::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareBulkLoadRequest::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepareBulkLoadRequest::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepareBulkLoadRequest::clear_table_name() {
  if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
  clear_has_table_name();
}
inline const ::hbase::pb::TableName& PrepareBulkLoadRequest::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::hbase::pb::TableName* PrepareBulkLoadRequest::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::hbase::pb::TableName;
  return table_name_;
}
inline ::hbase::pb::TableName* PrepareBulkLoadRequest::release_table_name() {
  clear_has_table_name();
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void PrepareBulkLoadRequest::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
}

// -------------------------------------------------------------------

// PrepareBulkLoadResponse

// required string bulk_token = 1;
inline bool PrepareBulkLoadResponse::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareBulkLoadResponse::set_has_bulk_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepareBulkLoadResponse::clear_has_bulk_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepareBulkLoadResponse::clear_bulk_token() {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    bulk_token_->clear();
  }
  clear_has_bulk_token();
}
inline const ::std::string& PrepareBulkLoadResponse::bulk_token() const {
  return *bulk_token_;
}
inline void PrepareBulkLoadResponse::set_bulk_token(const ::std::string& value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void PrepareBulkLoadResponse::set_bulk_token(const char* value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void PrepareBulkLoadResponse::set_bulk_token(const char* value, size_t size) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrepareBulkLoadResponse::mutable_bulk_token() {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  return bulk_token_;
}
inline ::std::string* PrepareBulkLoadResponse::release_bulk_token() {
  clear_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulk_token_;
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrepareBulkLoadResponse::set_allocated_bulk_token(::std::string* bulk_token) {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    delete bulk_token_;
  }
  if (bulk_token) {
    set_has_bulk_token();
    bulk_token_ = bulk_token;
  } else {
    clear_has_bulk_token();
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CleanupBulkLoadRequest

// required string bulk_token = 1;
inline bool CleanupBulkLoadRequest::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanupBulkLoadRequest::set_has_bulk_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanupBulkLoadRequest::clear_has_bulk_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanupBulkLoadRequest::clear_bulk_token() {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    bulk_token_->clear();
  }
  clear_has_bulk_token();
}
inline const ::std::string& CleanupBulkLoadRequest::bulk_token() const {
  return *bulk_token_;
}
inline void CleanupBulkLoadRequest::set_bulk_token(const ::std::string& value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void CleanupBulkLoadRequest::set_bulk_token(const char* value) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(value);
}
inline void CleanupBulkLoadRequest::set_bulk_token(const char* value, size_t size) {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  bulk_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CleanupBulkLoadRequest::mutable_bulk_token() {
  set_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    bulk_token_ = new ::std::string;
  }
  return bulk_token_;
}
inline ::std::string* CleanupBulkLoadRequest::release_bulk_token() {
  clear_has_bulk_token();
  if (bulk_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulk_token_;
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CleanupBulkLoadRequest::set_allocated_bulk_token(::std::string* bulk_token) {
  if (bulk_token_ != &::google::protobuf::internal::kEmptyString) {
    delete bulk_token_;
  }
  if (bulk_token) {
    set_has_bulk_token();
    bulk_token_ = bulk_token;
  } else {
    clear_has_bulk_token();
    bulk_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CleanupBulkLoadResponse


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SecureBulkLoad_2eproto__INCLUDED
