// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AccessControl.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "AccessControl.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* Permission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Permission_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Permission_Action_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Permission_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TablePermission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TablePermission_reflection_ = NULL;
const ::google::protobuf::Descriptor* NamespacePermission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NamespacePermission_reflection_ = NULL;
const ::google::protobuf::Descriptor* GlobalPermission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GlobalPermission_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserPermission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserPermission_reflection_ = NULL;
const ::google::protobuf::Descriptor* UsersAndPermissions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UsersAndPermissions_reflection_ = NULL;
const ::google::protobuf::Descriptor* UsersAndPermissions_UserPermissions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UsersAndPermissions_UserPermissions_reflection_ = NULL;
const ::google::protobuf::Descriptor* GrantRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GrantRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GrantResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GrantResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RevokeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RevokeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RevokeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RevokeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetUserPermissionsRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetUserPermissionsRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetUserPermissionsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetUserPermissionsResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckPermissionsRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckPermissionsRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckPermissionsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckPermissionsResponse_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_AccessControl_2eproto() {
  protobuf_AddDesc_AccessControl_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "AccessControl.proto");
  GOOGLE_CHECK(file != NULL);
  Permission_descriptor_ = file->message_type(0);
  static const int Permission_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, global_permission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, namespace_permission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, table_permission_),
  };
  Permission_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Permission_descriptor_,
      Permission::default_instance_,
      Permission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Permission, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Permission));
  Permission_Action_descriptor_ = Permission_descriptor_->enum_type(0);
  Permission_Type_descriptor_ = Permission_descriptor_->enum_type(1);
  TablePermission_descriptor_ = file->message_type(1);
  static const int TablePermission_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, family_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, qualifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, action_),
  };
  TablePermission_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TablePermission_descriptor_,
      TablePermission::default_instance_,
      TablePermission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TablePermission, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TablePermission));
  NamespacePermission_descriptor_ = file->message_type(2);
  static const int NamespacePermission_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespacePermission, namespace_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespacePermission, action_),
  };
  NamespacePermission_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NamespacePermission_descriptor_,
      NamespacePermission::default_instance_,
      NamespacePermission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespacePermission, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespacePermission, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NamespacePermission));
  GlobalPermission_descriptor_ = file->message_type(3);
  static const int GlobalPermission_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GlobalPermission, action_),
  };
  GlobalPermission_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GlobalPermission_descriptor_,
      GlobalPermission::default_instance_,
      GlobalPermission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GlobalPermission, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GlobalPermission, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GlobalPermission));
  UserPermission_descriptor_ = file->message_type(4);
  static const int UserPermission_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermission, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermission, permission_),
  };
  UserPermission_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserPermission_descriptor_,
      UserPermission::default_instance_,
      UserPermission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermission, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermission, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserPermission));
  UsersAndPermissions_descriptor_ = file->message_type(5);
  static const int UsersAndPermissions_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions, user_permissions_),
  };
  UsersAndPermissions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UsersAndPermissions_descriptor_,
      UsersAndPermissions::default_instance_,
      UsersAndPermissions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UsersAndPermissions));
  UsersAndPermissions_UserPermissions_descriptor_ = UsersAndPermissions_descriptor_->nested_type(0);
  static const int UsersAndPermissions_UserPermissions_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions_UserPermissions, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions_UserPermissions, permissions_),
  };
  UsersAndPermissions_UserPermissions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UsersAndPermissions_UserPermissions_descriptor_,
      UsersAndPermissions_UserPermissions::default_instance_,
      UsersAndPermissions_UserPermissions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions_UserPermissions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UsersAndPermissions_UserPermissions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UsersAndPermissions_UserPermissions));
  GrantRequest_descriptor_ = file->message_type(6);
  static const int GrantRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GrantRequest, user_permission_),
  };
  GrantRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GrantRequest_descriptor_,
      GrantRequest::default_instance_,
      GrantRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GrantRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GrantRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GrantRequest));
  GrantResponse_descriptor_ = file->message_type(7);
  static const int GrantResponse_offsets_[1] = {
  };
  GrantResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GrantResponse_descriptor_,
      GrantResponse::default_instance_,
      GrantResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GrantResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GrantResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GrantResponse));
  RevokeRequest_descriptor_ = file->message_type(8);
  static const int RevokeRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevokeRequest, user_permission_),
  };
  RevokeRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RevokeRequest_descriptor_,
      RevokeRequest::default_instance_,
      RevokeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevokeRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevokeRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RevokeRequest));
  RevokeResponse_descriptor_ = file->message_type(9);
  static const int RevokeResponse_offsets_[1] = {
  };
  RevokeResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RevokeResponse_descriptor_,
      RevokeResponse::default_instance_,
      RevokeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevokeResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevokeResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RevokeResponse));
  GetUserPermissionsRequest_descriptor_ = file->message_type(10);
  static const int GetUserPermissionsRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsRequest, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsRequest, namespace_name_),
  };
  GetUserPermissionsRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetUserPermissionsRequest_descriptor_,
      GetUserPermissionsRequest::default_instance_,
      GetUserPermissionsRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetUserPermissionsRequest));
  GetUserPermissionsResponse_descriptor_ = file->message_type(11);
  static const int GetUserPermissionsResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsResponse, user_permission_),
  };
  GetUserPermissionsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetUserPermissionsResponse_descriptor_,
      GetUserPermissionsResponse::default_instance_,
      GetUserPermissionsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserPermissionsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetUserPermissionsResponse));
  CheckPermissionsRequest_descriptor_ = file->message_type(12);
  static const int CheckPermissionsRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPermissionsRequest, permission_),
  };
  CheckPermissionsRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckPermissionsRequest_descriptor_,
      CheckPermissionsRequest::default_instance_,
      CheckPermissionsRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPermissionsRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPermissionsRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckPermissionsRequest));
  CheckPermissionsResponse_descriptor_ = file->message_type(13);
  static const int CheckPermissionsResponse_offsets_[1] = {
  };
  CheckPermissionsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckPermissionsResponse_descriptor_,
      CheckPermissionsResponse::default_instance_,
      CheckPermissionsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPermissionsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPermissionsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckPermissionsResponse));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_AccessControl_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Permission_descriptor_, &Permission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TablePermission_descriptor_, &TablePermission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NamespacePermission_descriptor_, &NamespacePermission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GlobalPermission_descriptor_, &GlobalPermission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserPermission_descriptor_, &UserPermission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UsersAndPermissions_descriptor_, &UsersAndPermissions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UsersAndPermissions_UserPermissions_descriptor_, &UsersAndPermissions_UserPermissions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GrantRequest_descriptor_, &GrantRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GrantResponse_descriptor_, &GrantResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RevokeRequest_descriptor_, &RevokeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RevokeResponse_descriptor_, &RevokeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetUserPermissionsRequest_descriptor_, &GetUserPermissionsRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetUserPermissionsResponse_descriptor_, &GetUserPermissionsResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckPermissionsRequest_descriptor_, &CheckPermissionsRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckPermissionsResponse_descriptor_, &CheckPermissionsResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_AccessControl_2eproto() {
  delete Permission::default_instance_;
  delete Permission_reflection_;
  delete TablePermission::default_instance_;
  delete TablePermission_reflection_;
  delete NamespacePermission::default_instance_;
  delete NamespacePermission_reflection_;
  delete GlobalPermission::default_instance_;
  delete GlobalPermission_reflection_;
  delete UserPermission::default_instance_;
  delete UserPermission_reflection_;
  delete UsersAndPermissions::default_instance_;
  delete UsersAndPermissions_reflection_;
  delete UsersAndPermissions_UserPermissions::default_instance_;
  delete UsersAndPermissions_UserPermissions_reflection_;
  delete GrantRequest::default_instance_;
  delete GrantRequest_reflection_;
  delete GrantResponse::default_instance_;
  delete GrantResponse_reflection_;
  delete RevokeRequest::default_instance_;
  delete RevokeRequest_reflection_;
  delete RevokeResponse::default_instance_;
  delete RevokeResponse_reflection_;
  delete GetUserPermissionsRequest::default_instance_;
  delete GetUserPermissionsRequest_reflection_;
  delete GetUserPermissionsResponse::default_instance_;
  delete GetUserPermissionsResponse_reflection_;
  delete CheckPermissionsRequest::default_instance_;
  delete CheckPermissionsRequest_reflection_;
  delete CheckPermissionsResponse::default_instance_;
  delete CheckPermissionsResponse_reflection_;
}

void protobuf_AddDesc_AccessControl_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hbase::pb::protobuf_AddDesc_HBase_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023AccessControl.proto\022\010hbase.pb\032\013HBase.p"
    "roto\"\314\002\n\nPermission\022\'\n\004type\030\001 \002(\0162\031.hbas"
    "e.pb.Permission.Type\0225\n\021global_permissio"
    "n\030\002 \001(\0132\032.hbase.pb.GlobalPermission\022;\n\024n"
    "amespace_permission\030\003 \001(\0132\035.hbase.pb.Nam"
    "espacePermission\0223\n\020table_permission\030\004 \001"
    "(\0132\031.hbase.pb.TablePermission\">\n\006Action\022"
    "\010\n\004READ\020\000\022\t\n\005WRITE\020\001\022\010\n\004EXEC\020\002\022\n\n\006CREATE"
    "\020\003\022\t\n\005ADMIN\020\004\",\n\004Type\022\n\n\006Global\020\001\022\r\n\tNam"
    "espace\020\002\022\t\n\005Table\020\003\"\212\001\n\017TablePermission\022"
    "\'\n\ntable_name\030\001 \001(\0132\023.hbase.pb.TableName"
    "\022\016\n\006family\030\002 \001(\014\022\021\n\tqualifier\030\003 \001(\014\022+\n\006a"
    "ction\030\004 \003(\0162\033.hbase.pb.Permission.Action"
    "\"Z\n\023NamespacePermission\022\026\n\016namespace_nam"
    "e\030\001 \001(\014\022+\n\006action\030\002 \003(\0162\033.hbase.pb.Permi"
    "ssion.Action\"\?\n\020GlobalPermission\022+\n\006acti"
    "on\030\001 \003(\0162\033.hbase.pb.Permission.Action\"H\n"
    "\016UserPermission\022\014\n\004user\030\001 \002(\014\022(\n\npermiss"
    "ion\030\003 \002(\0132\024.hbase.pb.Permission\"\252\001\n\023User"
    "sAndPermissions\022G\n\020user_permissions\030\001 \003("
    "\0132-.hbase.pb.UsersAndPermissions.UserPer"
    "missions\032J\n\017UserPermissions\022\014\n\004user\030\001 \002("
    "\014\022)\n\013permissions\030\002 \003(\0132\024.hbase.pb.Permis"
    "sion\"A\n\014GrantRequest\0221\n\017user_permission\030"
    "\001 \002(\0132\030.hbase.pb.UserPermission\"\017\n\rGrant"
    "Response\"B\n\rRevokeRequest\0221\n\017user_permis"
    "sion\030\001 \002(\0132\030.hbase.pb.UserPermission\"\020\n\016"
    "RevokeResponse\"\205\001\n\031GetUserPermissionsReq"
    "uest\022\'\n\004type\030\001 \001(\0162\031.hbase.pb.Permission"
    ".Type\022\'\n\ntable_name\030\002 \001(\0132\023.hbase.pb.Tab"
    "leName\022\026\n\016namespace_name\030\003 \001(\014\"O\n\032GetUse"
    "rPermissionsResponse\0221\n\017user_permission\030"
    "\001 \003(\0132\030.hbase.pb.UserPermission\"C\n\027Check"
    "PermissionsRequest\022(\n\npermission\030\001 \003(\0132\024"
    ".hbase.pb.Permission\"\032\n\030CheckPermissions"
    "Response2\311\002\n\024AccessControlService\0228\n\005Gra"
    "nt\022\026.hbase.pb.GrantRequest\032\027.hbase.pb.Gr"
    "antResponse\022;\n\006Revoke\022\027.hbase.pb.RevokeR"
    "equest\032\030.hbase.pb.RevokeResponse\022_\n\022GetU"
    "serPermissions\022#.hbase.pb.GetUserPermiss"
    "ionsRequest\032$.hbase.pb.GetUserPermission"
    "sResponse\022Y\n\020CheckPermissions\022!.hbase.pb"
    ".CheckPermissionsRequest\032\".hbase.pb.Chec"
    "kPermissionsResponseBI\n*org.apache.hadoo"
    "p.hbase.protobuf.generatedB\023AccessContro"
    "lProtosH\001\210\001\001\240\001\001", 1815);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "AccessControl.proto", &protobuf_RegisterTypes);
  Permission::default_instance_ = new Permission();
  TablePermission::default_instance_ = new TablePermission();
  NamespacePermission::default_instance_ = new NamespacePermission();
  GlobalPermission::default_instance_ = new GlobalPermission();
  UserPermission::default_instance_ = new UserPermission();
  UsersAndPermissions::default_instance_ = new UsersAndPermissions();
  UsersAndPermissions_UserPermissions::default_instance_ = new UsersAndPermissions_UserPermissions();
  GrantRequest::default_instance_ = new GrantRequest();
  GrantResponse::default_instance_ = new GrantResponse();
  RevokeRequest::default_instance_ = new RevokeRequest();
  RevokeResponse::default_instance_ = new RevokeResponse();
  GetUserPermissionsRequest::default_instance_ = new GetUserPermissionsRequest();
  GetUserPermissionsResponse::default_instance_ = new GetUserPermissionsResponse();
  CheckPermissionsRequest::default_instance_ = new CheckPermissionsRequest();
  CheckPermissionsResponse::default_instance_ = new CheckPermissionsResponse();
  Permission::default_instance_->InitAsDefaultInstance();
  TablePermission::default_instance_->InitAsDefaultInstance();
  NamespacePermission::default_instance_->InitAsDefaultInstance();
  GlobalPermission::default_instance_->InitAsDefaultInstance();
  UserPermission::default_instance_->InitAsDefaultInstance();
  UsersAndPermissions::default_instance_->InitAsDefaultInstance();
  UsersAndPermissions_UserPermissions::default_instance_->InitAsDefaultInstance();
  GrantRequest::default_instance_->InitAsDefaultInstance();
  GrantResponse::default_instance_->InitAsDefaultInstance();
  RevokeRequest::default_instance_->InitAsDefaultInstance();
  RevokeResponse::default_instance_->InitAsDefaultInstance();
  GetUserPermissionsRequest::default_instance_->InitAsDefaultInstance();
  GetUserPermissionsResponse::default_instance_->InitAsDefaultInstance();
  CheckPermissionsRequest::default_instance_->InitAsDefaultInstance();
  CheckPermissionsResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_AccessControl_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_AccessControl_2eproto {
  StaticDescriptorInitializer_AccessControl_2eproto() {
    protobuf_AddDesc_AccessControl_2eproto();
  }
} static_descriptor_initializer_AccessControl_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Permission_Action_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Permission_Action_descriptor_;
}
bool Permission_Action_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Permission_Action Permission::READ;
const Permission_Action Permission::WRITE;
const Permission_Action Permission::EXEC;
const Permission_Action Permission::CREATE;
const Permission_Action Permission::ADMIN;
const Permission_Action Permission::Action_MIN;
const Permission_Action Permission::Action_MAX;
const int Permission::Action_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Permission_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Permission_Type_descriptor_;
}
bool Permission_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Permission_Type Permission::Global;
const Permission_Type Permission::Namespace;
const Permission_Type Permission::Table;
const Permission_Type Permission::Type_MIN;
const Permission_Type Permission::Type_MAX;
const int Permission::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Permission::kTypeFieldNumber;
const int Permission::kGlobalPermissionFieldNumber;
const int Permission::kNamespacePermissionFieldNumber;
const int Permission::kTablePermissionFieldNumber;
#endif  // !_MSC_VER

Permission::Permission()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Permission::InitAsDefaultInstance() {
  global_permission_ = const_cast< ::hbase::pb::GlobalPermission*>(&::hbase::pb::GlobalPermission::default_instance());
  namespace_permission_ = const_cast< ::hbase::pb::NamespacePermission*>(&::hbase::pb::NamespacePermission::default_instance());
  table_permission_ = const_cast< ::hbase::pb::TablePermission*>(&::hbase::pb::TablePermission::default_instance());
}

Permission::Permission(const Permission& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Permission::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  global_permission_ = NULL;
  namespace_permission_ = NULL;
  table_permission_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Permission::~Permission() {
  SharedDtor();
}

void Permission::SharedDtor() {
  if (this != default_instance_) {
    delete global_permission_;
    delete namespace_permission_;
    delete table_permission_;
  }
}

void Permission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Permission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Permission_descriptor_;
}

const Permission& Permission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

Permission* Permission::default_instance_ = NULL;

Permission* Permission::New() const {
  return new Permission;
}

void Permission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_global_permission()) {
      if (global_permission_ != NULL) global_permission_->::hbase::pb::GlobalPermission::Clear();
    }
    if (has_namespace_permission()) {
      if (namespace_permission_ != NULL) namespace_permission_->::hbase::pb::NamespacePermission::Clear();
    }
    if (has_table_permission()) {
      if (table_permission_ != NULL) table_permission_->::hbase::pb::TablePermission::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Permission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.Permission.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Type_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::Permission_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_global_permission;
        break;
      }

      // optional .hbase.pb.GlobalPermission global_permission = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_global_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_global_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_namespace_permission;
        break;
      }

      // optional .hbase.pb.NamespacePermission namespace_permission = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_namespace_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_namespace_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_table_permission;
        break;
      }

      // optional .hbase.pb.TablePermission table_permission = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Permission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.Permission.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .hbase.pb.GlobalPermission global_permission = 2;
  if (has_global_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->global_permission(), output);
  }

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  if (has_namespace_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->namespace_permission(), output);
  }

  // optional .hbase.pb.TablePermission table_permission = 4;
  if (has_table_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->table_permission(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Permission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.Permission.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .hbase.pb.GlobalPermission global_permission = 2;
  if (has_global_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->global_permission(), target);
  }

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  if (has_namespace_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->namespace_permission(), target);
  }

  // optional .hbase.pb.TablePermission table_permission = 4;
  if (has_table_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->table_permission(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Permission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.Permission.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .hbase.pb.GlobalPermission global_permission = 2;
    if (has_global_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->global_permission());
    }

    // optional .hbase.pb.NamespacePermission namespace_permission = 3;
    if (has_namespace_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->namespace_permission());
    }

    // optional .hbase.pb.TablePermission table_permission = 4;
    if (has_table_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_permission());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Permission::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Permission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Permission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Permission::MergeFrom(const Permission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_global_permission()) {
      mutable_global_permission()->::hbase::pb::GlobalPermission::MergeFrom(from.global_permission());
    }
    if (from.has_namespace_permission()) {
      mutable_namespace_permission()->::hbase::pb::NamespacePermission::MergeFrom(from.namespace_permission());
    }
    if (from.has_table_permission()) {
      mutable_table_permission()->::hbase::pb::TablePermission::MergeFrom(from.table_permission());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Permission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Permission::CopyFrom(const Permission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Permission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_table_permission()) {
    if (!this->table_permission().IsInitialized()) return false;
  }
  return true;
}

void Permission::Swap(Permission* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(global_permission_, other->global_permission_);
    std::swap(namespace_permission_, other->namespace_permission_);
    std::swap(table_permission_, other->table_permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Permission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Permission_descriptor_;
  metadata.reflection = Permission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TablePermission::kTableNameFieldNumber;
const int TablePermission::kFamilyFieldNumber;
const int TablePermission::kQualifierFieldNumber;
const int TablePermission::kActionFieldNumber;
#endif  // !_MSC_VER

TablePermission::TablePermission()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TablePermission::InitAsDefaultInstance() {
  table_name_ = const_cast< ::hbase::pb::TableName*>(&::hbase::pb::TableName::default_instance());
}

TablePermission::TablePermission(const TablePermission& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TablePermission::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TablePermission::~TablePermission() {
  SharedDtor();
}

void TablePermission::SharedDtor() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (this != default_instance_) {
    delete table_name_;
  }
}

void TablePermission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TablePermission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TablePermission_descriptor_;
}

const TablePermission& TablePermission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

TablePermission* TablePermission::default_instance_ = NULL;

TablePermission* TablePermission::New() const {
  return new TablePermission;
}

void TablePermission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
    }
    if (has_family()) {
      if (family_ != &::google::protobuf::internal::kEmptyString) {
        family_->clear();
      }
    }
    if (has_qualifier()) {
      if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
        qualifier_->clear();
      }
    }
  }
  action_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TablePermission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.TableName table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_family;
        break;
      }

      // optional bytes family = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_family:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_family()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_qualifier;
        break;
      }

      // optional bytes qualifier = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_qualifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_qualifier()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_action;
        break;
      }

      // repeated .hbase.pb.Permission.Action action = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::hbase::pb::Permission_Action_IsValid,
                 this->mutable_action())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_action;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TablePermission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .hbase.pb.TableName table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }

  // optional bytes family = 2;
  if (has_family()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->family(), output);
  }

  // optional bytes qualifier = 3;
  if (has_qualifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->qualifier(), output);
  }

  // repeated .hbase.pb.Permission.Action action = 4;
  for (int i = 0; i < this->action_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->action(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TablePermission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .hbase.pb.TableName table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }

  // optional bytes family = 2;
  if (has_family()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->family(), target);
  }

  // optional bytes qualifier = 3;
  if (has_qualifier()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->qualifier(), target);
  }

  // repeated .hbase.pb.Permission.Action action = 4;
  for (int i = 0; i < this->action_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->action(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TablePermission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .hbase.pb.TableName table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }

    // optional bytes family = 2;
    if (has_family()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->family());
    }

    // optional bytes qualifier = 3;
    if (has_qualifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->qualifier());
    }

  }
  // repeated .hbase.pb.Permission.Action action = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->action_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->action(i));
    }
    total_size += 1 * this->action_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TablePermission::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TablePermission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TablePermission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TablePermission::MergeFrom(const TablePermission& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_.MergeFrom(from.action_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::hbase::pb::TableName::MergeFrom(from.table_name());
    }
    if (from.has_family()) {
      set_family(from.family());
    }
    if (from.has_qualifier()) {
      set_qualifier(from.qualifier());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TablePermission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TablePermission::CopyFrom(const TablePermission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TablePermission::IsInitialized() const {

  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  return true;
}

void TablePermission::Swap(TablePermission* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(family_, other->family_);
    std::swap(qualifier_, other->qualifier_);
    action_.Swap(&other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TablePermission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TablePermission_descriptor_;
  metadata.reflection = TablePermission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NamespacePermission::kNamespaceNameFieldNumber;
const int NamespacePermission::kActionFieldNumber;
#endif  // !_MSC_VER

NamespacePermission::NamespacePermission()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NamespacePermission::InitAsDefaultInstance() {
}

NamespacePermission::NamespacePermission(const NamespacePermission& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NamespacePermission::SharedCtor() {
  _cached_size_ = 0;
  namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NamespacePermission::~NamespacePermission() {
  SharedDtor();
}

void NamespacePermission::SharedDtor() {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    delete namespace_name_;
  }
  if (this != default_instance_) {
  }
}

void NamespacePermission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NamespacePermission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamespacePermission_descriptor_;
}

const NamespacePermission& NamespacePermission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

NamespacePermission* NamespacePermission::default_instance_ = NULL;

NamespacePermission* NamespacePermission::New() const {
  return new NamespacePermission;
}

void NamespacePermission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_namespace_name()) {
      if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
        namespace_name_->clear();
      }
    }
  }
  action_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NamespacePermission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes namespace_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_namespace_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_action;
        break;
      }

      // repeated .hbase.pb.Permission.Action action = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::hbase::pb::Permission_Action_IsValid,
                 this->mutable_action())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_action;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NamespacePermission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes namespace_name = 1;
  if (has_namespace_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->namespace_name(), output);
  }

  // repeated .hbase.pb.Permission.Action action = 2;
  for (int i = 0; i < this->action_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->action(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NamespacePermission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes namespace_name = 1;
  if (has_namespace_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->namespace_name(), target);
  }

  // repeated .hbase.pb.Permission.Action action = 2;
  for (int i = 0; i < this->action_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->action(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NamespacePermission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes namespace_name = 1;
    if (has_namespace_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->namespace_name());
    }

  }
  // repeated .hbase.pb.Permission.Action action = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->action_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->action(i));
    }
    total_size += 1 * this->action_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NamespacePermission::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NamespacePermission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NamespacePermission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NamespacePermission::MergeFrom(const NamespacePermission& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_.MergeFrom(from.action_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_namespace_name()) {
      set_namespace_name(from.namespace_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NamespacePermission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamespacePermission::CopyFrom(const NamespacePermission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespacePermission::IsInitialized() const {

  return true;
}

void NamespacePermission::Swap(NamespacePermission* other) {
  if (other != this) {
    std::swap(namespace_name_, other->namespace_name_);
    action_.Swap(&other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NamespacePermission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NamespacePermission_descriptor_;
  metadata.reflection = NamespacePermission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GlobalPermission::kActionFieldNumber;
#endif  // !_MSC_VER

GlobalPermission::GlobalPermission()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GlobalPermission::InitAsDefaultInstance() {
}

GlobalPermission::GlobalPermission(const GlobalPermission& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GlobalPermission::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GlobalPermission::~GlobalPermission() {
  SharedDtor();
}

void GlobalPermission::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GlobalPermission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlobalPermission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GlobalPermission_descriptor_;
}

const GlobalPermission& GlobalPermission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

GlobalPermission* GlobalPermission::default_instance_ = NULL;

GlobalPermission* GlobalPermission::New() const {
  return new GlobalPermission;
}

void GlobalPermission::Clear() {
  action_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GlobalPermission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.Permission.Action action = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::hbase::pb::Permission_Action_IsValid,
                 this->mutable_action())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_action;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GlobalPermission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.Permission.Action action = 1;
  for (int i = 0; i < this->action_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->action(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GlobalPermission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.Permission.Action action = 1;
  for (int i = 0; i < this->action_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->action(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GlobalPermission::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.Permission.Action action = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->action_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->action(i));
    }
    total_size += 1 * this->action_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlobalPermission::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GlobalPermission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GlobalPermission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GlobalPermission::MergeFrom(const GlobalPermission& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_.MergeFrom(from.action_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GlobalPermission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlobalPermission::CopyFrom(const GlobalPermission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalPermission::IsInitialized() const {

  return true;
}

void GlobalPermission::Swap(GlobalPermission* other) {
  if (other != this) {
    action_.Swap(&other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GlobalPermission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GlobalPermission_descriptor_;
  metadata.reflection = GlobalPermission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserPermission::kUserFieldNumber;
const int UserPermission::kPermissionFieldNumber;
#endif  // !_MSC_VER

UserPermission::UserPermission()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserPermission::InitAsDefaultInstance() {
  permission_ = const_cast< ::hbase::pb::Permission*>(&::hbase::pb::Permission::default_instance());
}

UserPermission::UserPermission(const UserPermission& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserPermission::SharedCtor() {
  _cached_size_ = 0;
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  permission_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserPermission::~UserPermission() {
  SharedDtor();
}

void UserPermission::SharedDtor() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (this != default_instance_) {
    delete permission_;
  }
}

void UserPermission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserPermission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserPermission_descriptor_;
}

const UserPermission& UserPermission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

UserPermission* UserPermission::default_instance_ = NULL;

UserPermission* UserPermission::New() const {
  return new UserPermission;
}

void UserPermission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::kEmptyString) {
        user_->clear();
      }
    }
    if (has_permission()) {
      if (permission_ != NULL) permission_->::hbase::pb::Permission::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserPermission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_permission;
        break;
      }

      // required .hbase.pb.Permission permission = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserPermission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->user(), output);
  }

  // required .hbase.pb.Permission permission = 3;
  if (has_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->permission(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserPermission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes user = 1;
  if (has_user()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->user(), target);
  }

  // required .hbase.pb.Permission permission = 3;
  if (has_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->permission(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserPermission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user());
    }

    // required .hbase.pb.Permission permission = 3;
    if (has_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->permission());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserPermission::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserPermission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserPermission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserPermission::MergeFrom(const UserPermission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      set_user(from.user());
    }
    if (from.has_permission()) {
      mutable_permission()->::hbase::pb::Permission::MergeFrom(from.permission());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserPermission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserPermission::CopyFrom(const UserPermission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserPermission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_permission()) {
    if (!this->permission().IsInitialized()) return false;
  }
  return true;
}

void UserPermission::Swap(UserPermission* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    std::swap(permission_, other->permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserPermission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserPermission_descriptor_;
  metadata.reflection = UserPermission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UsersAndPermissions_UserPermissions::kUserFieldNumber;
const int UsersAndPermissions_UserPermissions::kPermissionsFieldNumber;
#endif  // !_MSC_VER

UsersAndPermissions_UserPermissions::UsersAndPermissions_UserPermissions()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UsersAndPermissions_UserPermissions::InitAsDefaultInstance() {
}

UsersAndPermissions_UserPermissions::UsersAndPermissions_UserPermissions(const UsersAndPermissions_UserPermissions& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UsersAndPermissions_UserPermissions::SharedCtor() {
  _cached_size_ = 0;
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UsersAndPermissions_UserPermissions::~UsersAndPermissions_UserPermissions() {
  SharedDtor();
}

void UsersAndPermissions_UserPermissions::SharedDtor() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (this != default_instance_) {
  }
}

void UsersAndPermissions_UserPermissions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UsersAndPermissions_UserPermissions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UsersAndPermissions_UserPermissions_descriptor_;
}

const UsersAndPermissions_UserPermissions& UsersAndPermissions_UserPermissions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

UsersAndPermissions_UserPermissions* UsersAndPermissions_UserPermissions::default_instance_ = NULL;

UsersAndPermissions_UserPermissions* UsersAndPermissions_UserPermissions::New() const {
  return new UsersAndPermissions_UserPermissions;
}

void UsersAndPermissions_UserPermissions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::kEmptyString) {
        user_->clear();
      }
    }
  }
  permissions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UsersAndPermissions_UserPermissions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_permissions;
        break;
      }

      // repeated .hbase.pb.Permission permissions = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permissions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_permissions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_permissions;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UsersAndPermissions_UserPermissions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->user(), output);
  }

  // repeated .hbase.pb.Permission permissions = 2;
  for (int i = 0; i < this->permissions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->permissions(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UsersAndPermissions_UserPermissions::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes user = 1;
  if (has_user()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->user(), target);
  }

  // repeated .hbase.pb.Permission permissions = 2;
  for (int i = 0; i < this->permissions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->permissions(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UsersAndPermissions_UserPermissions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user());
    }

  }
  // repeated .hbase.pb.Permission permissions = 2;
  total_size += 1 * this->permissions_size();
  for (int i = 0; i < this->permissions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->permissions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UsersAndPermissions_UserPermissions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UsersAndPermissions_UserPermissions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UsersAndPermissions_UserPermissions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UsersAndPermissions_UserPermissions::MergeFrom(const UsersAndPermissions_UserPermissions& from) {
  GOOGLE_CHECK_NE(&from, this);
  permissions_.MergeFrom(from.permissions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      set_user(from.user());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UsersAndPermissions_UserPermissions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsersAndPermissions_UserPermissions::CopyFrom(const UsersAndPermissions_UserPermissions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersAndPermissions_UserPermissions::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < permissions_size(); i++) {
    if (!this->permissions(i).IsInitialized()) return false;
  }
  return true;
}

void UsersAndPermissions_UserPermissions::Swap(UsersAndPermissions_UserPermissions* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    permissions_.Swap(&other->permissions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UsersAndPermissions_UserPermissions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UsersAndPermissions_UserPermissions_descriptor_;
  metadata.reflection = UsersAndPermissions_UserPermissions_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UsersAndPermissions::kUserPermissionsFieldNumber;
#endif  // !_MSC_VER

UsersAndPermissions::UsersAndPermissions()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UsersAndPermissions::InitAsDefaultInstance() {
}

UsersAndPermissions::UsersAndPermissions(const UsersAndPermissions& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UsersAndPermissions::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UsersAndPermissions::~UsersAndPermissions() {
  SharedDtor();
}

void UsersAndPermissions::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UsersAndPermissions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UsersAndPermissions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UsersAndPermissions_descriptor_;
}

const UsersAndPermissions& UsersAndPermissions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

UsersAndPermissions* UsersAndPermissions::default_instance_ = NULL;

UsersAndPermissions* UsersAndPermissions::New() const {
  return new UsersAndPermissions;
}

void UsersAndPermissions::Clear() {
  user_permissions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UsersAndPermissions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_permissions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_permissions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_permissions;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UsersAndPermissions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  for (int i = 0; i < this->user_permissions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->user_permissions(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UsersAndPermissions::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  for (int i = 0; i < this->user_permissions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->user_permissions(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UsersAndPermissions::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  total_size += 1 * this->user_permissions_size();
  for (int i = 0; i < this->user_permissions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_permissions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UsersAndPermissions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UsersAndPermissions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UsersAndPermissions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UsersAndPermissions::MergeFrom(const UsersAndPermissions& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_permissions_.MergeFrom(from.user_permissions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UsersAndPermissions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsersAndPermissions::CopyFrom(const UsersAndPermissions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersAndPermissions::IsInitialized() const {

  for (int i = 0; i < user_permissions_size(); i++) {
    if (!this->user_permissions(i).IsInitialized()) return false;
  }
  return true;
}

void UsersAndPermissions::Swap(UsersAndPermissions* other) {
  if (other != this) {
    user_permissions_.Swap(&other->user_permissions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UsersAndPermissions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UsersAndPermissions_descriptor_;
  metadata.reflection = UsersAndPermissions_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GrantRequest::kUserPermissionFieldNumber;
#endif  // !_MSC_VER

GrantRequest::GrantRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GrantRequest::InitAsDefaultInstance() {
  user_permission_ = const_cast< ::hbase::pb::UserPermission*>(&::hbase::pb::UserPermission::default_instance());
}

GrantRequest::GrantRequest(const GrantRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GrantRequest::SharedCtor() {
  _cached_size_ = 0;
  user_permission_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GrantRequest::~GrantRequest() {
  SharedDtor();
}

void GrantRequest::SharedDtor() {
  if (this != default_instance_) {
    delete user_permission_;
  }
}

void GrantRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GrantRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GrantRequest_descriptor_;
}

const GrantRequest& GrantRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

GrantRequest* GrantRequest::default_instance_ = NULL;

GrantRequest* GrantRequest::New() const {
  return new GrantRequest;
}

void GrantRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_permission()) {
      if (user_permission_ != NULL) user_permission_->::hbase::pb::UserPermission::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GrantRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GrantRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->user_permission(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GrantRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->user_permission(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GrantRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.UserPermission user_permission = 1;
    if (has_user_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_permission());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GrantRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GrantRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GrantRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GrantRequest::MergeFrom(const GrantRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_permission()) {
      mutable_user_permission()->::hbase::pb::UserPermission::MergeFrom(from.user_permission());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GrantRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GrantRequest::CopyFrom(const GrantRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GrantRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_permission()) {
    if (!this->user_permission().IsInitialized()) return false;
  }
  return true;
}

void GrantRequest::Swap(GrantRequest* other) {
  if (other != this) {
    std::swap(user_permission_, other->user_permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GrantRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GrantRequest_descriptor_;
  metadata.reflection = GrantRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GrantResponse::GrantResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GrantResponse::InitAsDefaultInstance() {
}

GrantResponse::GrantResponse(const GrantResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GrantResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GrantResponse::~GrantResponse() {
  SharedDtor();
}

void GrantResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GrantResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GrantResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GrantResponse_descriptor_;
}

const GrantResponse& GrantResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

GrantResponse* GrantResponse::default_instance_ = NULL;

GrantResponse* GrantResponse::New() const {
  return new GrantResponse;
}

void GrantResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GrantResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GrantResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GrantResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GrantResponse::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GrantResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GrantResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GrantResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GrantResponse::MergeFrom(const GrantResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GrantResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GrantResponse::CopyFrom(const GrantResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GrantResponse::IsInitialized() const {

  return true;
}

void GrantResponse::Swap(GrantResponse* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GrantResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GrantResponse_descriptor_;
  metadata.reflection = GrantResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RevokeRequest::kUserPermissionFieldNumber;
#endif  // !_MSC_VER

RevokeRequest::RevokeRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RevokeRequest::InitAsDefaultInstance() {
  user_permission_ = const_cast< ::hbase::pb::UserPermission*>(&::hbase::pb::UserPermission::default_instance());
}

RevokeRequest::RevokeRequest(const RevokeRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RevokeRequest::SharedCtor() {
  _cached_size_ = 0;
  user_permission_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RevokeRequest::~RevokeRequest() {
  SharedDtor();
}

void RevokeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete user_permission_;
  }
}

void RevokeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RevokeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RevokeRequest_descriptor_;
}

const RevokeRequest& RevokeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

RevokeRequest* RevokeRequest::default_instance_ = NULL;

RevokeRequest* RevokeRequest::New() const {
  return new RevokeRequest;
}

void RevokeRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_permission()) {
      if (user_permission_ != NULL) user_permission_->::hbase::pb::UserPermission::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RevokeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RevokeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->user_permission(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RevokeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->user_permission(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RevokeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hbase.pb.UserPermission user_permission = 1;
    if (has_user_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_permission());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RevokeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RevokeRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RevokeRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RevokeRequest::MergeFrom(const RevokeRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_permission()) {
      mutable_user_permission()->::hbase::pb::UserPermission::MergeFrom(from.user_permission());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RevokeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevokeRequest::CopyFrom(const RevokeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevokeRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_permission()) {
    if (!this->user_permission().IsInitialized()) return false;
  }
  return true;
}

void RevokeRequest::Swap(RevokeRequest* other) {
  if (other != this) {
    std::swap(user_permission_, other->user_permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RevokeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RevokeRequest_descriptor_;
  metadata.reflection = RevokeRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RevokeResponse::RevokeResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RevokeResponse::InitAsDefaultInstance() {
}

RevokeResponse::RevokeResponse(const RevokeResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RevokeResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RevokeResponse::~RevokeResponse() {
  SharedDtor();
}

void RevokeResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RevokeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RevokeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RevokeResponse_descriptor_;
}

const RevokeResponse& RevokeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

RevokeResponse* RevokeResponse::default_instance_ = NULL;

RevokeResponse* RevokeResponse::New() const {
  return new RevokeResponse;
}

void RevokeResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RevokeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void RevokeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RevokeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RevokeResponse::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RevokeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RevokeResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RevokeResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RevokeResponse::MergeFrom(const RevokeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RevokeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevokeResponse::CopyFrom(const RevokeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevokeResponse::IsInitialized() const {

  return true;
}

void RevokeResponse::Swap(RevokeResponse* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RevokeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RevokeResponse_descriptor_;
  metadata.reflection = RevokeResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetUserPermissionsRequest::kTypeFieldNumber;
const int GetUserPermissionsRequest::kTableNameFieldNumber;
const int GetUserPermissionsRequest::kNamespaceNameFieldNumber;
#endif  // !_MSC_VER

GetUserPermissionsRequest::GetUserPermissionsRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetUserPermissionsRequest::InitAsDefaultInstance() {
  table_name_ = const_cast< ::hbase::pb::TableName*>(&::hbase::pb::TableName::default_instance());
}

GetUserPermissionsRequest::GetUserPermissionsRequest(const GetUserPermissionsRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetUserPermissionsRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  table_name_ = NULL;
  namespace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetUserPermissionsRequest::~GetUserPermissionsRequest() {
  SharedDtor();
}

void GetUserPermissionsRequest::SharedDtor() {
  if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
    delete namespace_name_;
  }
  if (this != default_instance_) {
    delete table_name_;
  }
}

void GetUserPermissionsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetUserPermissionsRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetUserPermissionsRequest_descriptor_;
}

const GetUserPermissionsRequest& GetUserPermissionsRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

GetUserPermissionsRequest* GetUserPermissionsRequest::default_instance_ = NULL;

GetUserPermissionsRequest* GetUserPermissionsRequest::New() const {
  return new GetUserPermissionsRequest;
}

void GetUserPermissionsRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::hbase::pb::TableName::Clear();
    }
    if (has_namespace_name()) {
      if (namespace_name_ != &::google::protobuf::internal::kEmptyString) {
        namespace_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetUserPermissionsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.Permission.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Type_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::Permission_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_table_name;
        break;
      }

      // optional .hbase.pb.TableName table_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_namespace_name;
        break;
      }

      // optional bytes namespace_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_namespace_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_namespace_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetUserPermissionsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .hbase.pb.Permission.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .hbase.pb.TableName table_name = 2;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->table_name(), output);
  }

  // optional bytes namespace_name = 3;
  if (has_namespace_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->namespace_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetUserPermissionsRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .hbase.pb.Permission.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .hbase.pb.TableName table_name = 2;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->table_name(), target);
  }

  // optional bytes namespace_name = 3;
  if (has_namespace_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->namespace_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetUserPermissionsRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .hbase.pb.Permission.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .hbase.pb.TableName table_name = 2;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }

    // optional bytes namespace_name = 3;
    if (has_namespace_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->namespace_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetUserPermissionsRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetUserPermissionsRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetUserPermissionsRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetUserPermissionsRequest::MergeFrom(const GetUserPermissionsRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_table_name()) {
      mutable_table_name()->::hbase::pb::TableName::MergeFrom(from.table_name());
    }
    if (from.has_namespace_name()) {
      set_namespace_name(from.namespace_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetUserPermissionsRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUserPermissionsRequest::CopyFrom(const GetUserPermissionsRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserPermissionsRequest::IsInitialized() const {

  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  return true;
}

void GetUserPermissionsRequest::Swap(GetUserPermissionsRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(table_name_, other->table_name_);
    std::swap(namespace_name_, other->namespace_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetUserPermissionsRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetUserPermissionsRequest_descriptor_;
  metadata.reflection = GetUserPermissionsRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetUserPermissionsResponse::kUserPermissionFieldNumber;
#endif  // !_MSC_VER

GetUserPermissionsResponse::GetUserPermissionsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetUserPermissionsResponse::InitAsDefaultInstance() {
}

GetUserPermissionsResponse::GetUserPermissionsResponse(const GetUserPermissionsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetUserPermissionsResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetUserPermissionsResponse::~GetUserPermissionsResponse() {
  SharedDtor();
}

void GetUserPermissionsResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetUserPermissionsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetUserPermissionsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetUserPermissionsResponse_descriptor_;
}

const GetUserPermissionsResponse& GetUserPermissionsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

GetUserPermissionsResponse* GetUserPermissionsResponse::default_instance_ = NULL;

GetUserPermissionsResponse* GetUserPermissionsResponse::New() const {
  return new GetUserPermissionsResponse;
}

void GetUserPermissionsResponse::Clear() {
  user_permission_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetUserPermissionsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_permission;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetUserPermissionsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.UserPermission user_permission = 1;
  for (int i = 0; i < this->user_permission_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->user_permission(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetUserPermissionsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.UserPermission user_permission = 1;
  for (int i = 0; i < this->user_permission_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->user_permission(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetUserPermissionsResponse::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.UserPermission user_permission = 1;
  total_size += 1 * this->user_permission_size();
  for (int i = 0; i < this->user_permission_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_permission(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetUserPermissionsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetUserPermissionsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetUserPermissionsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetUserPermissionsResponse::MergeFrom(const GetUserPermissionsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_permission_.MergeFrom(from.user_permission_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetUserPermissionsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUserPermissionsResponse::CopyFrom(const GetUserPermissionsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserPermissionsResponse::IsInitialized() const {

  for (int i = 0; i < user_permission_size(); i++) {
    if (!this->user_permission(i).IsInitialized()) return false;
  }
  return true;
}

void GetUserPermissionsResponse::Swap(GetUserPermissionsResponse* other) {
  if (other != this) {
    user_permission_.Swap(&other->user_permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetUserPermissionsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetUserPermissionsResponse_descriptor_;
  metadata.reflection = GetUserPermissionsResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckPermissionsRequest::kPermissionFieldNumber;
#endif  // !_MSC_VER

CheckPermissionsRequest::CheckPermissionsRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckPermissionsRequest::InitAsDefaultInstance() {
}

CheckPermissionsRequest::CheckPermissionsRequest(const CheckPermissionsRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckPermissionsRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckPermissionsRequest::~CheckPermissionsRequest() {
  SharedDtor();
}

void CheckPermissionsRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckPermissionsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckPermissionsRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckPermissionsRequest_descriptor_;
}

const CheckPermissionsRequest& CheckPermissionsRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

CheckPermissionsRequest* CheckPermissionsRequest::default_instance_ = NULL;

CheckPermissionsRequest* CheckPermissionsRequest::New() const {
  return new CheckPermissionsRequest;
}

void CheckPermissionsRequest::Clear() {
  permission_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckPermissionsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.Permission permission = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_permission;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckPermissionsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hbase.pb.Permission permission = 1;
  for (int i = 0; i < this->permission_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->permission(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckPermissionsRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hbase.pb.Permission permission = 1;
  for (int i = 0; i < this->permission_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->permission(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckPermissionsRequest::ByteSize() const {
  int total_size = 0;

  // repeated .hbase.pb.Permission permission = 1;
  total_size += 1 * this->permission_size();
  for (int i = 0; i < this->permission_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->permission(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckPermissionsRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckPermissionsRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckPermissionsRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckPermissionsRequest::MergeFrom(const CheckPermissionsRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  permission_.MergeFrom(from.permission_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckPermissionsRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckPermissionsRequest::CopyFrom(const CheckPermissionsRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPermissionsRequest::IsInitialized() const {

  for (int i = 0; i < permission_size(); i++) {
    if (!this->permission(i).IsInitialized()) return false;
  }
  return true;
}

void CheckPermissionsRequest::Swap(CheckPermissionsRequest* other) {
  if (other != this) {
    permission_.Swap(&other->permission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckPermissionsRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckPermissionsRequest_descriptor_;
  metadata.reflection = CheckPermissionsRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CheckPermissionsResponse::CheckPermissionsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckPermissionsResponse::InitAsDefaultInstance() {
}

CheckPermissionsResponse::CheckPermissionsResponse(const CheckPermissionsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckPermissionsResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckPermissionsResponse::~CheckPermissionsResponse() {
  SharedDtor();
}

void CheckPermissionsResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckPermissionsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckPermissionsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckPermissionsResponse_descriptor_;
}

const CheckPermissionsResponse& CheckPermissionsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AccessControl_2eproto();
  return *default_instance_;
}

CheckPermissionsResponse* CheckPermissionsResponse::default_instance_ = NULL;

CheckPermissionsResponse* CheckPermissionsResponse::New() const {
  return new CheckPermissionsResponse;
}

void CheckPermissionsResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckPermissionsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void CheckPermissionsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckPermissionsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckPermissionsResponse::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckPermissionsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckPermissionsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckPermissionsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckPermissionsResponse::MergeFrom(const CheckPermissionsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckPermissionsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckPermissionsResponse::CopyFrom(const CheckPermissionsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPermissionsResponse::IsInitialized() const {

  return true;
}

void CheckPermissionsResponse::Swap(CheckPermissionsResponse* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckPermissionsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckPermissionsResponse_descriptor_;
  metadata.reflection = CheckPermissionsResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

// @@protoc_insertion_point(global_scope)
