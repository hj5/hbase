// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Client.proto

#ifndef PROTOBUF_Client_2eproto__INCLUDED
#define PROTOBUF_Client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Filter.pb.h"
#include "Cell.pb.h"
#include "Comparator.pb.h"
#include "MapReduce.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Client_2eproto();
void protobuf_AssignDesc_Client_2eproto();
void protobuf_ShutdownFile_Client_2eproto();

class Authorizations;
class CellVisibility;
class Column;
class Get;
class Result;
class GetRequest;
class GetResponse;
class Condition;
class MutationProto;
class MutationProto_ColumnValue;
class MutationProto_ColumnValue_QualifierValue;
class MutateRequest;
class MutateResponse;
class Scan;
class ScanRequest;
class ScanResponse;
class BulkLoadHFileRequest;
class BulkLoadHFileRequest_FamilyPath;
class BulkLoadHFileResponse;
class CoprocessorServiceCall;
class CoprocessorServiceResult;
class CoprocessorServiceRequest;
class CoprocessorServiceResponse;
class Action;
class RegionAction;
class RegionLoadStats;
class MultiRegionLoadStats;
class ResultOrException;
class RegionActionResult;
class MultiRequest;
class MultiResponse;

enum MutationProto_Durability {
  MutationProto_Durability_USE_DEFAULT = 0,
  MutationProto_Durability_SKIP_WAL = 1,
  MutationProto_Durability_ASYNC_WAL = 2,
  MutationProto_Durability_SYNC_WAL = 3,
  MutationProto_Durability_FSYNC_WAL = 4
};
bool MutationProto_Durability_IsValid(int value);
const MutationProto_Durability MutationProto_Durability_Durability_MIN = MutationProto_Durability_USE_DEFAULT;
const MutationProto_Durability MutationProto_Durability_Durability_MAX = MutationProto_Durability_FSYNC_WAL;
const int MutationProto_Durability_Durability_ARRAYSIZE = MutationProto_Durability_Durability_MAX + 1;

const ::google::protobuf::EnumDescriptor* MutationProto_Durability_descriptor();
inline const ::std::string& MutationProto_Durability_Name(MutationProto_Durability value) {
  return ::google::protobuf::internal::NameOfEnum(
    MutationProto_Durability_descriptor(), value);
}
inline bool MutationProto_Durability_Parse(
    const ::std::string& name, MutationProto_Durability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MutationProto_Durability>(
    MutationProto_Durability_descriptor(), name, value);
}
enum MutationProto_MutationType {
  MutationProto_MutationType_APPEND = 0,
  MutationProto_MutationType_INCREMENT = 1,
  MutationProto_MutationType_PUT = 2,
  MutationProto_MutationType_DELETE = 3
};
bool MutationProto_MutationType_IsValid(int value);
const MutationProto_MutationType MutationProto_MutationType_MutationType_MIN = MutationProto_MutationType_APPEND;
const MutationProto_MutationType MutationProto_MutationType_MutationType_MAX = MutationProto_MutationType_DELETE;
const int MutationProto_MutationType_MutationType_ARRAYSIZE = MutationProto_MutationType_MutationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MutationProto_MutationType_descriptor();
inline const ::std::string& MutationProto_MutationType_Name(MutationProto_MutationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MutationProto_MutationType_descriptor(), value);
}
inline bool MutationProto_MutationType_Parse(
    const ::std::string& name, MutationProto_MutationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MutationProto_MutationType>(
    MutationProto_MutationType_descriptor(), name, value);
}
enum MutationProto_DeleteType {
  MutationProto_DeleteType_DELETE_ONE_VERSION = 0,
  MutationProto_DeleteType_DELETE_MULTIPLE_VERSIONS = 1,
  MutationProto_DeleteType_DELETE_FAMILY = 2,
  MutationProto_DeleteType_DELETE_FAMILY_VERSION = 3
};
bool MutationProto_DeleteType_IsValid(int value);
const MutationProto_DeleteType MutationProto_DeleteType_DeleteType_MIN = MutationProto_DeleteType_DELETE_ONE_VERSION;
const MutationProto_DeleteType MutationProto_DeleteType_DeleteType_MAX = MutationProto_DeleteType_DELETE_FAMILY_VERSION;
const int MutationProto_DeleteType_DeleteType_ARRAYSIZE = MutationProto_DeleteType_DeleteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MutationProto_DeleteType_descriptor();
inline const ::std::string& MutationProto_DeleteType_Name(MutationProto_DeleteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MutationProto_DeleteType_descriptor(), value);
}
inline bool MutationProto_DeleteType_Parse(
    const ::std::string& name, MutationProto_DeleteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MutationProto_DeleteType>(
    MutationProto_DeleteType_descriptor(), name, value);
}
enum Consistency {
  STRONG = 0,
  TIMELINE = 1
};
bool Consistency_IsValid(int value);
const Consistency Consistency_MIN = STRONG;
const Consistency Consistency_MAX = TIMELINE;
const int Consistency_ARRAYSIZE = Consistency_MAX + 1;

const ::google::protobuf::EnumDescriptor* Consistency_descriptor();
inline const ::std::string& Consistency_Name(Consistency value) {
  return ::google::protobuf::internal::NameOfEnum(
    Consistency_descriptor(), value);
}
inline bool Consistency_Parse(
    const ::std::string& name, Consistency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Consistency>(
    Consistency_descriptor(), name, value);
}
// ===================================================================

class Authorizations : public ::google::protobuf::Message {
 public:
  Authorizations();
  virtual ~Authorizations();

  Authorizations(const Authorizations& from);

  inline Authorizations& operator=(const Authorizations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authorizations& default_instance();

  void Swap(Authorizations* other);

  // implements Message ----------------------------------------------

  Authorizations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Authorizations& from);
  void MergeFrom(const Authorizations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string label = 1;
  inline int label_size() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label(int index) const;
  inline ::std::string* mutable_label(int index);
  inline void set_label(int index, const ::std::string& value);
  inline void set_label(int index, const char* value);
  inline void set_label(int index, const char* value, size_t size);
  inline ::std::string* add_label();
  inline void add_label(const ::std::string& value);
  inline void add_label(const char* value);
  inline void add_label(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& label() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_label();

  // @@protoc_insertion_point(class_scope:hbase.pb.Authorizations)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Authorizations* default_instance_;
};
// -------------------------------------------------------------------

class CellVisibility : public ::google::protobuf::Message {
 public:
  CellVisibility();
  virtual ~CellVisibility();

  CellVisibility(const CellVisibility& from);

  inline CellVisibility& operator=(const CellVisibility& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellVisibility& default_instance();

  void Swap(CellVisibility* other);

  // implements Message ----------------------------------------------

  CellVisibility* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellVisibility& from);
  void MergeFrom(const CellVisibility& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string expression = 1;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 1;
  inline const ::std::string& expression() const;
  inline void set_expression(const ::std::string& value);
  inline void set_expression(const char* value);
  inline void set_expression(const char* value, size_t size);
  inline ::std::string* mutable_expression();
  inline ::std::string* release_expression();
  inline void set_allocated_expression(::std::string* expression);

  // @@protoc_insertion_point(class_scope:hbase.pb.CellVisibility)
 private:
  inline void set_has_expression();
  inline void clear_has_expression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* expression_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static CellVisibility* default_instance_;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // repeated bytes qualifier = 2;
  inline int qualifier_size() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 2;
  inline const ::std::string& qualifier(int index) const;
  inline ::std::string* mutable_qualifier(int index);
  inline void set_qualifier(int index, const ::std::string& value);
  inline void set_qualifier(int index, const char* value);
  inline void set_qualifier(int index, const void* value, size_t size);
  inline ::std::string* add_qualifier();
  inline void add_qualifier(const ::std::string& value);
  inline void add_qualifier(const char* value);
  inline void add_qualifier(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& qualifier() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_qualifier();

  // @@protoc_insertion_point(class_scope:hbase.pb.Column)
 private:
  inline void set_has_family();
  inline void clear_has_family();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_;
  ::google::protobuf::RepeatedPtrField< ::std::string> qualifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class Get : public ::google::protobuf::Message {
 public:
  Get();
  virtual ~Get();

  Get(const Get& from);

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Get& default_instance();

  void Swap(Get* other);

  // implements Message ----------------------------------------------

  Get* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::std::string& row() const;
  inline void set_row(const ::std::string& value);
  inline void set_row(const char* value);
  inline void set_row(const void* value, size_t size);
  inline ::std::string* mutable_row();
  inline ::std::string* release_row();
  inline void set_allocated_row(::std::string* row);

  // repeated .hbase.pb.Column column = 2;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::hbase::pb::Column& column(int index) const;
  inline ::hbase::pb::Column* mutable_column(int index);
  inline ::hbase::pb::Column* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >*
      mutable_column();

  // repeated .hbase.pb.NameBytesPair attribute = 3;
  inline int attribute_size() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 3;
  inline const ::hbase::pb::NameBytesPair& attribute(int index) const;
  inline ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  inline ::hbase::pb::NameBytesPair* add_attribute();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();

  // optional .hbase.pb.Filter filter = 4;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 4;
  inline const ::hbase::pb::Filter& filter() const;
  inline ::hbase::pb::Filter* mutable_filter();
  inline ::hbase::pb::Filter* release_filter();
  inline void set_allocated_filter(::hbase::pb::Filter* filter);

  // optional .hbase.pb.TimeRange time_range = 5;
  inline bool has_time_range() const;
  inline void clear_time_range();
  static const int kTimeRangeFieldNumber = 5;
  inline const ::hbase::pb::TimeRange& time_range() const;
  inline ::hbase::pb::TimeRange* mutable_time_range();
  inline ::hbase::pb::TimeRange* release_time_range();
  inline void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional uint32 max_versions = 6 [default = 1];
  inline bool has_max_versions() const;
  inline void clear_max_versions();
  static const int kMaxVersionsFieldNumber = 6;
  inline ::google::protobuf::uint32 max_versions() const;
  inline void set_max_versions(::google::protobuf::uint32 value);

  // optional bool cache_blocks = 7 [default = true];
  inline bool has_cache_blocks() const;
  inline void clear_cache_blocks();
  static const int kCacheBlocksFieldNumber = 7;
  inline bool cache_blocks() const;
  inline void set_cache_blocks(bool value);

  // optional uint32 store_limit = 8;
  inline bool has_store_limit() const;
  inline void clear_store_limit();
  static const int kStoreLimitFieldNumber = 8;
  inline ::google::protobuf::uint32 store_limit() const;
  inline void set_store_limit(::google::protobuf::uint32 value);

  // optional uint32 store_offset = 9;
  inline bool has_store_offset() const;
  inline void clear_store_offset();
  static const int kStoreOffsetFieldNumber = 9;
  inline ::google::protobuf::uint32 store_offset() const;
  inline void set_store_offset(::google::protobuf::uint32 value);

  // optional bool existence_only = 10 [default = false];
  inline bool has_existence_only() const;
  inline void clear_existence_only();
  static const int kExistenceOnlyFieldNumber = 10;
  inline bool existence_only() const;
  inline void set_existence_only(bool value);

  // optional .hbase.pb.Consistency consistency = 12 [default = STRONG];
  inline bool has_consistency() const;
  inline void clear_consistency();
  static const int kConsistencyFieldNumber = 12;
  inline ::hbase::pb::Consistency consistency() const;
  inline void set_consistency(::hbase::pb::Consistency value);

  // repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 13;
  inline int cf_time_range_size() const;
  inline void clear_cf_time_range();
  static const int kCfTimeRangeFieldNumber = 13;
  inline const ::hbase::pb::ColumnFamilyTimeRange& cf_time_range(int index) const;
  inline ::hbase::pb::ColumnFamilyTimeRange* mutable_cf_time_range(int index);
  inline ::hbase::pb::ColumnFamilyTimeRange* add_cf_time_range();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
      cf_time_range() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
      mutable_cf_time_range();

  // @@protoc_insertion_point(class_scope:hbase.pb.Get)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_time_range();
  inline void clear_has_time_range();
  inline void set_has_max_versions();
  inline void clear_has_max_versions();
  inline void set_has_cache_blocks();
  inline void clear_has_cache_blocks();
  inline void set_has_store_limit();
  inline void clear_has_store_limit();
  inline void set_has_store_offset();
  inline void clear_has_store_offset();
  inline void set_has_existence_only();
  inline void clear_has_existence_only();
  inline void set_has_consistency();
  inline void clear_has_consistency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* row_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column > column_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::hbase::pb::Filter* filter_;
  ::hbase::pb::TimeRange* time_range_;
  ::google::protobuf::uint32 max_versions_;
  ::google::protobuf::uint32 store_limit_;
  bool cache_blocks_;
  bool existence_only_;
  ::google::protobuf::uint32 store_offset_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange > cf_time_range_;
  int consistency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Get* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.Cell cell = 1;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 1;
  inline const ::hbase::pb::Cell& cell(int index) const;
  inline ::hbase::pb::Cell* mutable_cell(int index);
  inline ::hbase::pb::Cell* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Cell >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Cell >*
      mutable_cell();

  // optional int32 associated_cell_count = 2;
  inline bool has_associated_cell_count() const;
  inline void clear_associated_cell_count();
  static const int kAssociatedCellCountFieldNumber = 2;
  inline ::google::protobuf::int32 associated_cell_count() const;
  inline void set_associated_cell_count(::google::protobuf::int32 value);

  // optional bool exists = 3;
  inline bool has_exists() const;
  inline void clear_exists();
  static const int kExistsFieldNumber = 3;
  inline bool exists() const;
  inline void set_exists(bool value);

  // optional bool stale = 4 [default = false];
  inline bool has_stale() const;
  inline void clear_stale();
  static const int kStaleFieldNumber = 4;
  inline bool stale() const;
  inline void set_stale(bool value);

  // optional bool partial = 5 [default = false];
  inline bool has_partial() const;
  inline void clear_partial();
  static const int kPartialFieldNumber = 5;
  inline bool partial() const;
  inline void set_partial(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Result)
 private:
  inline void set_has_associated_cell_count();
  inline void clear_has_associated_cell_count();
  inline void set_has_exists();
  inline void clear_has_exists();
  inline void set_has_stale();
  inline void clear_has_stale();
  inline void set_has_partial();
  inline void clear_has_partial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Cell > cell_;
  ::google::protobuf::int32 associated_cell_count_;
  bool exists_;
  bool stale_;
  bool partial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  void Swap(GetRequest* other);

  // implements Message ----------------------------------------------

  GetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.Get get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::hbase::pb::Get& get() const;
  inline ::hbase::pb::Get* mutable_get();
  inline ::hbase::pb::Get* release_get();
  inline void set_allocated_get(::hbase::pb::Get* get);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetRequest)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_get();
  inline void clear_has_get();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::Get* get_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();

  void Swap(GetResponse* other);

  // implements Message ----------------------------------------------

  GetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::hbase::pb::Result& result() const;
  inline ::hbase::pb::Result* mutable_result();
  inline ::hbase::pb::Result* release_result();
  inline void set_allocated_result(::hbase::pb::Result* result);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Result* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  void Swap(Condition* other);

  // implements Message ----------------------------------------------

  Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::std::string& row() const;
  inline void set_row(const ::std::string& value);
  inline void set_row(const char* value);
  inline void set_row(const void* value, size_t size);
  inline ::std::string* mutable_row();
  inline ::std::string* release_row();
  inline void set_allocated_row(::std::string* row);

  // required bytes family = 2;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 2;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // required bytes qualifier = 3;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 3;
  inline const ::std::string& qualifier() const;
  inline void set_qualifier(const ::std::string& value);
  inline void set_qualifier(const char* value);
  inline void set_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_qualifier();
  inline ::std::string* release_qualifier();
  inline void set_allocated_qualifier(::std::string* qualifier);

  // required .hbase.pb.CompareType compare_type = 4;
  inline bool has_compare_type() const;
  inline void clear_compare_type();
  static const int kCompareTypeFieldNumber = 4;
  inline ::hbase::pb::CompareType compare_type() const;
  inline void set_compare_type(::hbase::pb::CompareType value);

  // required .hbase.pb.Comparator comparator = 5;
  inline bool has_comparator() const;
  inline void clear_comparator();
  static const int kComparatorFieldNumber = 5;
  inline const ::hbase::pb::Comparator& comparator() const;
  inline ::hbase::pb::Comparator* mutable_comparator();
  inline ::hbase::pb::Comparator* release_comparator();
  inline void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // @@protoc_insertion_point(class_scope:hbase.pb.Condition)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();
  inline void set_has_compare_type();
  inline void clear_has_compare_type();
  inline void set_has_comparator();
  inline void clear_has_comparator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* row_;
  ::std::string* family_;
  ::std::string* qualifier_;
  ::hbase::pb::Comparator* comparator_;
  int compare_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Condition* default_instance_;
};
// -------------------------------------------------------------------

class MutationProto_ColumnValue_QualifierValue : public ::google::protobuf::Message {
 public:
  MutationProto_ColumnValue_QualifierValue();
  virtual ~MutationProto_ColumnValue_QualifierValue();

  MutationProto_ColumnValue_QualifierValue(const MutationProto_ColumnValue_QualifierValue& from);

  inline MutationProto_ColumnValue_QualifierValue& operator=(const MutationProto_ColumnValue_QualifierValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutationProto_ColumnValue_QualifierValue& default_instance();

  void Swap(MutationProto_ColumnValue_QualifierValue* other);

  // implements Message ----------------------------------------------

  MutationProto_ColumnValue_QualifierValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutationProto_ColumnValue_QualifierValue& from);
  void MergeFrom(const MutationProto_ColumnValue_QualifierValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes qualifier = 1;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 1;
  inline const ::std::string& qualifier() const;
  inline void set_qualifier(const ::std::string& value);
  inline void set_qualifier(const char* value);
  inline void set_qualifier(const void* value, size_t size);
  inline ::std::string* mutable_qualifier();
  inline ::std::string* release_qualifier();
  inline void set_allocated_qualifier(::std::string* qualifier);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .hbase.pb.MutationProto.DeleteType delete_type = 4;
  inline bool has_delete_type() const;
  inline void clear_delete_type();
  static const int kDeleteTypeFieldNumber = 4;
  inline ::hbase::pb::MutationProto_DeleteType delete_type() const;
  inline void set_delete_type(::hbase::pb::MutationProto_DeleteType value);

  // optional bytes tags = 5;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 5;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const void* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  inline void set_allocated_tags(::std::string* tags);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto.ColumnValue.QualifierValue)
 private:
  inline void set_has_qualifier();
  inline void clear_has_qualifier();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_delete_type();
  inline void clear_has_delete_type();
  inline void set_has_tags();
  inline void clear_has_tags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* qualifier_;
  ::std::string* value_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* tags_;
  int delete_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MutationProto_ColumnValue_QualifierValue* default_instance_;
};
// -------------------------------------------------------------------

class MutationProto_ColumnValue : public ::google::protobuf::Message {
 public:
  MutationProto_ColumnValue();
  virtual ~MutationProto_ColumnValue();

  MutationProto_ColumnValue(const MutationProto_ColumnValue& from);

  inline MutationProto_ColumnValue& operator=(const MutationProto_ColumnValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutationProto_ColumnValue& default_instance();

  void Swap(MutationProto_ColumnValue* other);

  // implements Message ----------------------------------------------

  MutationProto_ColumnValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutationProto_ColumnValue& from);
  void MergeFrom(const MutationProto_ColumnValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MutationProto_ColumnValue_QualifierValue QualifierValue;

  // accessors -------------------------------------------------------

  // required bytes family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // repeated .hbase.pb.MutationProto.ColumnValue.QualifierValue qualifier_value = 2;
  inline int qualifier_value_size() const;
  inline void clear_qualifier_value();
  static const int kQualifierValueFieldNumber = 2;
  inline const ::hbase::pb::MutationProto_ColumnValue_QualifierValue& qualifier_value(int index) const;
  inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* mutable_qualifier_value(int index);
  inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* add_qualifier_value();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >&
      qualifier_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >*
      mutable_qualifier_value();

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto.ColumnValue)
 private:
  inline void set_has_family();
  inline void clear_has_family();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue > qualifier_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MutationProto_ColumnValue* default_instance_;
};
// -------------------------------------------------------------------

class MutationProto : public ::google::protobuf::Message {
 public:
  MutationProto();
  virtual ~MutationProto();

  MutationProto(const MutationProto& from);

  inline MutationProto& operator=(const MutationProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutationProto& default_instance();

  void Swap(MutationProto* other);

  // implements Message ----------------------------------------------

  MutationProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutationProto& from);
  void MergeFrom(const MutationProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MutationProto_ColumnValue ColumnValue;

  typedef MutationProto_Durability Durability;
  static const Durability USE_DEFAULT = MutationProto_Durability_USE_DEFAULT;
  static const Durability SKIP_WAL = MutationProto_Durability_SKIP_WAL;
  static const Durability ASYNC_WAL = MutationProto_Durability_ASYNC_WAL;
  static const Durability SYNC_WAL = MutationProto_Durability_SYNC_WAL;
  static const Durability FSYNC_WAL = MutationProto_Durability_FSYNC_WAL;
  static inline bool Durability_IsValid(int value) {
    return MutationProto_Durability_IsValid(value);
  }
  static const Durability Durability_MIN =
    MutationProto_Durability_Durability_MIN;
  static const Durability Durability_MAX =
    MutationProto_Durability_Durability_MAX;
  static const int Durability_ARRAYSIZE =
    MutationProto_Durability_Durability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Durability_descriptor() {
    return MutationProto_Durability_descriptor();
  }
  static inline const ::std::string& Durability_Name(Durability value) {
    return MutationProto_Durability_Name(value);
  }
  static inline bool Durability_Parse(const ::std::string& name,
      Durability* value) {
    return MutationProto_Durability_Parse(name, value);
  }

  typedef MutationProto_MutationType MutationType;
  static const MutationType APPEND = MutationProto_MutationType_APPEND;
  static const MutationType INCREMENT = MutationProto_MutationType_INCREMENT;
  static const MutationType PUT = MutationProto_MutationType_PUT;
  static const MutationType DELETE = MutationProto_MutationType_DELETE;
  static inline bool MutationType_IsValid(int value) {
    return MutationProto_MutationType_IsValid(value);
  }
  static const MutationType MutationType_MIN =
    MutationProto_MutationType_MutationType_MIN;
  static const MutationType MutationType_MAX =
    MutationProto_MutationType_MutationType_MAX;
  static const int MutationType_ARRAYSIZE =
    MutationProto_MutationType_MutationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MutationType_descriptor() {
    return MutationProto_MutationType_descriptor();
  }
  static inline const ::std::string& MutationType_Name(MutationType value) {
    return MutationProto_MutationType_Name(value);
  }
  static inline bool MutationType_Parse(const ::std::string& name,
      MutationType* value) {
    return MutationProto_MutationType_Parse(name, value);
  }

  typedef MutationProto_DeleteType DeleteType;
  static const DeleteType DELETE_ONE_VERSION = MutationProto_DeleteType_DELETE_ONE_VERSION;
  static const DeleteType DELETE_MULTIPLE_VERSIONS = MutationProto_DeleteType_DELETE_MULTIPLE_VERSIONS;
  static const DeleteType DELETE_FAMILY = MutationProto_DeleteType_DELETE_FAMILY;
  static const DeleteType DELETE_FAMILY_VERSION = MutationProto_DeleteType_DELETE_FAMILY_VERSION;
  static inline bool DeleteType_IsValid(int value) {
    return MutationProto_DeleteType_IsValid(value);
  }
  static const DeleteType DeleteType_MIN =
    MutationProto_DeleteType_DeleteType_MIN;
  static const DeleteType DeleteType_MAX =
    MutationProto_DeleteType_DeleteType_MAX;
  static const int DeleteType_ARRAYSIZE =
    MutationProto_DeleteType_DeleteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeleteType_descriptor() {
    return MutationProto_DeleteType_descriptor();
  }
  static inline const ::std::string& DeleteType_Name(DeleteType value) {
    return MutationProto_DeleteType_Name(value);
  }
  static inline bool DeleteType_Parse(const ::std::string& name,
      DeleteType* value) {
    return MutationProto_DeleteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::std::string& row() const;
  inline void set_row(const ::std::string& value);
  inline void set_row(const char* value);
  inline void set_row(const void* value, size_t size);
  inline ::std::string* mutable_row();
  inline ::std::string* release_row();
  inline void set_allocated_row(::std::string* row);

  // optional .hbase.pb.MutationProto.MutationType mutate_type = 2;
  inline bool has_mutate_type() const;
  inline void clear_mutate_type();
  static const int kMutateTypeFieldNumber = 2;
  inline ::hbase::pb::MutationProto_MutationType mutate_type() const;
  inline void set_mutate_type(::hbase::pb::MutationProto_MutationType value);

  // repeated .hbase.pb.MutationProto.ColumnValue column_value = 3;
  inline int column_value_size() const;
  inline void clear_column_value();
  static const int kColumnValueFieldNumber = 3;
  inline const ::hbase::pb::MutationProto_ColumnValue& column_value(int index) const;
  inline ::hbase::pb::MutationProto_ColumnValue* mutable_column_value(int index);
  inline ::hbase::pb::MutationProto_ColumnValue* add_column_value();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >&
      column_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >*
      mutable_column_value();

  // optional uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .hbase.pb.NameBytesPair attribute = 5;
  inline int attribute_size() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  inline const ::hbase::pb::NameBytesPair& attribute(int index) const;
  inline ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  inline ::hbase::pb::NameBytesPair* add_attribute();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();

  // optional .hbase.pb.MutationProto.Durability durability = 6 [default = USE_DEFAULT];
  inline bool has_durability() const;
  inline void clear_durability();
  static const int kDurabilityFieldNumber = 6;
  inline ::hbase::pb::MutationProto_Durability durability() const;
  inline void set_durability(::hbase::pb::MutationProto_Durability value);

  // optional .hbase.pb.TimeRange time_range = 7;
  inline bool has_time_range() const;
  inline void clear_time_range();
  static const int kTimeRangeFieldNumber = 7;
  inline const ::hbase::pb::TimeRange& time_range() const;
  inline ::hbase::pb::TimeRange* mutable_time_range();
  inline ::hbase::pb::TimeRange* release_time_range();
  inline void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional int32 associated_cell_count = 8;
  inline bool has_associated_cell_count() const;
  inline void clear_associated_cell_count();
  static const int kAssociatedCellCountFieldNumber = 8;
  inline ::google::protobuf::int32 associated_cell_count() const;
  inline void set_associated_cell_count(::google::protobuf::int32 value);

  // optional uint64 nonce = 9;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 9;
  inline ::google::protobuf::uint64 nonce() const;
  inline void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_mutate_type();
  inline void clear_has_mutate_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_durability();
  inline void clear_has_durability();
  inline void set_has_time_range();
  inline void clear_has_time_range();
  inline void set_has_associated_cell_count();
  inline void clear_has_associated_cell_count();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* row_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue > column_value_;
  ::google::protobuf::uint64 timestamp_;
  int mutate_type_;
  int durability_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::hbase::pb::TimeRange* time_range_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::int32 associated_cell_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MutationProto* default_instance_;
};
// -------------------------------------------------------------------

class MutateRequest : public ::google::protobuf::Message {
 public:
  MutateRequest();
  virtual ~MutateRequest();

  MutateRequest(const MutateRequest& from);

  inline MutateRequest& operator=(const MutateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutateRequest& default_instance();

  void Swap(MutateRequest* other);

  // implements Message ----------------------------------------------

  MutateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutateRequest& from);
  void MergeFrom(const MutateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.MutationProto mutation = 2;
  inline bool has_mutation() const;
  inline void clear_mutation();
  static const int kMutationFieldNumber = 2;
  inline const ::hbase::pb::MutationProto& mutation() const;
  inline ::hbase::pb::MutationProto* mutable_mutation();
  inline ::hbase::pb::MutationProto* release_mutation();
  inline void set_allocated_mutation(::hbase::pb::MutationProto* mutation);

  // optional .hbase.pb.Condition condition = 3;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 3;
  inline const ::hbase::pb::Condition& condition() const;
  inline ::hbase::pb::Condition* mutable_condition();
  inline ::hbase::pb::Condition* release_condition();
  inline void set_allocated_condition(::hbase::pb::Condition* condition);

  // optional uint64 nonce_group = 4;
  inline bool has_nonce_group() const;
  inline void clear_nonce_group();
  static const int kNonceGroupFieldNumber = 4;
  inline ::google::protobuf::uint64 nonce_group() const;
  inline void set_nonce_group(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutateRequest)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_mutation();
  inline void clear_has_mutation();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_nonce_group();
  inline void clear_has_nonce_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::MutationProto* mutation_;
  ::hbase::pb::Condition* condition_;
  ::google::protobuf::uint64 nonce_group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MutateRequest* default_instance_;
};
// -------------------------------------------------------------------

class MutateResponse : public ::google::protobuf::Message {
 public:
  MutateResponse();
  virtual ~MutateResponse();

  MutateResponse(const MutateResponse& from);

  inline MutateResponse& operator=(const MutateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutateResponse& default_instance();

  void Swap(MutateResponse* other);

  // implements Message ----------------------------------------------

  MutateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutateResponse& from);
  void MergeFrom(const MutateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::hbase::pb::Result& result() const;
  inline ::hbase::pb::Result* mutable_result();
  inline ::hbase::pb::Result* release_result();
  inline void set_allocated_result(::hbase::pb::Result* result);

  // optional bool processed = 2;
  inline bool has_processed() const;
  inline void clear_processed();
  static const int kProcessedFieldNumber = 2;
  inline bool processed() const;
  inline void set_processed(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_processed();
  inline void clear_has_processed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Result* result_;
  bool processed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MutateResponse* default_instance_;
};
// -------------------------------------------------------------------

class Scan : public ::google::protobuf::Message {
 public:
  Scan();
  virtual ~Scan();

  Scan(const Scan& from);

  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scan& default_instance();

  void Swap(Scan* other);

  // implements Message ----------------------------------------------

  Scan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.Column column = 1;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline const ::hbase::pb::Column& column(int index) const;
  inline ::hbase::pb::Column* mutable_column(int index);
  inline ::hbase::pb::Column* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >*
      mutable_column();

  // repeated .hbase.pb.NameBytesPair attribute = 2;
  inline int attribute_size() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 2;
  inline const ::hbase::pb::NameBytesPair& attribute(int index) const;
  inline ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  inline ::hbase::pb::NameBytesPair* add_attribute();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();

  // optional bytes start_row = 3;
  inline bool has_start_row() const;
  inline void clear_start_row();
  static const int kStartRowFieldNumber = 3;
  inline const ::std::string& start_row() const;
  inline void set_start_row(const ::std::string& value);
  inline void set_start_row(const char* value);
  inline void set_start_row(const void* value, size_t size);
  inline ::std::string* mutable_start_row();
  inline ::std::string* release_start_row();
  inline void set_allocated_start_row(::std::string* start_row);

  // optional bytes stop_row = 4;
  inline bool has_stop_row() const;
  inline void clear_stop_row();
  static const int kStopRowFieldNumber = 4;
  inline const ::std::string& stop_row() const;
  inline void set_stop_row(const ::std::string& value);
  inline void set_stop_row(const char* value);
  inline void set_stop_row(const void* value, size_t size);
  inline ::std::string* mutable_stop_row();
  inline ::std::string* release_stop_row();
  inline void set_allocated_stop_row(::std::string* stop_row);

  // optional .hbase.pb.Filter filter = 5;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 5;
  inline const ::hbase::pb::Filter& filter() const;
  inline ::hbase::pb::Filter* mutable_filter();
  inline ::hbase::pb::Filter* release_filter();
  inline void set_allocated_filter(::hbase::pb::Filter* filter);

  // optional .hbase.pb.TimeRange time_range = 6;
  inline bool has_time_range() const;
  inline void clear_time_range();
  static const int kTimeRangeFieldNumber = 6;
  inline const ::hbase::pb::TimeRange& time_range() const;
  inline ::hbase::pb::TimeRange* mutable_time_range();
  inline ::hbase::pb::TimeRange* release_time_range();
  inline void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional uint32 max_versions = 7 [default = 1];
  inline bool has_max_versions() const;
  inline void clear_max_versions();
  static const int kMaxVersionsFieldNumber = 7;
  inline ::google::protobuf::uint32 max_versions() const;
  inline void set_max_versions(::google::protobuf::uint32 value);

  // optional bool cache_blocks = 8 [default = true];
  inline bool has_cache_blocks() const;
  inline void clear_cache_blocks();
  static const int kCacheBlocksFieldNumber = 8;
  inline bool cache_blocks() const;
  inline void set_cache_blocks(bool value);

  // optional uint32 batch_size = 9;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 batch_size() const;
  inline void set_batch_size(::google::protobuf::uint32 value);

  // optional uint64 max_result_size = 10;
  inline bool has_max_result_size() const;
  inline void clear_max_result_size();
  static const int kMaxResultSizeFieldNumber = 10;
  inline ::google::protobuf::uint64 max_result_size() const;
  inline void set_max_result_size(::google::protobuf::uint64 value);

  // optional uint32 store_limit = 11;
  inline bool has_store_limit() const;
  inline void clear_store_limit();
  static const int kStoreLimitFieldNumber = 11;
  inline ::google::protobuf::uint32 store_limit() const;
  inline void set_store_limit(::google::protobuf::uint32 value);

  // optional uint32 store_offset = 12;
  inline bool has_store_offset() const;
  inline void clear_store_offset();
  static const int kStoreOffsetFieldNumber = 12;
  inline ::google::protobuf::uint32 store_offset() const;
  inline void set_store_offset(::google::protobuf::uint32 value);

  // optional bool load_column_families_on_demand = 13;
  inline bool has_load_column_families_on_demand() const;
  inline void clear_load_column_families_on_demand();
  static const int kLoadColumnFamiliesOnDemandFieldNumber = 13;
  inline bool load_column_families_on_demand() const;
  inline void set_load_column_families_on_demand(bool value);

  // optional bool small = 14;
  inline bool has_small() const;
  inline void clear_small();
  static const int kSmallFieldNumber = 14;
  inline bool small() const;
  inline void set_small(bool value);

  // optional bool reversed = 15 [default = false];
  inline bool has_reversed() const;
  inline void clear_reversed();
  static const int kReversedFieldNumber = 15;
  inline bool reversed() const;
  inline void set_reversed(bool value);

  // optional .hbase.pb.Consistency consistency = 16 [default = STRONG];
  inline bool has_consistency() const;
  inline void clear_consistency();
  static const int kConsistencyFieldNumber = 16;
  inline ::hbase::pb::Consistency consistency() const;
  inline void set_consistency(::hbase::pb::Consistency value);

  // optional uint32 caching = 17;
  inline bool has_caching() const;
  inline void clear_caching();
  static const int kCachingFieldNumber = 17;
  inline ::google::protobuf::uint32 caching() const;
  inline void set_caching(::google::protobuf::uint32 value);

  // optional bool allow_partial_results = 18;
  inline bool has_allow_partial_results() const;
  inline void clear_allow_partial_results();
  static const int kAllowPartialResultsFieldNumber = 18;
  inline bool allow_partial_results() const;
  inline void set_allow_partial_results(bool value);

  // repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 19;
  inline int cf_time_range_size() const;
  inline void clear_cf_time_range();
  static const int kCfTimeRangeFieldNumber = 19;
  inline const ::hbase::pb::ColumnFamilyTimeRange& cf_time_range(int index) const;
  inline ::hbase::pb::ColumnFamilyTimeRange* mutable_cf_time_range(int index);
  inline ::hbase::pb::ColumnFamilyTimeRange* add_cf_time_range();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
      cf_time_range() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
      mutable_cf_time_range();

  // @@protoc_insertion_point(class_scope:hbase.pb.Scan)
 private:
  inline void set_has_start_row();
  inline void clear_has_start_row();
  inline void set_has_stop_row();
  inline void clear_has_stop_row();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_time_range();
  inline void clear_has_time_range();
  inline void set_has_max_versions();
  inline void clear_has_max_versions();
  inline void set_has_cache_blocks();
  inline void clear_has_cache_blocks();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_max_result_size();
  inline void clear_has_max_result_size();
  inline void set_has_store_limit();
  inline void clear_has_store_limit();
  inline void set_has_store_offset();
  inline void clear_has_store_offset();
  inline void set_has_load_column_families_on_demand();
  inline void clear_has_load_column_families_on_demand();
  inline void set_has_small();
  inline void clear_has_small();
  inline void set_has_reversed();
  inline void clear_has_reversed();
  inline void set_has_consistency();
  inline void clear_has_consistency();
  inline void set_has_caching();
  inline void clear_has_caching();
  inline void set_has_allow_partial_results();
  inline void clear_has_allow_partial_results();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column > column_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::std::string* start_row_;
  ::std::string* stop_row_;
  ::hbase::pb::Filter* filter_;
  ::hbase::pb::TimeRange* time_range_;
  ::google::protobuf::uint32 max_versions_;
  ::google::protobuf::uint32 batch_size_;
  ::google::protobuf::uint64 max_result_size_;
  ::google::protobuf::uint32 store_limit_;
  ::google::protobuf::uint32 store_offset_;
  bool cache_blocks_;
  bool load_column_families_on_demand_;
  bool small_;
  bool reversed_;
  int consistency_;
  ::google::protobuf::uint32 caching_;
  bool allow_partial_results_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange > cf_time_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Scan* default_instance_;
};
// -------------------------------------------------------------------

class ScanRequest : public ::google::protobuf::Message {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanRequest& default_instance();

  void Swap(ScanRequest* other);

  // implements Message ----------------------------------------------

  ScanRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // optional .hbase.pb.Scan scan = 2;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 2;
  inline const ::hbase::pb::Scan& scan() const;
  inline ::hbase::pb::Scan* mutable_scan();
  inline ::hbase::pb::Scan* release_scan();
  inline void set_allocated_scan(::hbase::pb::Scan* scan);

  // optional uint64 scanner_id = 3;
  inline bool has_scanner_id() const;
  inline void clear_scanner_id();
  static const int kScannerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 scanner_id() const;
  inline void set_scanner_id(::google::protobuf::uint64 value);

  // optional uint32 number_of_rows = 4;
  inline bool has_number_of_rows() const;
  inline void clear_number_of_rows();
  static const int kNumberOfRowsFieldNumber = 4;
  inline ::google::protobuf::uint32 number_of_rows() const;
  inline void set_number_of_rows(::google::protobuf::uint32 value);

  // optional bool close_scanner = 5;
  inline bool has_close_scanner() const;
  inline void clear_close_scanner();
  static const int kCloseScannerFieldNumber = 5;
  inline bool close_scanner() const;
  inline void set_close_scanner(bool value);

  // optional uint64 next_call_seq = 6;
  inline bool has_next_call_seq() const;
  inline void clear_next_call_seq();
  static const int kNextCallSeqFieldNumber = 6;
  inline ::google::protobuf::uint64 next_call_seq() const;
  inline void set_next_call_seq(::google::protobuf::uint64 value);

  // optional bool client_handles_partials = 7;
  inline bool has_client_handles_partials() const;
  inline void clear_client_handles_partials();
  static const int kClientHandlesPartialsFieldNumber = 7;
  inline bool client_handles_partials() const;
  inline void set_client_handles_partials(bool value);

  // optional bool client_handles_heartbeats = 8;
  inline bool has_client_handles_heartbeats() const;
  inline void clear_client_handles_heartbeats();
  static const int kClientHandlesHeartbeatsFieldNumber = 8;
  inline bool client_handles_heartbeats() const;
  inline void set_client_handles_heartbeats(bool value);

  // optional bool track_scan_metrics = 9;
  inline bool has_track_scan_metrics() const;
  inline void clear_track_scan_metrics();
  static const int kTrackScanMetricsFieldNumber = 9;
  inline bool track_scan_metrics() const;
  inline void set_track_scan_metrics(bool value);

  // optional bool renew = 10 [default = false];
  inline bool has_renew() const;
  inline void clear_renew();
  static const int kRenewFieldNumber = 10;
  inline bool renew() const;
  inline void set_renew(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ScanRequest)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_scanner_id();
  inline void clear_has_scanner_id();
  inline void set_has_number_of_rows();
  inline void clear_has_number_of_rows();
  inline void set_has_close_scanner();
  inline void clear_has_close_scanner();
  inline void set_has_next_call_seq();
  inline void clear_has_next_call_seq();
  inline void set_has_client_handles_partials();
  inline void clear_has_client_handles_partials();
  inline void set_has_client_handles_heartbeats();
  inline void clear_has_client_handles_heartbeats();
  inline void set_has_track_scan_metrics();
  inline void clear_has_track_scan_metrics();
  inline void set_has_renew();
  inline void clear_has_renew();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::Scan* scan_;
  ::google::protobuf::uint64 scanner_id_;
  ::google::protobuf::uint64 next_call_seq_;
  ::google::protobuf::uint32 number_of_rows_;
  bool close_scanner_;
  bool client_handles_partials_;
  bool client_handles_heartbeats_;
  bool track_scan_metrics_;
  bool renew_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static ScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class ScanResponse : public ::google::protobuf::Message {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanResponse& default_instance();

  void Swap(ScanResponse* other);

  // implements Message ----------------------------------------------

  ScanResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 cells_per_result = 1;
  inline int cells_per_result_size() const;
  inline void clear_cells_per_result();
  static const int kCellsPerResultFieldNumber = 1;
  inline ::google::protobuf::uint32 cells_per_result(int index) const;
  inline void set_cells_per_result(int index, ::google::protobuf::uint32 value);
  inline void add_cells_per_result(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cells_per_result() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cells_per_result();

  // optional uint64 scanner_id = 2;
  inline bool has_scanner_id() const;
  inline void clear_scanner_id();
  static const int kScannerIdFieldNumber = 2;
  inline ::google::protobuf::uint64 scanner_id() const;
  inline void set_scanner_id(::google::protobuf::uint64 value);

  // optional bool more_results = 3;
  inline bool has_more_results() const;
  inline void clear_more_results();
  static const int kMoreResultsFieldNumber = 3;
  inline bool more_results() const;
  inline void set_more_results(bool value);

  // optional uint32 ttl = 4;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 4;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // repeated .hbase.pb.Result results = 5;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 5;
  inline const ::hbase::pb::Result& results(int index) const;
  inline ::hbase::pb::Result* mutable_results(int index);
  inline ::hbase::pb::Result* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Result >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Result >*
      mutable_results();

  // optional bool stale = 6;
  inline bool has_stale() const;
  inline void clear_stale();
  static const int kStaleFieldNumber = 6;
  inline bool stale() const;
  inline void set_stale(bool value);

  // repeated bool partial_flag_per_result = 7;
  inline int partial_flag_per_result_size() const;
  inline void clear_partial_flag_per_result();
  static const int kPartialFlagPerResultFieldNumber = 7;
  inline bool partial_flag_per_result(int index) const;
  inline void set_partial_flag_per_result(int index, bool value);
  inline void add_partial_flag_per_result(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      partial_flag_per_result() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_partial_flag_per_result();

  // optional bool more_results_in_region = 8;
  inline bool has_more_results_in_region() const;
  inline void clear_more_results_in_region();
  static const int kMoreResultsInRegionFieldNumber = 8;
  inline bool more_results_in_region() const;
  inline void set_more_results_in_region(bool value);

  // optional bool heartbeat_message = 9;
  inline bool has_heartbeat_message() const;
  inline void clear_heartbeat_message();
  static const int kHeartbeatMessageFieldNumber = 9;
  inline bool heartbeat_message() const;
  inline void set_heartbeat_message(bool value);

  // optional .hbase.pb.ScanMetrics scan_metrics = 10;
  inline bool has_scan_metrics() const;
  inline void clear_scan_metrics();
  static const int kScanMetricsFieldNumber = 10;
  inline const ::hbase::pb::ScanMetrics& scan_metrics() const;
  inline ::hbase::pb::ScanMetrics* mutable_scan_metrics();
  inline ::hbase::pb::ScanMetrics* release_scan_metrics();
  inline void set_allocated_scan_metrics(::hbase::pb::ScanMetrics* scan_metrics);

  // @@protoc_insertion_point(class_scope:hbase.pb.ScanResponse)
 private:
  inline void set_has_scanner_id();
  inline void clear_has_scanner_id();
  inline void set_has_more_results();
  inline void clear_has_more_results();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_stale();
  inline void clear_has_stale();
  inline void set_has_more_results_in_region();
  inline void clear_has_more_results_in_region();
  inline void set_has_heartbeat_message();
  inline void clear_has_heartbeat_message();
  inline void set_has_scan_metrics();
  inline void clear_has_scan_metrics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cells_per_result_;
  ::google::protobuf::uint64 scanner_id_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Result > results_;
  ::google::protobuf::uint32 ttl_;
  bool more_results_;
  bool stale_;
  bool more_results_in_region_;
  bool heartbeat_message_;
  ::google::protobuf::RepeatedField< bool > partial_flag_per_result_;
  ::hbase::pb::ScanMetrics* scan_metrics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static ScanResponse* default_instance_;
};
// -------------------------------------------------------------------

class BulkLoadHFileRequest_FamilyPath : public ::google::protobuf::Message {
 public:
  BulkLoadHFileRequest_FamilyPath();
  virtual ~BulkLoadHFileRequest_FamilyPath();

  BulkLoadHFileRequest_FamilyPath(const BulkLoadHFileRequest_FamilyPath& from);

  inline BulkLoadHFileRequest_FamilyPath& operator=(const BulkLoadHFileRequest_FamilyPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulkLoadHFileRequest_FamilyPath& default_instance();

  void Swap(BulkLoadHFileRequest_FamilyPath* other);

  // implements Message ----------------------------------------------

  BulkLoadHFileRequest_FamilyPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulkLoadHFileRequest_FamilyPath& from);
  void MergeFrom(const BulkLoadHFileRequest_FamilyPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const void* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileRequest.FamilyPath)
 private:
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static BulkLoadHFileRequest_FamilyPath* default_instance_;
};
// -------------------------------------------------------------------

class BulkLoadHFileRequest : public ::google::protobuf::Message {
 public:
  BulkLoadHFileRequest();
  virtual ~BulkLoadHFileRequest();

  BulkLoadHFileRequest(const BulkLoadHFileRequest& from);

  inline BulkLoadHFileRequest& operator=(const BulkLoadHFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulkLoadHFileRequest& default_instance();

  void Swap(BulkLoadHFileRequest* other);

  // implements Message ----------------------------------------------

  BulkLoadHFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulkLoadHFileRequest& from);
  void MergeFrom(const BulkLoadHFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BulkLoadHFileRequest_FamilyPath FamilyPath;

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 2;
  inline int family_path_size() const;
  inline void clear_family_path();
  static const int kFamilyPathFieldNumber = 2;
  inline const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& family_path(int index) const;
  inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* mutable_family_path(int index);
  inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* add_family_path();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
      family_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
      mutable_family_path();

  // optional bool assign_seq_num = 3;
  inline bool has_assign_seq_num() const;
  inline void clear_assign_seq_num();
  static const int kAssignSeqNumFieldNumber = 3;
  inline bool assign_seq_num() const;
  inline void set_assign_seq_num(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileRequest)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_assign_seq_num();
  inline void clear_has_assign_seq_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath > family_path_;
  bool assign_seq_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static BulkLoadHFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class BulkLoadHFileResponse : public ::google::protobuf::Message {
 public:
  BulkLoadHFileResponse();
  virtual ~BulkLoadHFileResponse();

  BulkLoadHFileResponse(const BulkLoadHFileResponse& from);

  inline BulkLoadHFileResponse& operator=(const BulkLoadHFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulkLoadHFileResponse& default_instance();

  void Swap(BulkLoadHFileResponse* other);

  // implements Message ----------------------------------------------

  BulkLoadHFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulkLoadHFileResponse& from);
  void MergeFrom(const BulkLoadHFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool loaded = 1;
  inline bool has_loaded() const;
  inline void clear_loaded();
  static const int kLoadedFieldNumber = 1;
  inline bool loaded() const;
  inline void set_loaded(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileResponse)
 private:
  inline void set_has_loaded();
  inline void clear_has_loaded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool loaded_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static BulkLoadHFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CoprocessorServiceCall : public ::google::protobuf::Message {
 public:
  CoprocessorServiceCall();
  virtual ~CoprocessorServiceCall();

  CoprocessorServiceCall(const CoprocessorServiceCall& from);

  inline CoprocessorServiceCall& operator=(const CoprocessorServiceCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoprocessorServiceCall& default_instance();

  void Swap(CoprocessorServiceCall* other);

  // implements Message ----------------------------------------------

  CoprocessorServiceCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoprocessorServiceCall& from);
  void MergeFrom(const CoprocessorServiceCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::std::string& row() const;
  inline void set_row(const ::std::string& value);
  inline void set_row(const char* value);
  inline void set_row(const void* value, size_t size);
  inline ::std::string* mutable_row();
  inline ::std::string* release_row();
  inline void set_allocated_row(::std::string* row);

  // required string service_name = 2;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 2;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // required string method_name = 3;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 3;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // required bytes request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  inline void set_allocated_request(::std::string* request);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceCall)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_method_name();
  inline void clear_has_method_name();
  inline void set_has_request();
  inline void clear_has_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* row_;
  ::std::string* service_name_;
  ::std::string* method_name_;
  ::std::string* request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static CoprocessorServiceCall* default_instance_;
};
// -------------------------------------------------------------------

class CoprocessorServiceResult : public ::google::protobuf::Message {
 public:
  CoprocessorServiceResult();
  virtual ~CoprocessorServiceResult();

  CoprocessorServiceResult(const CoprocessorServiceResult& from);

  inline CoprocessorServiceResult& operator=(const CoprocessorServiceResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoprocessorServiceResult& default_instance();

  void Swap(CoprocessorServiceResult* other);

  // implements Message ----------------------------------------------

  CoprocessorServiceResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoprocessorServiceResult& from);
  void MergeFrom(const CoprocessorServiceResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.NameBytesPair value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::hbase::pb::NameBytesPair& value() const;
  inline ::hbase::pb::NameBytesPair* mutable_value();
  inline ::hbase::pb::NameBytesPair* release_value();
  inline void set_allocated_value(::hbase::pb::NameBytesPair* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceResult)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::NameBytesPair* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static CoprocessorServiceResult* default_instance_;
};
// -------------------------------------------------------------------

class CoprocessorServiceRequest : public ::google::protobuf::Message {
 public:
  CoprocessorServiceRequest();
  virtual ~CoprocessorServiceRequest();

  CoprocessorServiceRequest(const CoprocessorServiceRequest& from);

  inline CoprocessorServiceRequest& operator=(const CoprocessorServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoprocessorServiceRequest& default_instance();

  void Swap(CoprocessorServiceRequest* other);

  // implements Message ----------------------------------------------

  CoprocessorServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoprocessorServiceRequest& from);
  void MergeFrom(const CoprocessorServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.CoprocessorServiceCall call = 2;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 2;
  inline const ::hbase::pb::CoprocessorServiceCall& call() const;
  inline ::hbase::pb::CoprocessorServiceCall* mutable_call();
  inline ::hbase::pb::CoprocessorServiceCall* release_call();
  inline void set_allocated_call(::hbase::pb::CoprocessorServiceCall* call);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceRequest)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_call();
  inline void clear_has_call();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::CoprocessorServiceCall* call_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static CoprocessorServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class CoprocessorServiceResponse : public ::google::protobuf::Message {
 public:
  CoprocessorServiceResponse();
  virtual ~CoprocessorServiceResponse();

  CoprocessorServiceResponse(const CoprocessorServiceResponse& from);

  inline CoprocessorServiceResponse& operator=(const CoprocessorServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoprocessorServiceResponse& default_instance();

  void Swap(CoprocessorServiceResponse* other);

  // implements Message ----------------------------------------------

  CoprocessorServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoprocessorServiceResponse& from);
  void MergeFrom(const CoprocessorServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.NameBytesPair value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::hbase::pb::NameBytesPair& value() const;
  inline ::hbase::pb::NameBytesPair* mutable_value();
  inline ::hbase::pb::NameBytesPair* release_value();
  inline void set_allocated_value(::hbase::pb::NameBytesPair* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceResponse)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::NameBytesPair* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static CoprocessorServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .hbase.pb.MutationProto mutation = 2;
  inline bool has_mutation() const;
  inline void clear_mutation();
  static const int kMutationFieldNumber = 2;
  inline const ::hbase::pb::MutationProto& mutation() const;
  inline ::hbase::pb::MutationProto* mutable_mutation();
  inline ::hbase::pb::MutationProto* release_mutation();
  inline void set_allocated_mutation(::hbase::pb::MutationProto* mutation);

  // optional .hbase.pb.Get get = 3;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 3;
  inline const ::hbase::pb::Get& get() const;
  inline ::hbase::pb::Get* mutable_get();
  inline ::hbase::pb::Get* release_get();
  inline void set_allocated_get(::hbase::pb::Get* get);

  // optional .hbase.pb.CoprocessorServiceCall service_call = 4;
  inline bool has_service_call() const;
  inline void clear_service_call();
  static const int kServiceCallFieldNumber = 4;
  inline const ::hbase::pb::CoprocessorServiceCall& service_call() const;
  inline ::hbase::pb::CoprocessorServiceCall* mutable_service_call();
  inline ::hbase::pb::CoprocessorServiceCall* release_service_call();
  inline void set_allocated_service_call(::hbase::pb::CoprocessorServiceCall* service_call);

  // @@protoc_insertion_point(class_scope:hbase.pb.Action)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_mutation();
  inline void clear_has_mutation();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_service_call();
  inline void clear_has_service_call();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::MutationProto* mutation_;
  ::hbase::pb::Get* get_;
  ::hbase::pb::CoprocessorServiceCall* service_call_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class RegionAction : public ::google::protobuf::Message {
 public:
  RegionAction();
  virtual ~RegionAction();

  RegionAction(const RegionAction& from);

  inline RegionAction& operator=(const RegionAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionAction& default_instance();

  void Swap(RegionAction* other);

  // implements Message ----------------------------------------------

  RegionAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionAction& from);
  void MergeFrom(const RegionAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.RegionSpecifier region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region() const;
  inline ::hbase::pb::RegionSpecifier* mutable_region();
  inline ::hbase::pb::RegionSpecifier* release_region();
  inline void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // optional bool atomic = 2;
  inline bool has_atomic() const;
  inline void clear_atomic();
  static const int kAtomicFieldNumber = 2;
  inline bool atomic() const;
  inline void set_atomic(bool value);

  // repeated .hbase.pb.Action action = 3;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline const ::hbase::pb::Action& action(int index) const;
  inline ::hbase::pb::Action* mutable_action(int index);
  inline ::hbase::pb::Action* add_action();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Action >&
      action() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Action >*
      mutable_action();

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionAction)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_atomic();
  inline void clear_has_atomic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::RegionSpecifier* region_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::Action > action_;
  bool atomic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static RegionAction* default_instance_;
};
// -------------------------------------------------------------------

class RegionLoadStats : public ::google::protobuf::Message {
 public:
  RegionLoadStats();
  virtual ~RegionLoadStats();

  RegionLoadStats(const RegionLoadStats& from);

  inline RegionLoadStats& operator=(const RegionLoadStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionLoadStats& default_instance();

  void Swap(RegionLoadStats* other);

  // implements Message ----------------------------------------------

  RegionLoadStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionLoadStats& from);
  void MergeFrom(const RegionLoadStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 memstoreLoad = 1 [default = 0];
  inline bool has_memstoreload() const;
  inline void clear_memstoreload();
  static const int kMemstoreLoadFieldNumber = 1;
  inline ::google::protobuf::int32 memstoreload() const;
  inline void set_memstoreload(::google::protobuf::int32 value);

  // optional int32 heapOccupancy = 2 [default = 0];
  inline bool has_heapoccupancy() const;
  inline void clear_heapoccupancy();
  static const int kHeapOccupancyFieldNumber = 2;
  inline ::google::protobuf::int32 heapoccupancy() const;
  inline void set_heapoccupancy(::google::protobuf::int32 value);

  // optional int32 compactionPressure = 3 [default = 0];
  inline bool has_compactionpressure() const;
  inline void clear_compactionpressure();
  static const int kCompactionPressureFieldNumber = 3;
  inline ::google::protobuf::int32 compactionpressure() const;
  inline void set_compactionpressure(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionLoadStats)
 private:
  inline void set_has_memstoreload();
  inline void clear_has_memstoreload();
  inline void set_has_heapoccupancy();
  inline void clear_has_heapoccupancy();
  inline void set_has_compactionpressure();
  inline void clear_has_compactionpressure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 memstoreload_;
  ::google::protobuf::int32 heapoccupancy_;
  ::google::protobuf::int32 compactionpressure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static RegionLoadStats* default_instance_;
};
// -------------------------------------------------------------------

class MultiRegionLoadStats : public ::google::protobuf::Message {
 public:
  MultiRegionLoadStats();
  virtual ~MultiRegionLoadStats();

  MultiRegionLoadStats(const MultiRegionLoadStats& from);

  inline MultiRegionLoadStats& operator=(const MultiRegionLoadStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiRegionLoadStats& default_instance();

  void Swap(MultiRegionLoadStats* other);

  // implements Message ----------------------------------------------

  MultiRegionLoadStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiRegionLoadStats& from);
  void MergeFrom(const MultiRegionLoadStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.RegionSpecifier region = 1;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline const ::hbase::pb::RegionSpecifier& region(int index) const;
  inline ::hbase::pb::RegionSpecifier* mutable_region(int index);
  inline ::hbase::pb::RegionSpecifier* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionSpecifier >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionSpecifier >*
      mutable_region();

  // repeated .hbase.pb.RegionLoadStats stat = 2;
  inline int stat_size() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline const ::hbase::pb::RegionLoadStats& stat(int index) const;
  inline ::hbase::pb::RegionLoadStats* mutable_stat(int index);
  inline ::hbase::pb::RegionLoadStats* add_stat();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionLoadStats >&
      stat() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionLoadStats >*
      mutable_stat();

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRegionLoadStats)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionSpecifier > region_;
  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionLoadStats > stat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MultiRegionLoadStats* default_instance_;
};
// -------------------------------------------------------------------

class ResultOrException : public ::google::protobuf::Message {
 public:
  ResultOrException();
  virtual ~ResultOrException();

  ResultOrException(const ResultOrException& from);

  inline ResultOrException& operator=(const ResultOrException& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultOrException& default_instance();

  void Swap(ResultOrException* other);

  // implements Message ----------------------------------------------

  ResultOrException* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultOrException& from);
  void MergeFrom(const ResultOrException& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .hbase.pb.Result result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::hbase::pb::Result& result() const;
  inline ::hbase::pb::Result* mutable_result();
  inline ::hbase::pb::Result* release_result();
  inline void set_allocated_result(::hbase::pb::Result* result);

  // optional .hbase.pb.NameBytesPair exception = 3;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 3;
  inline const ::hbase::pb::NameBytesPair& exception() const;
  inline ::hbase::pb::NameBytesPair* mutable_exception();
  inline ::hbase::pb::NameBytesPair* release_exception();
  inline void set_allocated_exception(::hbase::pb::NameBytesPair* exception);

  // optional .hbase.pb.CoprocessorServiceResult service_result = 4;
  inline bool has_service_result() const;
  inline void clear_service_result();
  static const int kServiceResultFieldNumber = 4;
  inline const ::hbase::pb::CoprocessorServiceResult& service_result() const;
  inline ::hbase::pb::CoprocessorServiceResult* mutable_service_result();
  inline ::hbase::pb::CoprocessorServiceResult* release_service_result();
  inline void set_allocated_service_result(::hbase::pb::CoprocessorServiceResult* service_result);

  // optional .hbase.pb.RegionLoadStats loadStats = 5 [deprecated = true];
  inline bool has_loadstats() const PROTOBUF_DEPRECATED;
  inline void clear_loadstats() PROTOBUF_DEPRECATED;
  static const int kLoadStatsFieldNumber = 5;
  inline const ::hbase::pb::RegionLoadStats& loadstats() const PROTOBUF_DEPRECATED;
  inline ::hbase::pb::RegionLoadStats* mutable_loadstats() PROTOBUF_DEPRECATED;
  inline ::hbase::pb::RegionLoadStats* release_loadstats() PROTOBUF_DEPRECATED;
  inline void set_allocated_loadstats(::hbase::pb::RegionLoadStats* loadstats) PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:hbase.pb.ResultOrException)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_exception();
  inline void clear_has_exception();
  inline void set_has_service_result();
  inline void clear_has_service_result();
  inline void set_has_loadstats();
  inline void clear_has_loadstats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Result* result_;
  ::hbase::pb::NameBytesPair* exception_;
  ::hbase::pb::CoprocessorServiceResult* service_result_;
  ::hbase::pb::RegionLoadStats* loadstats_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static ResultOrException* default_instance_;
};
// -------------------------------------------------------------------

class RegionActionResult : public ::google::protobuf::Message {
 public:
  RegionActionResult();
  virtual ~RegionActionResult();

  RegionActionResult(const RegionActionResult& from);

  inline RegionActionResult& operator=(const RegionActionResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionActionResult& default_instance();

  void Swap(RegionActionResult* other);

  // implements Message ----------------------------------------------

  RegionActionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionActionResult& from);
  void MergeFrom(const RegionActionResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.ResultOrException resultOrException = 1;
  inline int resultorexception_size() const;
  inline void clear_resultorexception();
  static const int kResultOrExceptionFieldNumber = 1;
  inline const ::hbase::pb::ResultOrException& resultorexception(int index) const;
  inline ::hbase::pb::ResultOrException* mutable_resultorexception(int index);
  inline ::hbase::pb::ResultOrException* add_resultorexception();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ResultOrException >&
      resultorexception() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ResultOrException >*
      mutable_resultorexception();

  // optional .hbase.pb.NameBytesPair exception = 2;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 2;
  inline const ::hbase::pb::NameBytesPair& exception() const;
  inline ::hbase::pb::NameBytesPair* mutable_exception();
  inline ::hbase::pb::NameBytesPair* release_exception();
  inline void set_allocated_exception(::hbase::pb::NameBytesPair* exception);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionActionResult)
 private:
  inline void set_has_exception();
  inline void clear_has_exception();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::ResultOrException > resultorexception_;
  ::hbase::pb::NameBytesPair* exception_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static RegionActionResult* default_instance_;
};
// -------------------------------------------------------------------

class MultiRequest : public ::google::protobuf::Message {
 public:
  MultiRequest();
  virtual ~MultiRequest();

  MultiRequest(const MultiRequest& from);

  inline MultiRequest& operator=(const MultiRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiRequest& default_instance();

  void Swap(MultiRequest* other);

  // implements Message ----------------------------------------------

  MultiRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiRequest& from);
  void MergeFrom(const MultiRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.RegionAction regionAction = 1;
  inline int regionaction_size() const;
  inline void clear_regionaction();
  static const int kRegionActionFieldNumber = 1;
  inline const ::hbase::pb::RegionAction& regionaction(int index) const;
  inline ::hbase::pb::RegionAction* mutable_regionaction(int index);
  inline ::hbase::pb::RegionAction* add_regionaction();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionAction >&
      regionaction() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionAction >*
      mutable_regionaction();

  // optional uint64 nonceGroup = 2;
  inline bool has_noncegroup() const;
  inline void clear_noncegroup();
  static const int kNonceGroupFieldNumber = 2;
  inline ::google::protobuf::uint64 noncegroup() const;
  inline void set_noncegroup(::google::protobuf::uint64 value);

  // optional .hbase.pb.Condition condition = 3;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 3;
  inline const ::hbase::pb::Condition& condition() const;
  inline ::hbase::pb::Condition* mutable_condition();
  inline ::hbase::pb::Condition* release_condition();
  inline void set_allocated_condition(::hbase::pb::Condition* condition);

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRequest)
 private:
  inline void set_has_noncegroup();
  inline void clear_has_noncegroup();
  inline void set_has_condition();
  inline void clear_has_condition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionAction > regionaction_;
  ::google::protobuf::uint64 noncegroup_;
  ::hbase::pb::Condition* condition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MultiRequest* default_instance_;
};
// -------------------------------------------------------------------

class MultiResponse : public ::google::protobuf::Message {
 public:
  MultiResponse();
  virtual ~MultiResponse();

  MultiResponse(const MultiResponse& from);

  inline MultiResponse& operator=(const MultiResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiResponse& default_instance();

  void Swap(MultiResponse* other);

  // implements Message ----------------------------------------------

  MultiResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiResponse& from);
  void MergeFrom(const MultiResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hbase.pb.RegionActionResult regionActionResult = 1;
  inline int regionactionresult_size() const;
  inline void clear_regionactionresult();
  static const int kRegionActionResultFieldNumber = 1;
  inline const ::hbase::pb::RegionActionResult& regionactionresult(int index) const;
  inline ::hbase::pb::RegionActionResult* mutable_regionactionresult(int index);
  inline ::hbase::pb::RegionActionResult* add_regionactionresult();
  inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionActionResult >&
      regionactionresult() const;
  inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionActionResult >*
      mutable_regionactionresult();

  // optional bool processed = 2;
  inline bool has_processed() const;
  inline void clear_processed();
  static const int kProcessedFieldNumber = 2;
  inline bool processed() const;
  inline void set_processed(bool value);

  // optional .hbase.pb.MultiRegionLoadStats regionStatistics = 3;
  inline bool has_regionstatistics() const;
  inline void clear_regionstatistics();
  static const int kRegionStatisticsFieldNumber = 3;
  inline const ::hbase::pb::MultiRegionLoadStats& regionstatistics() const;
  inline ::hbase::pb::MultiRegionLoadStats* mutable_regionstatistics();
  inline ::hbase::pb::MultiRegionLoadStats* release_regionstatistics();
  inline void set_allocated_regionstatistics(::hbase::pb::MultiRegionLoadStats* regionstatistics);

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiResponse)
 private:
  inline void set_has_processed();
  inline void clear_has_processed();
  inline void set_has_regionstatistics();
  inline void clear_has_regionstatistics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionActionResult > regionactionresult_;
  ::hbase::pb::MultiRegionLoadStats* regionstatistics_;
  bool processed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Client_2eproto();
  friend void protobuf_AssignDesc_Client_2eproto();
  friend void protobuf_ShutdownFile_Client_2eproto();

  void InitAsDefaultInstance();
  static MultiResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Authorizations

// repeated string label = 1;
inline int Authorizations::label_size() const {
  return label_.size();
}
inline void Authorizations::clear_label() {
  label_.Clear();
}
inline const ::std::string& Authorizations::label(int index) const {
  return label_.Get(index);
}
inline ::std::string* Authorizations::mutable_label(int index) {
  return label_.Mutable(index);
}
inline void Authorizations::set_label(int index, const ::std::string& value) {
  label_.Mutable(index)->assign(value);
}
inline void Authorizations::set_label(int index, const char* value) {
  label_.Mutable(index)->assign(value);
}
inline void Authorizations::set_label(int index, const char* value, size_t size) {
  label_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authorizations::add_label() {
  return label_.Add();
}
inline void Authorizations::add_label(const ::std::string& value) {
  label_.Add()->assign(value);
}
inline void Authorizations::add_label(const char* value) {
  label_.Add()->assign(value);
}
inline void Authorizations::add_label(const char* value, size_t size) {
  label_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Authorizations::label() const {
  return label_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Authorizations::mutable_label() {
  return &label_;
}

// -------------------------------------------------------------------

// CellVisibility

// required string expression = 1;
inline bool CellVisibility::has_expression() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellVisibility::set_has_expression() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellVisibility::clear_has_expression() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellVisibility::clear_expression() {
  if (expression_ != &::google::protobuf::internal::kEmptyString) {
    expression_->clear();
  }
  clear_has_expression();
}
inline const ::std::string& CellVisibility::expression() const {
  return *expression_;
}
inline void CellVisibility::set_expression(const ::std::string& value) {
  set_has_expression();
  if (expression_ == &::google::protobuf::internal::kEmptyString) {
    expression_ = new ::std::string;
  }
  expression_->assign(value);
}
inline void CellVisibility::set_expression(const char* value) {
  set_has_expression();
  if (expression_ == &::google::protobuf::internal::kEmptyString) {
    expression_ = new ::std::string;
  }
  expression_->assign(value);
}
inline void CellVisibility::set_expression(const char* value, size_t size) {
  set_has_expression();
  if (expression_ == &::google::protobuf::internal::kEmptyString) {
    expression_ = new ::std::string;
  }
  expression_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CellVisibility::mutable_expression() {
  set_has_expression();
  if (expression_ == &::google::protobuf::internal::kEmptyString) {
    expression_ = new ::std::string;
  }
  return expression_;
}
inline ::std::string* CellVisibility::release_expression() {
  clear_has_expression();
  if (expression_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = expression_;
    expression_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CellVisibility::set_allocated_expression(::std::string* expression) {
  if (expression_ != &::google::protobuf::internal::kEmptyString) {
    delete expression_;
  }
  if (expression) {
    set_has_expression();
    expression_ = expression;
  } else {
    clear_has_expression();
    expression_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Column

// required bytes family = 1;
inline bool Column::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& Column::family() const {
  return *family_;
}
inline void Column::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void Column::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void Column::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* Column::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Column::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes qualifier = 2;
inline int Column::qualifier_size() const {
  return qualifier_.size();
}
inline void Column::clear_qualifier() {
  qualifier_.Clear();
}
inline const ::std::string& Column::qualifier(int index) const {
  return qualifier_.Get(index);
}
inline ::std::string* Column::mutable_qualifier(int index) {
  return qualifier_.Mutable(index);
}
inline void Column::set_qualifier(int index, const ::std::string& value) {
  qualifier_.Mutable(index)->assign(value);
}
inline void Column::set_qualifier(int index, const char* value) {
  qualifier_.Mutable(index)->assign(value);
}
inline void Column::set_qualifier(int index, const void* value, size_t size) {
  qualifier_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::add_qualifier() {
  return qualifier_.Add();
}
inline void Column::add_qualifier(const ::std::string& value) {
  qualifier_.Add()->assign(value);
}
inline void Column::add_qualifier(const char* value) {
  qualifier_.Add()->assign(value);
}
inline void Column::add_qualifier(const void* value, size_t size) {
  qualifier_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Column::qualifier() const {
  return qualifier_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Column::mutable_qualifier() {
  return &qualifier_;
}

// -------------------------------------------------------------------

// Get

// required bytes row = 1;
inline bool Get::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Get::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Get::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Get::clear_row() {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    row_->clear();
  }
  clear_has_row();
}
inline const ::std::string& Get::row() const {
  return *row_;
}
inline void Get::set_row(const ::std::string& value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void Get::set_row(const char* value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void Get::set_row(const void* value, size_t size) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Get::mutable_row() {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  return row_;
}
inline ::std::string* Get::release_row() {
  clear_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = row_;
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Get::set_allocated_row(::std::string* row) {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    delete row_;
  }
  if (row) {
    set_has_row();
    row_ = row;
  } else {
    clear_has_row();
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.Column column = 2;
inline int Get::column_size() const {
  return column_.size();
}
inline void Get::clear_column() {
  column_.Clear();
}
inline const ::hbase::pb::Column& Get::column(int index) const {
  return column_.Get(index);
}
inline ::hbase::pb::Column* Get::mutable_column(int index) {
  return column_.Mutable(index);
}
inline ::hbase::pb::Column* Get::add_column() {
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >&
Get::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >*
Get::mutable_column() {
  return &column_;
}

// repeated .hbase.pb.NameBytesPair attribute = 3;
inline int Get::attribute_size() const {
  return attribute_.size();
}
inline void Get::clear_attribute() {
  attribute_.Clear();
}
inline const ::hbase::pb::NameBytesPair& Get::attribute(int index) const {
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* Get::mutable_attribute(int index) {
  return attribute_.Mutable(index);
}
inline ::hbase::pb::NameBytesPair* Get::add_attribute() {
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
Get::attribute() const {
  return attribute_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
Get::mutable_attribute() {
  return &attribute_;
}

// optional .hbase.pb.Filter filter = 4;
inline bool Get::has_filter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Get::set_has_filter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Get::clear_has_filter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Get::clear_filter() {
  if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
  clear_has_filter();
}
inline const ::hbase::pb::Filter& Get::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::hbase::pb::Filter* Get::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::hbase::pb::Filter;
  return filter_;
}
inline ::hbase::pb::Filter* Get::release_filter() {
  clear_has_filter();
  ::hbase::pb::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void Get::set_allocated_filter(::hbase::pb::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// optional .hbase.pb.TimeRange time_range = 5;
inline bool Get::has_time_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Get::set_has_time_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Get::clear_has_time_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Get::clear_time_range() {
  if (time_range_ != NULL) time_range_->::hbase::pb::TimeRange::Clear();
  clear_has_time_range();
}
inline const ::hbase::pb::TimeRange& Get::time_range() const {
  return time_range_ != NULL ? *time_range_ : *default_instance_->time_range_;
}
inline ::hbase::pb::TimeRange* Get::mutable_time_range() {
  set_has_time_range();
  if (time_range_ == NULL) time_range_ = new ::hbase::pb::TimeRange;
  return time_range_;
}
inline ::hbase::pb::TimeRange* Get::release_time_range() {
  clear_has_time_range();
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = NULL;
  return temp;
}
inline void Get::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  delete time_range_;
  time_range_ = time_range;
  if (time_range) {
    set_has_time_range();
  } else {
    clear_has_time_range();
  }
}

// optional uint32 max_versions = 6 [default = 1];
inline bool Get::has_max_versions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Get::set_has_max_versions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Get::clear_has_max_versions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Get::clear_max_versions() {
  max_versions_ = 1u;
  clear_has_max_versions();
}
inline ::google::protobuf::uint32 Get::max_versions() const {
  return max_versions_;
}
inline void Get::set_max_versions(::google::protobuf::uint32 value) {
  set_has_max_versions();
  max_versions_ = value;
}

// optional bool cache_blocks = 7 [default = true];
inline bool Get::has_cache_blocks() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Get::set_has_cache_blocks() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Get::clear_has_cache_blocks() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Get::clear_cache_blocks() {
  cache_blocks_ = true;
  clear_has_cache_blocks();
}
inline bool Get::cache_blocks() const {
  return cache_blocks_;
}
inline void Get::set_cache_blocks(bool value) {
  set_has_cache_blocks();
  cache_blocks_ = value;
}

// optional uint32 store_limit = 8;
inline bool Get::has_store_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Get::set_has_store_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Get::clear_has_store_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Get::clear_store_limit() {
  store_limit_ = 0u;
  clear_has_store_limit();
}
inline ::google::protobuf::uint32 Get::store_limit() const {
  return store_limit_;
}
inline void Get::set_store_limit(::google::protobuf::uint32 value) {
  set_has_store_limit();
  store_limit_ = value;
}

// optional uint32 store_offset = 9;
inline bool Get::has_store_offset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Get::set_has_store_offset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Get::clear_has_store_offset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Get::clear_store_offset() {
  store_offset_ = 0u;
  clear_has_store_offset();
}
inline ::google::protobuf::uint32 Get::store_offset() const {
  return store_offset_;
}
inline void Get::set_store_offset(::google::protobuf::uint32 value) {
  set_has_store_offset();
  store_offset_ = value;
}

// optional bool existence_only = 10 [default = false];
inline bool Get::has_existence_only() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Get::set_has_existence_only() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Get::clear_has_existence_only() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Get::clear_existence_only() {
  existence_only_ = false;
  clear_has_existence_only();
}
inline bool Get::existence_only() const {
  return existence_only_;
}
inline void Get::set_existence_only(bool value) {
  set_has_existence_only();
  existence_only_ = value;
}

// optional .hbase.pb.Consistency consistency = 12 [default = STRONG];
inline bool Get::has_consistency() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Get::set_has_consistency() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Get::clear_has_consistency() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Get::clear_consistency() {
  consistency_ = 0;
  clear_has_consistency();
}
inline ::hbase::pb::Consistency Get::consistency() const {
  return static_cast< ::hbase::pb::Consistency >(consistency_);
}
inline void Get::set_consistency(::hbase::pb::Consistency value) {
  assert(::hbase::pb::Consistency_IsValid(value));
  set_has_consistency();
  consistency_ = value;
}

// repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 13;
inline int Get::cf_time_range_size() const {
  return cf_time_range_.size();
}
inline void Get::clear_cf_time_range() {
  cf_time_range_.Clear();
}
inline const ::hbase::pb::ColumnFamilyTimeRange& Get::cf_time_range(int index) const {
  return cf_time_range_.Get(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Get::mutable_cf_time_range(int index) {
  return cf_time_range_.Mutable(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Get::add_cf_time_range() {
  return cf_time_range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
Get::cf_time_range() const {
  return cf_time_range_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
Get::mutable_cf_time_range() {
  return &cf_time_range_;
}

// -------------------------------------------------------------------

// Result

// repeated .hbase.pb.Cell cell = 1;
inline int Result::cell_size() const {
  return cell_.size();
}
inline void Result::clear_cell() {
  cell_.Clear();
}
inline const ::hbase::pb::Cell& Result::cell(int index) const {
  return cell_.Get(index);
}
inline ::hbase::pb::Cell* Result::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::hbase::pb::Cell* Result::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Cell >&
Result::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Cell >*
Result::mutable_cell() {
  return &cell_;
}

// optional int32 associated_cell_count = 2;
inline bool Result::has_associated_cell_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_associated_cell_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_associated_cell_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_associated_cell_count() {
  associated_cell_count_ = 0;
  clear_has_associated_cell_count();
}
inline ::google::protobuf::int32 Result::associated_cell_count() const {
  return associated_cell_count_;
}
inline void Result::set_associated_cell_count(::google::protobuf::int32 value) {
  set_has_associated_cell_count();
  associated_cell_count_ = value;
}

// optional bool exists = 3;
inline bool Result::has_exists() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_exists() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_exists() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_exists() {
  exists_ = false;
  clear_has_exists();
}
inline bool Result::exists() const {
  return exists_;
}
inline void Result::set_exists(bool value) {
  set_has_exists();
  exists_ = value;
}

// optional bool stale = 4 [default = false];
inline bool Result::has_stale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_stale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_stale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_stale() {
  stale_ = false;
  clear_has_stale();
}
inline bool Result::stale() const {
  return stale_;
}
inline void Result::set_stale(bool value) {
  set_has_stale();
  stale_ = value;
}

// optional bool partial = 5 [default = false];
inline bool Result::has_partial() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Result::set_has_partial() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Result::clear_has_partial() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Result::clear_partial() {
  partial_ = false;
  clear_has_partial();
}
inline bool Result::partial() const {
  return partial_;
}
inline void Result::set_partial(bool value) {
  set_has_partial();
  partial_ = value;
}

// -------------------------------------------------------------------

// GetRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool GetRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRequest::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRequest::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& GetRequest::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* GetRequest::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* GetRequest::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void GetRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// required .hbase.pb.Get get = 2;
inline bool GetRequest::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRequest::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRequest::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRequest::clear_get() {
  if (get_ != NULL) get_->::hbase::pb::Get::Clear();
  clear_has_get();
}
inline const ::hbase::pb::Get& GetRequest::get() const {
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::hbase::pb::Get* GetRequest::mutable_get() {
  set_has_get();
  if (get_ == NULL) get_ = new ::hbase::pb::Get;
  return get_;
}
inline ::hbase::pb::Get* GetRequest::release_get() {
  clear_has_get();
  ::hbase::pb::Get* temp = get_;
  get_ = NULL;
  return temp;
}
inline void GetRequest::set_allocated_get(::hbase::pb::Get* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
}

// -------------------------------------------------------------------

// GetResponse

// optional .hbase.pb.Result result = 1;
inline bool GetResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResponse::clear_result() {
  if (result_ != NULL) result_->::hbase::pb::Result::Clear();
  clear_has_result();
}
inline const ::hbase::pb::Result& GetResponse::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::hbase::pb::Result* GetResponse::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::hbase::pb::Result;
  return result_;
}
inline ::hbase::pb::Result* GetResponse::release_result() {
  clear_has_result();
  ::hbase::pb::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_result(::hbase::pb::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// Condition

// required bytes row = 1;
inline bool Condition::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_row() {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    row_->clear();
  }
  clear_has_row();
}
inline const ::std::string& Condition::row() const {
  return *row_;
}
inline void Condition::set_row(const ::std::string& value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void Condition::set_row(const char* value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void Condition::set_row(const void* value, size_t size) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_row() {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  return row_;
}
inline ::std::string* Condition::release_row() {
  clear_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = row_;
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Condition::set_allocated_row(::std::string* row) {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    delete row_;
  }
  if (row) {
    set_has_row();
    row_ = row;
  } else {
    clear_has_row();
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes family = 2;
inline bool Condition::has_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Condition::set_has_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Condition::clear_has_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Condition::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& Condition::family() const {
  return *family_;
}
inline void Condition::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void Condition::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void Condition::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* Condition::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Condition::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes qualifier = 3;
inline bool Condition::has_qualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Condition::set_has_qualifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Condition::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Condition::clear_qualifier() {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    qualifier_->clear();
  }
  clear_has_qualifier();
}
inline const ::std::string& Condition::qualifier() const {
  return *qualifier_;
}
inline void Condition::set_qualifier(const ::std::string& value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void Condition::set_qualifier(const char* value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void Condition::set_qualifier(const void* value, size_t size) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_qualifier() {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  return qualifier_;
}
inline ::std::string* Condition::release_qualifier() {
  clear_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualifier_;
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Condition::set_allocated_qualifier(::std::string* qualifier) {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (qualifier) {
    set_has_qualifier();
    qualifier_ = qualifier;
  } else {
    clear_has_qualifier();
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hbase.pb.CompareType compare_type = 4;
inline bool Condition::has_compare_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Condition::set_has_compare_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Condition::clear_has_compare_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Condition::clear_compare_type() {
  compare_type_ = 0;
  clear_has_compare_type();
}
inline ::hbase::pb::CompareType Condition::compare_type() const {
  return static_cast< ::hbase::pb::CompareType >(compare_type_);
}
inline void Condition::set_compare_type(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  set_has_compare_type();
  compare_type_ = value;
}

// required .hbase.pb.Comparator comparator = 5;
inline bool Condition::has_comparator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Condition::set_has_comparator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Condition::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Condition::clear_comparator() {
  if (comparator_ != NULL) comparator_->::hbase::pb::Comparator::Clear();
  clear_has_comparator();
}
inline const ::hbase::pb::Comparator& Condition::comparator() const {
  return comparator_ != NULL ? *comparator_ : *default_instance_->comparator_;
}
inline ::hbase::pb::Comparator* Condition::mutable_comparator() {
  set_has_comparator();
  if (comparator_ == NULL) comparator_ = new ::hbase::pb::Comparator;
  return comparator_;
}
inline ::hbase::pb::Comparator* Condition::release_comparator() {
  clear_has_comparator();
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = NULL;
  return temp;
}
inline void Condition::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  delete comparator_;
  comparator_ = comparator;
  if (comparator) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
}

// -------------------------------------------------------------------

// MutationProto_ColumnValue_QualifierValue

// optional bytes qualifier = 1;
inline bool MutationProto_ColumnValue_QualifierValue::has_qualifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::set_has_qualifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_qualifier() {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    qualifier_->clear();
  }
  clear_has_qualifier();
}
inline const ::std::string& MutationProto_ColumnValue_QualifierValue::qualifier() const {
  return *qualifier_;
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const ::std::string& value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const char* value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const void* value, size_t size) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::mutable_qualifier() {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  return qualifier_;
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::release_qualifier() {
  clear_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualifier_;
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_qualifier(::std::string* qualifier) {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (qualifier) {
    set_has_qualifier();
    qualifier_ = qualifier;
  } else {
    clear_has_qualifier();
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 2;
inline bool MutationProto_ColumnValue_QualifierValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& MutationProto_ColumnValue_QualifierValue::value() const {
  return *value_;
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 timestamp = 3;
inline bool MutationProto_ColumnValue_QualifierValue::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MutationProto_ColumnValue_QualifierValue::timestamp() const {
  return timestamp_;
}
inline void MutationProto_ColumnValue_QualifierValue::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .hbase.pb.MutationProto.DeleteType delete_type = 4;
inline bool MutationProto_ColumnValue_QualifierValue::has_delete_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::set_has_delete_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_has_delete_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_delete_type() {
  delete_type_ = 0;
  clear_has_delete_type();
}
inline ::hbase::pb::MutationProto_DeleteType MutationProto_ColumnValue_QualifierValue::delete_type() const {
  return static_cast< ::hbase::pb::MutationProto_DeleteType >(delete_type_);
}
inline void MutationProto_ColumnValue_QualifierValue::set_delete_type(::hbase::pb::MutationProto_DeleteType value) {
  assert(::hbase::pb::MutationProto_DeleteType_IsValid(value));
  set_has_delete_type();
  delete_type_ = value;
}

// optional bytes tags = 5;
inline bool MutationProto_ColumnValue_QualifierValue::has_tags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::set_has_tags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_has_tags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& MutationProto_ColumnValue_QualifierValue::tags() const {
  return *tags_;
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const void* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* MutationProto_ColumnValue_QualifierValue::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_tags(::std::string* tags) {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    delete tags_;
  }
  if (tags) {
    set_has_tags();
    tags_ = tags;
  } else {
    clear_has_tags();
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MutationProto_ColumnValue

// required bytes family = 1;
inline bool MutationProto_ColumnValue::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto_ColumnValue::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutationProto_ColumnValue::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutationProto_ColumnValue::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& MutationProto_ColumnValue::family() const {
  return *family_;
}
inline void MutationProto_ColumnValue::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void MutationProto_ColumnValue::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void MutationProto_ColumnValue::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MutationProto_ColumnValue::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* MutationProto_ColumnValue::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MutationProto_ColumnValue::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hbase.pb.MutationProto.ColumnValue.QualifierValue qualifier_value = 2;
inline int MutationProto_ColumnValue::qualifier_value_size() const {
  return qualifier_value_.size();
}
inline void MutationProto_ColumnValue::clear_qualifier_value() {
  qualifier_value_.Clear();
}
inline const ::hbase::pb::MutationProto_ColumnValue_QualifierValue& MutationProto_ColumnValue::qualifier_value(int index) const {
  return qualifier_value_.Get(index);
}
inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* MutationProto_ColumnValue::mutable_qualifier_value(int index) {
  return qualifier_value_.Mutable(index);
}
inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* MutationProto_ColumnValue::add_qualifier_value() {
  return qualifier_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >&
MutationProto_ColumnValue::qualifier_value() const {
  return qualifier_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >*
MutationProto_ColumnValue::mutable_qualifier_value() {
  return &qualifier_value_;
}

// -------------------------------------------------------------------

// MutationProto

// optional bytes row = 1;
inline bool MutationProto::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutationProto::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutationProto::clear_row() {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    row_->clear();
  }
  clear_has_row();
}
inline const ::std::string& MutationProto::row() const {
  return *row_;
}
inline void MutationProto::set_row(const ::std::string& value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void MutationProto::set_row(const char* value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void MutationProto::set_row(const void* value, size_t size) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MutationProto::mutable_row() {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  return row_;
}
inline ::std::string* MutationProto::release_row() {
  clear_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = row_;
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MutationProto::set_allocated_row(::std::string* row) {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    delete row_;
  }
  if (row) {
    set_has_row();
    row_ = row;
  } else {
    clear_has_row();
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .hbase.pb.MutationProto.MutationType mutate_type = 2;
inline bool MutationProto::has_mutate_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutationProto::set_has_mutate_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutationProto::clear_has_mutate_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutationProto::clear_mutate_type() {
  mutate_type_ = 0;
  clear_has_mutate_type();
}
inline ::hbase::pb::MutationProto_MutationType MutationProto::mutate_type() const {
  return static_cast< ::hbase::pb::MutationProto_MutationType >(mutate_type_);
}
inline void MutationProto::set_mutate_type(::hbase::pb::MutationProto_MutationType value) {
  assert(::hbase::pb::MutationProto_MutationType_IsValid(value));
  set_has_mutate_type();
  mutate_type_ = value;
}

// repeated .hbase.pb.MutationProto.ColumnValue column_value = 3;
inline int MutationProto::column_value_size() const {
  return column_value_.size();
}
inline void MutationProto::clear_column_value() {
  column_value_.Clear();
}
inline const ::hbase::pb::MutationProto_ColumnValue& MutationProto::column_value(int index) const {
  return column_value_.Get(index);
}
inline ::hbase::pb::MutationProto_ColumnValue* MutationProto::mutable_column_value(int index) {
  return column_value_.Mutable(index);
}
inline ::hbase::pb::MutationProto_ColumnValue* MutationProto::add_column_value() {
  return column_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >&
MutationProto::column_value() const {
  return column_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >*
MutationProto::mutable_column_value() {
  return &column_value_;
}

// optional uint64 timestamp = 4;
inline bool MutationProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutationProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MutationProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MutationProto::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MutationProto::timestamp() const {
  return timestamp_;
}
inline void MutationProto::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .hbase.pb.NameBytesPair attribute = 5;
inline int MutationProto::attribute_size() const {
  return attribute_.size();
}
inline void MutationProto::clear_attribute() {
  attribute_.Clear();
}
inline const ::hbase::pb::NameBytesPair& MutationProto::attribute(int index) const {
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* MutationProto::mutable_attribute(int index) {
  return attribute_.Mutable(index);
}
inline ::hbase::pb::NameBytesPair* MutationProto::add_attribute() {
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
MutationProto::attribute() const {
  return attribute_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
MutationProto::mutable_attribute() {
  return &attribute_;
}

// optional .hbase.pb.MutationProto.Durability durability = 6 [default = USE_DEFAULT];
inline bool MutationProto::has_durability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MutationProto::set_has_durability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MutationProto::clear_has_durability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MutationProto::clear_durability() {
  durability_ = 0;
  clear_has_durability();
}
inline ::hbase::pb::MutationProto_Durability MutationProto::durability() const {
  return static_cast< ::hbase::pb::MutationProto_Durability >(durability_);
}
inline void MutationProto::set_durability(::hbase::pb::MutationProto_Durability value) {
  assert(::hbase::pb::MutationProto_Durability_IsValid(value));
  set_has_durability();
  durability_ = value;
}

// optional .hbase.pb.TimeRange time_range = 7;
inline bool MutationProto::has_time_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MutationProto::set_has_time_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MutationProto::clear_has_time_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MutationProto::clear_time_range() {
  if (time_range_ != NULL) time_range_->::hbase::pb::TimeRange::Clear();
  clear_has_time_range();
}
inline const ::hbase::pb::TimeRange& MutationProto::time_range() const {
  return time_range_ != NULL ? *time_range_ : *default_instance_->time_range_;
}
inline ::hbase::pb::TimeRange* MutationProto::mutable_time_range() {
  set_has_time_range();
  if (time_range_ == NULL) time_range_ = new ::hbase::pb::TimeRange;
  return time_range_;
}
inline ::hbase::pb::TimeRange* MutationProto::release_time_range() {
  clear_has_time_range();
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = NULL;
  return temp;
}
inline void MutationProto::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  delete time_range_;
  time_range_ = time_range;
  if (time_range) {
    set_has_time_range();
  } else {
    clear_has_time_range();
  }
}

// optional int32 associated_cell_count = 8;
inline bool MutationProto::has_associated_cell_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MutationProto::set_has_associated_cell_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MutationProto::clear_has_associated_cell_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MutationProto::clear_associated_cell_count() {
  associated_cell_count_ = 0;
  clear_has_associated_cell_count();
}
inline ::google::protobuf::int32 MutationProto::associated_cell_count() const {
  return associated_cell_count_;
}
inline void MutationProto::set_associated_cell_count(::google::protobuf::int32 value) {
  set_has_associated_cell_count();
  associated_cell_count_ = value;
}

// optional uint64 nonce = 9;
inline bool MutationProto::has_nonce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MutationProto::set_has_nonce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MutationProto::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MutationProto::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 MutationProto::nonce() const {
  return nonce_;
}
inline void MutationProto::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
}

// -------------------------------------------------------------------

// MutateRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool MutateRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutateRequest::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutateRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutateRequest::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& MutateRequest::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* MutateRequest::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* MutateRequest::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void MutateRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// required .hbase.pb.MutationProto mutation = 2;
inline bool MutateRequest::has_mutation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutateRequest::set_has_mutation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutateRequest::clear_has_mutation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutateRequest::clear_mutation() {
  if (mutation_ != NULL) mutation_->::hbase::pb::MutationProto::Clear();
  clear_has_mutation();
}
inline const ::hbase::pb::MutationProto& MutateRequest::mutation() const {
  return mutation_ != NULL ? *mutation_ : *default_instance_->mutation_;
}
inline ::hbase::pb::MutationProto* MutateRequest::mutable_mutation() {
  set_has_mutation();
  if (mutation_ == NULL) mutation_ = new ::hbase::pb::MutationProto;
  return mutation_;
}
inline ::hbase::pb::MutationProto* MutateRequest::release_mutation() {
  clear_has_mutation();
  ::hbase::pb::MutationProto* temp = mutation_;
  mutation_ = NULL;
  return temp;
}
inline void MutateRequest::set_allocated_mutation(::hbase::pb::MutationProto* mutation) {
  delete mutation_;
  mutation_ = mutation;
  if (mutation) {
    set_has_mutation();
  } else {
    clear_has_mutation();
  }
}

// optional .hbase.pb.Condition condition = 3;
inline bool MutateRequest::has_condition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutateRequest::set_has_condition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MutateRequest::clear_has_condition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MutateRequest::clear_condition() {
  if (condition_ != NULL) condition_->::hbase::pb::Condition::Clear();
  clear_has_condition();
}
inline const ::hbase::pb::Condition& MutateRequest::condition() const {
  return condition_ != NULL ? *condition_ : *default_instance_->condition_;
}
inline ::hbase::pb::Condition* MutateRequest::mutable_condition() {
  set_has_condition();
  if (condition_ == NULL) condition_ = new ::hbase::pb::Condition;
  return condition_;
}
inline ::hbase::pb::Condition* MutateRequest::release_condition() {
  clear_has_condition();
  ::hbase::pb::Condition* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline void MutateRequest::set_allocated_condition(::hbase::pb::Condition* condition) {
  delete condition_;
  condition_ = condition;
  if (condition) {
    set_has_condition();
  } else {
    clear_has_condition();
  }
}

// optional uint64 nonce_group = 4;
inline bool MutateRequest::has_nonce_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutateRequest::set_has_nonce_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MutateRequest::clear_has_nonce_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MutateRequest::clear_nonce_group() {
  nonce_group_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce_group();
}
inline ::google::protobuf::uint64 MutateRequest::nonce_group() const {
  return nonce_group_;
}
inline void MutateRequest::set_nonce_group(::google::protobuf::uint64 value) {
  set_has_nonce_group();
  nonce_group_ = value;
}

// -------------------------------------------------------------------

// MutateResponse

// optional .hbase.pb.Result result = 1;
inline bool MutateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutateResponse::clear_result() {
  if (result_ != NULL) result_->::hbase::pb::Result::Clear();
  clear_has_result();
}
inline const ::hbase::pb::Result& MutateResponse::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::hbase::pb::Result* MutateResponse::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::hbase::pb::Result;
  return result_;
}
inline ::hbase::pb::Result* MutateResponse::release_result() {
  clear_has_result();
  ::hbase::pb::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void MutateResponse::set_allocated_result(::hbase::pb::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional bool processed = 2;
inline bool MutateResponse::has_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutateResponse::set_has_processed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutateResponse::clear_has_processed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutateResponse::clear_processed() {
  processed_ = false;
  clear_has_processed();
}
inline bool MutateResponse::processed() const {
  return processed_;
}
inline void MutateResponse::set_processed(bool value) {
  set_has_processed();
  processed_ = value;
}

// -------------------------------------------------------------------

// Scan

// repeated .hbase.pb.Column column = 1;
inline int Scan::column_size() const {
  return column_.size();
}
inline void Scan::clear_column() {
  column_.Clear();
}
inline const ::hbase::pb::Column& Scan::column(int index) const {
  return column_.Get(index);
}
inline ::hbase::pb::Column* Scan::mutable_column(int index) {
  return column_.Mutable(index);
}
inline ::hbase::pb::Column* Scan::add_column() {
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >&
Scan::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Column >*
Scan::mutable_column() {
  return &column_;
}

// repeated .hbase.pb.NameBytesPair attribute = 2;
inline int Scan::attribute_size() const {
  return attribute_.size();
}
inline void Scan::clear_attribute() {
  attribute_.Clear();
}
inline const ::hbase::pb::NameBytesPair& Scan::attribute(int index) const {
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* Scan::mutable_attribute(int index) {
  return attribute_.Mutable(index);
}
inline ::hbase::pb::NameBytesPair* Scan::add_attribute() {
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
Scan::attribute() const {
  return attribute_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
Scan::mutable_attribute() {
  return &attribute_;
}

// optional bytes start_row = 3;
inline bool Scan::has_start_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scan::set_has_start_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scan::clear_has_start_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scan::clear_start_row() {
  if (start_row_ != &::google::protobuf::internal::kEmptyString) {
    start_row_->clear();
  }
  clear_has_start_row();
}
inline const ::std::string& Scan::start_row() const {
  return *start_row_;
}
inline void Scan::set_start_row(const ::std::string& value) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(value);
}
inline void Scan::set_start_row(const char* value) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(value);
}
inline void Scan::set_start_row(const void* value, size_t size) {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  start_row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Scan::mutable_start_row() {
  set_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    start_row_ = new ::std::string;
  }
  return start_row_;
}
inline ::std::string* Scan::release_start_row() {
  clear_has_start_row();
  if (start_row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_row_;
    start_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Scan::set_allocated_start_row(::std::string* start_row) {
  if (start_row_ != &::google::protobuf::internal::kEmptyString) {
    delete start_row_;
  }
  if (start_row) {
    set_has_start_row();
    start_row_ = start_row;
  } else {
    clear_has_start_row();
    start_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes stop_row = 4;
inline bool Scan::has_stop_row() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Scan::set_has_stop_row() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Scan::clear_has_stop_row() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Scan::clear_stop_row() {
  if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
    stop_row_->clear();
  }
  clear_has_stop_row();
}
inline const ::std::string& Scan::stop_row() const {
  return *stop_row_;
}
inline void Scan::set_stop_row(const ::std::string& value) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(value);
}
inline void Scan::set_stop_row(const char* value) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(value);
}
inline void Scan::set_stop_row(const void* value, size_t size) {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  stop_row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Scan::mutable_stop_row() {
  set_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    stop_row_ = new ::std::string;
  }
  return stop_row_;
}
inline ::std::string* Scan::release_stop_row() {
  clear_has_stop_row();
  if (stop_row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_row_;
    stop_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Scan::set_allocated_stop_row(::std::string* stop_row) {
  if (stop_row_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_row_;
  }
  if (stop_row) {
    set_has_stop_row();
    stop_row_ = stop_row;
  } else {
    clear_has_stop_row();
    stop_row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .hbase.pb.Filter filter = 5;
inline bool Scan::has_filter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scan::set_has_filter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Scan::clear_has_filter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Scan::clear_filter() {
  if (filter_ != NULL) filter_->::hbase::pb::Filter::Clear();
  clear_has_filter();
}
inline const ::hbase::pb::Filter& Scan::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::hbase::pb::Filter* Scan::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::hbase::pb::Filter;
  return filter_;
}
inline ::hbase::pb::Filter* Scan::release_filter() {
  clear_has_filter();
  ::hbase::pb::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void Scan::set_allocated_filter(::hbase::pb::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// optional .hbase.pb.TimeRange time_range = 6;
inline bool Scan::has_time_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Scan::set_has_time_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Scan::clear_has_time_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Scan::clear_time_range() {
  if (time_range_ != NULL) time_range_->::hbase::pb::TimeRange::Clear();
  clear_has_time_range();
}
inline const ::hbase::pb::TimeRange& Scan::time_range() const {
  return time_range_ != NULL ? *time_range_ : *default_instance_->time_range_;
}
inline ::hbase::pb::TimeRange* Scan::mutable_time_range() {
  set_has_time_range();
  if (time_range_ == NULL) time_range_ = new ::hbase::pb::TimeRange;
  return time_range_;
}
inline ::hbase::pb::TimeRange* Scan::release_time_range() {
  clear_has_time_range();
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = NULL;
  return temp;
}
inline void Scan::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  delete time_range_;
  time_range_ = time_range;
  if (time_range) {
    set_has_time_range();
  } else {
    clear_has_time_range();
  }
}

// optional uint32 max_versions = 7 [default = 1];
inline bool Scan::has_max_versions() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Scan::set_has_max_versions() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Scan::clear_has_max_versions() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Scan::clear_max_versions() {
  max_versions_ = 1u;
  clear_has_max_versions();
}
inline ::google::protobuf::uint32 Scan::max_versions() const {
  return max_versions_;
}
inline void Scan::set_max_versions(::google::protobuf::uint32 value) {
  set_has_max_versions();
  max_versions_ = value;
}

// optional bool cache_blocks = 8 [default = true];
inline bool Scan::has_cache_blocks() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Scan::set_has_cache_blocks() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Scan::clear_has_cache_blocks() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Scan::clear_cache_blocks() {
  cache_blocks_ = true;
  clear_has_cache_blocks();
}
inline bool Scan::cache_blocks() const {
  return cache_blocks_;
}
inline void Scan::set_cache_blocks(bool value) {
  set_has_cache_blocks();
  cache_blocks_ = value;
}

// optional uint32 batch_size = 9;
inline bool Scan::has_batch_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Scan::set_has_batch_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Scan::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Scan::clear_batch_size() {
  batch_size_ = 0u;
  clear_has_batch_size();
}
inline ::google::protobuf::uint32 Scan::batch_size() const {
  return batch_size_;
}
inline void Scan::set_batch_size(::google::protobuf::uint32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional uint64 max_result_size = 10;
inline bool Scan::has_max_result_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Scan::set_has_max_result_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Scan::clear_has_max_result_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Scan::clear_max_result_size() {
  max_result_size_ = GOOGLE_ULONGLONG(0);
  clear_has_max_result_size();
}
inline ::google::protobuf::uint64 Scan::max_result_size() const {
  return max_result_size_;
}
inline void Scan::set_max_result_size(::google::protobuf::uint64 value) {
  set_has_max_result_size();
  max_result_size_ = value;
}

// optional uint32 store_limit = 11;
inline bool Scan::has_store_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Scan::set_has_store_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Scan::clear_has_store_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Scan::clear_store_limit() {
  store_limit_ = 0u;
  clear_has_store_limit();
}
inline ::google::protobuf::uint32 Scan::store_limit() const {
  return store_limit_;
}
inline void Scan::set_store_limit(::google::protobuf::uint32 value) {
  set_has_store_limit();
  store_limit_ = value;
}

// optional uint32 store_offset = 12;
inline bool Scan::has_store_offset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Scan::set_has_store_offset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Scan::clear_has_store_offset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Scan::clear_store_offset() {
  store_offset_ = 0u;
  clear_has_store_offset();
}
inline ::google::protobuf::uint32 Scan::store_offset() const {
  return store_offset_;
}
inline void Scan::set_store_offset(::google::protobuf::uint32 value) {
  set_has_store_offset();
  store_offset_ = value;
}

// optional bool load_column_families_on_demand = 13;
inline bool Scan::has_load_column_families_on_demand() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Scan::set_has_load_column_families_on_demand() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Scan::clear_has_load_column_families_on_demand() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Scan::clear_load_column_families_on_demand() {
  load_column_families_on_demand_ = false;
  clear_has_load_column_families_on_demand();
}
inline bool Scan::load_column_families_on_demand() const {
  return load_column_families_on_demand_;
}
inline void Scan::set_load_column_families_on_demand(bool value) {
  set_has_load_column_families_on_demand();
  load_column_families_on_demand_ = value;
}

// optional bool small = 14;
inline bool Scan::has_small() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Scan::set_has_small() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Scan::clear_has_small() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Scan::clear_small() {
  small_ = false;
  clear_has_small();
}
inline bool Scan::small() const {
  return small_;
}
inline void Scan::set_small(bool value) {
  set_has_small();
  small_ = value;
}

// optional bool reversed = 15 [default = false];
inline bool Scan::has_reversed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Scan::set_has_reversed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Scan::clear_has_reversed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Scan::clear_reversed() {
  reversed_ = false;
  clear_has_reversed();
}
inline bool Scan::reversed() const {
  return reversed_;
}
inline void Scan::set_reversed(bool value) {
  set_has_reversed();
  reversed_ = value;
}

// optional .hbase.pb.Consistency consistency = 16 [default = STRONG];
inline bool Scan::has_consistency() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Scan::set_has_consistency() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Scan::clear_has_consistency() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Scan::clear_consistency() {
  consistency_ = 0;
  clear_has_consistency();
}
inline ::hbase::pb::Consistency Scan::consistency() const {
  return static_cast< ::hbase::pb::Consistency >(consistency_);
}
inline void Scan::set_consistency(::hbase::pb::Consistency value) {
  assert(::hbase::pb::Consistency_IsValid(value));
  set_has_consistency();
  consistency_ = value;
}

// optional uint32 caching = 17;
inline bool Scan::has_caching() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Scan::set_has_caching() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Scan::clear_has_caching() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Scan::clear_caching() {
  caching_ = 0u;
  clear_has_caching();
}
inline ::google::protobuf::uint32 Scan::caching() const {
  return caching_;
}
inline void Scan::set_caching(::google::protobuf::uint32 value) {
  set_has_caching();
  caching_ = value;
}

// optional bool allow_partial_results = 18;
inline bool Scan::has_allow_partial_results() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Scan::set_has_allow_partial_results() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Scan::clear_has_allow_partial_results() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Scan::clear_allow_partial_results() {
  allow_partial_results_ = false;
  clear_has_allow_partial_results();
}
inline bool Scan::allow_partial_results() const {
  return allow_partial_results_;
}
inline void Scan::set_allow_partial_results(bool value) {
  set_has_allow_partial_results();
  allow_partial_results_ = value;
}

// repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 19;
inline int Scan::cf_time_range_size() const {
  return cf_time_range_.size();
}
inline void Scan::clear_cf_time_range() {
  cf_time_range_.Clear();
}
inline const ::hbase::pb::ColumnFamilyTimeRange& Scan::cf_time_range(int index) const {
  return cf_time_range_.Get(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Scan::mutable_cf_time_range(int index) {
  return cf_time_range_.Mutable(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Scan::add_cf_time_range() {
  return cf_time_range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
Scan::cf_time_range() const {
  return cf_time_range_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
Scan::mutable_cf_time_range() {
  return &cf_time_range_;
}

// -------------------------------------------------------------------

// ScanRequest

// optional .hbase.pb.RegionSpecifier region = 1;
inline bool ScanRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanRequest::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanRequest::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& ScanRequest::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* ScanRequest::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* ScanRequest::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void ScanRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// optional .hbase.pb.Scan scan = 2;
inline bool ScanRequest::has_scan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanRequest::set_has_scan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanRequest::clear_has_scan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanRequest::clear_scan() {
  if (scan_ != NULL) scan_->::hbase::pb::Scan::Clear();
  clear_has_scan();
}
inline const ::hbase::pb::Scan& ScanRequest::scan() const {
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::hbase::pb::Scan* ScanRequest::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::hbase::pb::Scan;
  return scan_;
}
inline ::hbase::pb::Scan* ScanRequest::release_scan() {
  clear_has_scan();
  ::hbase::pb::Scan* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void ScanRequest::set_allocated_scan(::hbase::pb::Scan* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
}

// optional uint64 scanner_id = 3;
inline bool ScanRequest::has_scanner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanRequest::set_has_scanner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScanRequest::clear_has_scanner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScanRequest::clear_scanner_id() {
  scanner_id_ = GOOGLE_ULONGLONG(0);
  clear_has_scanner_id();
}
inline ::google::protobuf::uint64 ScanRequest::scanner_id() const {
  return scanner_id_;
}
inline void ScanRequest::set_scanner_id(::google::protobuf::uint64 value) {
  set_has_scanner_id();
  scanner_id_ = value;
}

// optional uint32 number_of_rows = 4;
inline bool ScanRequest::has_number_of_rows() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanRequest::set_has_number_of_rows() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScanRequest::clear_has_number_of_rows() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScanRequest::clear_number_of_rows() {
  number_of_rows_ = 0u;
  clear_has_number_of_rows();
}
inline ::google::protobuf::uint32 ScanRequest::number_of_rows() const {
  return number_of_rows_;
}
inline void ScanRequest::set_number_of_rows(::google::protobuf::uint32 value) {
  set_has_number_of_rows();
  number_of_rows_ = value;
}

// optional bool close_scanner = 5;
inline bool ScanRequest::has_close_scanner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScanRequest::set_has_close_scanner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScanRequest::clear_has_close_scanner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScanRequest::clear_close_scanner() {
  close_scanner_ = false;
  clear_has_close_scanner();
}
inline bool ScanRequest::close_scanner() const {
  return close_scanner_;
}
inline void ScanRequest::set_close_scanner(bool value) {
  set_has_close_scanner();
  close_scanner_ = value;
}

// optional uint64 next_call_seq = 6;
inline bool ScanRequest::has_next_call_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScanRequest::set_has_next_call_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScanRequest::clear_has_next_call_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScanRequest::clear_next_call_seq() {
  next_call_seq_ = GOOGLE_ULONGLONG(0);
  clear_has_next_call_seq();
}
inline ::google::protobuf::uint64 ScanRequest::next_call_seq() const {
  return next_call_seq_;
}
inline void ScanRequest::set_next_call_seq(::google::protobuf::uint64 value) {
  set_has_next_call_seq();
  next_call_seq_ = value;
}

// optional bool client_handles_partials = 7;
inline bool ScanRequest::has_client_handles_partials() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScanRequest::set_has_client_handles_partials() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScanRequest::clear_has_client_handles_partials() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScanRequest::clear_client_handles_partials() {
  client_handles_partials_ = false;
  clear_has_client_handles_partials();
}
inline bool ScanRequest::client_handles_partials() const {
  return client_handles_partials_;
}
inline void ScanRequest::set_client_handles_partials(bool value) {
  set_has_client_handles_partials();
  client_handles_partials_ = value;
}

// optional bool client_handles_heartbeats = 8;
inline bool ScanRequest::has_client_handles_heartbeats() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScanRequest::set_has_client_handles_heartbeats() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScanRequest::clear_has_client_handles_heartbeats() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScanRequest::clear_client_handles_heartbeats() {
  client_handles_heartbeats_ = false;
  clear_has_client_handles_heartbeats();
}
inline bool ScanRequest::client_handles_heartbeats() const {
  return client_handles_heartbeats_;
}
inline void ScanRequest::set_client_handles_heartbeats(bool value) {
  set_has_client_handles_heartbeats();
  client_handles_heartbeats_ = value;
}

// optional bool track_scan_metrics = 9;
inline bool ScanRequest::has_track_scan_metrics() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScanRequest::set_has_track_scan_metrics() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScanRequest::clear_has_track_scan_metrics() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScanRequest::clear_track_scan_metrics() {
  track_scan_metrics_ = false;
  clear_has_track_scan_metrics();
}
inline bool ScanRequest::track_scan_metrics() const {
  return track_scan_metrics_;
}
inline void ScanRequest::set_track_scan_metrics(bool value) {
  set_has_track_scan_metrics();
  track_scan_metrics_ = value;
}

// optional bool renew = 10 [default = false];
inline bool ScanRequest::has_renew() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScanRequest::set_has_renew() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScanRequest::clear_has_renew() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScanRequest::clear_renew() {
  renew_ = false;
  clear_has_renew();
}
inline bool ScanRequest::renew() const {
  return renew_;
}
inline void ScanRequest::set_renew(bool value) {
  set_has_renew();
  renew_ = value;
}

// -------------------------------------------------------------------

// ScanResponse

// repeated uint32 cells_per_result = 1;
inline int ScanResponse::cells_per_result_size() const {
  return cells_per_result_.size();
}
inline void ScanResponse::clear_cells_per_result() {
  cells_per_result_.Clear();
}
inline ::google::protobuf::uint32 ScanResponse::cells_per_result(int index) const {
  return cells_per_result_.Get(index);
}
inline void ScanResponse::set_cells_per_result(int index, ::google::protobuf::uint32 value) {
  cells_per_result_.Set(index, value);
}
inline void ScanResponse::add_cells_per_result(::google::protobuf::uint32 value) {
  cells_per_result_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ScanResponse::cells_per_result() const {
  return cells_per_result_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ScanResponse::mutable_cells_per_result() {
  return &cells_per_result_;
}

// optional uint64 scanner_id = 2;
inline bool ScanResponse::has_scanner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanResponse::set_has_scanner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanResponse::clear_has_scanner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanResponse::clear_scanner_id() {
  scanner_id_ = GOOGLE_ULONGLONG(0);
  clear_has_scanner_id();
}
inline ::google::protobuf::uint64 ScanResponse::scanner_id() const {
  return scanner_id_;
}
inline void ScanResponse::set_scanner_id(::google::protobuf::uint64 value) {
  set_has_scanner_id();
  scanner_id_ = value;
}

// optional bool more_results = 3;
inline bool ScanResponse::has_more_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanResponse::set_has_more_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScanResponse::clear_has_more_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScanResponse::clear_more_results() {
  more_results_ = false;
  clear_has_more_results();
}
inline bool ScanResponse::more_results() const {
  return more_results_;
}
inline void ScanResponse::set_more_results(bool value) {
  set_has_more_results();
  more_results_ = value;
}

// optional uint32 ttl = 4;
inline bool ScanResponse::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanResponse::set_has_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScanResponse::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScanResponse::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 ScanResponse::ttl() const {
  return ttl_;
}
inline void ScanResponse::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// repeated .hbase.pb.Result results = 5;
inline int ScanResponse::results_size() const {
  return results_.size();
}
inline void ScanResponse::clear_results() {
  results_.Clear();
}
inline const ::hbase::pb::Result& ScanResponse::results(int index) const {
  return results_.Get(index);
}
inline ::hbase::pb::Result* ScanResponse::mutable_results(int index) {
  return results_.Mutable(index);
}
inline ::hbase::pb::Result* ScanResponse::add_results() {
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Result >&
ScanResponse::results() const {
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Result >*
ScanResponse::mutable_results() {
  return &results_;
}

// optional bool stale = 6;
inline bool ScanResponse::has_stale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScanResponse::set_has_stale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScanResponse::clear_has_stale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScanResponse::clear_stale() {
  stale_ = false;
  clear_has_stale();
}
inline bool ScanResponse::stale() const {
  return stale_;
}
inline void ScanResponse::set_stale(bool value) {
  set_has_stale();
  stale_ = value;
}

// repeated bool partial_flag_per_result = 7;
inline int ScanResponse::partial_flag_per_result_size() const {
  return partial_flag_per_result_.size();
}
inline void ScanResponse::clear_partial_flag_per_result() {
  partial_flag_per_result_.Clear();
}
inline bool ScanResponse::partial_flag_per_result(int index) const {
  return partial_flag_per_result_.Get(index);
}
inline void ScanResponse::set_partial_flag_per_result(int index, bool value) {
  partial_flag_per_result_.Set(index, value);
}
inline void ScanResponse::add_partial_flag_per_result(bool value) {
  partial_flag_per_result_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
ScanResponse::partial_flag_per_result() const {
  return partial_flag_per_result_;
}
inline ::google::protobuf::RepeatedField< bool >*
ScanResponse::mutable_partial_flag_per_result() {
  return &partial_flag_per_result_;
}

// optional bool more_results_in_region = 8;
inline bool ScanResponse::has_more_results_in_region() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScanResponse::set_has_more_results_in_region() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScanResponse::clear_has_more_results_in_region() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScanResponse::clear_more_results_in_region() {
  more_results_in_region_ = false;
  clear_has_more_results_in_region();
}
inline bool ScanResponse::more_results_in_region() const {
  return more_results_in_region_;
}
inline void ScanResponse::set_more_results_in_region(bool value) {
  set_has_more_results_in_region();
  more_results_in_region_ = value;
}

// optional bool heartbeat_message = 9;
inline bool ScanResponse::has_heartbeat_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScanResponse::set_has_heartbeat_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScanResponse::clear_has_heartbeat_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScanResponse::clear_heartbeat_message() {
  heartbeat_message_ = false;
  clear_has_heartbeat_message();
}
inline bool ScanResponse::heartbeat_message() const {
  return heartbeat_message_;
}
inline void ScanResponse::set_heartbeat_message(bool value) {
  set_has_heartbeat_message();
  heartbeat_message_ = value;
}

// optional .hbase.pb.ScanMetrics scan_metrics = 10;
inline bool ScanResponse::has_scan_metrics() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScanResponse::set_has_scan_metrics() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScanResponse::clear_has_scan_metrics() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScanResponse::clear_scan_metrics() {
  if (scan_metrics_ != NULL) scan_metrics_->::hbase::pb::ScanMetrics::Clear();
  clear_has_scan_metrics();
}
inline const ::hbase::pb::ScanMetrics& ScanResponse::scan_metrics() const {
  return scan_metrics_ != NULL ? *scan_metrics_ : *default_instance_->scan_metrics_;
}
inline ::hbase::pb::ScanMetrics* ScanResponse::mutable_scan_metrics() {
  set_has_scan_metrics();
  if (scan_metrics_ == NULL) scan_metrics_ = new ::hbase::pb::ScanMetrics;
  return scan_metrics_;
}
inline ::hbase::pb::ScanMetrics* ScanResponse::release_scan_metrics() {
  clear_has_scan_metrics();
  ::hbase::pb::ScanMetrics* temp = scan_metrics_;
  scan_metrics_ = NULL;
  return temp;
}
inline void ScanResponse::set_allocated_scan_metrics(::hbase::pb::ScanMetrics* scan_metrics) {
  delete scan_metrics_;
  scan_metrics_ = scan_metrics;
  if (scan_metrics) {
    set_has_scan_metrics();
  } else {
    clear_has_scan_metrics();
  }
}

// -------------------------------------------------------------------

// BulkLoadHFileRequest_FamilyPath

// required bytes family = 1;
inline bool BulkLoadHFileRequest_FamilyPath::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileRequest_FamilyPath::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& BulkLoadHFileRequest_FamilyPath::family() const {
  return *family_;
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const void* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulkLoadHFileRequest_FamilyPath::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* BulkLoadHFileRequest_FamilyPath::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulkLoadHFileRequest_FamilyPath::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool BulkLoadHFileRequest_FamilyPath::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulkLoadHFileRequest_FamilyPath::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& BulkLoadHFileRequest_FamilyPath::path() const {
  return *path_;
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulkLoadHFileRequest_FamilyPath::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* BulkLoadHFileRequest_FamilyPath::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulkLoadHFileRequest_FamilyPath::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BulkLoadHFileRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool BulkLoadHFileRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileRequest::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulkLoadHFileRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulkLoadHFileRequest::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& BulkLoadHFileRequest::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* BulkLoadHFileRequest::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* BulkLoadHFileRequest::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void BulkLoadHFileRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 2;
inline int BulkLoadHFileRequest::family_path_size() const {
  return family_path_.size();
}
inline void BulkLoadHFileRequest::clear_family_path() {
  family_path_.Clear();
}
inline const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& BulkLoadHFileRequest::family_path(int index) const {
  return family_path_.Get(index);
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* BulkLoadHFileRequest::mutable_family_path(int index) {
  return family_path_.Mutable(index);
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* BulkLoadHFileRequest::add_family_path() {
  return family_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
BulkLoadHFileRequest::family_path() const {
  return family_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
BulkLoadHFileRequest::mutable_family_path() {
  return &family_path_;
}

// optional bool assign_seq_num = 3;
inline bool BulkLoadHFileRequest::has_assign_seq_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulkLoadHFileRequest::set_has_assign_seq_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BulkLoadHFileRequest::clear_has_assign_seq_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BulkLoadHFileRequest::clear_assign_seq_num() {
  assign_seq_num_ = false;
  clear_has_assign_seq_num();
}
inline bool BulkLoadHFileRequest::assign_seq_num() const {
  return assign_seq_num_;
}
inline void BulkLoadHFileRequest::set_assign_seq_num(bool value) {
  set_has_assign_seq_num();
  assign_seq_num_ = value;
}

// -------------------------------------------------------------------

// BulkLoadHFileResponse

// required bool loaded = 1;
inline bool BulkLoadHFileResponse::has_loaded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileResponse::set_has_loaded() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulkLoadHFileResponse::clear_has_loaded() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulkLoadHFileResponse::clear_loaded() {
  loaded_ = false;
  clear_has_loaded();
}
inline bool BulkLoadHFileResponse::loaded() const {
  return loaded_;
}
inline void BulkLoadHFileResponse::set_loaded(bool value) {
  set_has_loaded();
  loaded_ = value;
}

// -------------------------------------------------------------------

// CoprocessorServiceCall

// required bytes row = 1;
inline bool CoprocessorServiceCall::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoprocessorServiceCall::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoprocessorServiceCall::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoprocessorServiceCall::clear_row() {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    row_->clear();
  }
  clear_has_row();
}
inline const ::std::string& CoprocessorServiceCall::row() const {
  return *row_;
}
inline void CoprocessorServiceCall::set_row(const ::std::string& value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void CoprocessorServiceCall::set_row(const char* value) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(value);
}
inline void CoprocessorServiceCall::set_row(const void* value, size_t size) {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  row_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoprocessorServiceCall::mutable_row() {
  set_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    row_ = new ::std::string;
  }
  return row_;
}
inline ::std::string* CoprocessorServiceCall::release_row() {
  clear_has_row();
  if (row_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = row_;
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoprocessorServiceCall::set_allocated_row(::std::string* row) {
  if (row_ != &::google::protobuf::internal::kEmptyString) {
    delete row_;
  }
  if (row) {
    set_has_row();
    row_ = row;
  } else {
    clear_has_row();
    row_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string service_name = 2;
inline bool CoprocessorServiceCall::has_service_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoprocessorServiceCall::set_has_service_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoprocessorServiceCall::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoprocessorServiceCall::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& CoprocessorServiceCall::service_name() const {
  return *service_name_;
}
inline void CoprocessorServiceCall::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void CoprocessorServiceCall::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void CoprocessorServiceCall::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoprocessorServiceCall::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* CoprocessorServiceCall::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoprocessorServiceCall::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string method_name = 3;
inline bool CoprocessorServiceCall::has_method_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoprocessorServiceCall::set_has_method_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoprocessorServiceCall::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoprocessorServiceCall::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& CoprocessorServiceCall::method_name() const {
  return *method_name_;
}
inline void CoprocessorServiceCall::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CoprocessorServiceCall::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CoprocessorServiceCall::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoprocessorServiceCall::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}
inline ::std::string* CoprocessorServiceCall::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoprocessorServiceCall::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes request = 4;
inline bool CoprocessorServiceCall::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoprocessorServiceCall::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoprocessorServiceCall::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoprocessorServiceCall::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& CoprocessorServiceCall::request() const {
  return *request_;
}
inline void CoprocessorServiceCall::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void CoprocessorServiceCall::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void CoprocessorServiceCall::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoprocessorServiceCall::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* CoprocessorServiceCall::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoprocessorServiceCall::set_allocated_request(::std::string* request) {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    delete request_;
  }
  if (request) {
    set_has_request();
    request_ = request;
  } else {
    clear_has_request();
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CoprocessorServiceResult

// optional .hbase.pb.NameBytesPair value = 1;
inline bool CoprocessorServiceResult::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoprocessorServiceResult::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoprocessorServiceResult::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoprocessorServiceResult::clear_value() {
  if (value_ != NULL) value_->::hbase::pb::NameBytesPair::Clear();
  clear_has_value();
}
inline const ::hbase::pb::NameBytesPair& CoprocessorServiceResult::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResult::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::hbase::pb::NameBytesPair;
  return value_;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResult::release_value() {
  clear_has_value();
  ::hbase::pb::NameBytesPair* temp = value_;
  value_ = NULL;
  return temp;
}
inline void CoprocessorServiceResult::set_allocated_value(::hbase::pb::NameBytesPair* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// CoprocessorServiceRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool CoprocessorServiceRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoprocessorServiceRequest::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoprocessorServiceRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoprocessorServiceRequest::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& CoprocessorServiceRequest::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceRequest::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceRequest::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void CoprocessorServiceRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// required .hbase.pb.CoprocessorServiceCall call = 2;
inline bool CoprocessorServiceRequest::has_call() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoprocessorServiceRequest::set_has_call() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoprocessorServiceRequest::clear_has_call() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoprocessorServiceRequest::clear_call() {
  if (call_ != NULL) call_->::hbase::pb::CoprocessorServiceCall::Clear();
  clear_has_call();
}
inline const ::hbase::pb::CoprocessorServiceCall& CoprocessorServiceRequest::call() const {
  return call_ != NULL ? *call_ : *default_instance_->call_;
}
inline ::hbase::pb::CoprocessorServiceCall* CoprocessorServiceRequest::mutable_call() {
  set_has_call();
  if (call_ == NULL) call_ = new ::hbase::pb::CoprocessorServiceCall;
  return call_;
}
inline ::hbase::pb::CoprocessorServiceCall* CoprocessorServiceRequest::release_call() {
  clear_has_call();
  ::hbase::pb::CoprocessorServiceCall* temp = call_;
  call_ = NULL;
  return temp;
}
inline void CoprocessorServiceRequest::set_allocated_call(::hbase::pb::CoprocessorServiceCall* call) {
  delete call_;
  call_ = call;
  if (call) {
    set_has_call();
  } else {
    clear_has_call();
  }
}

// -------------------------------------------------------------------

// CoprocessorServiceResponse

// required .hbase.pb.RegionSpecifier region = 1;
inline bool CoprocessorServiceResponse::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoprocessorServiceResponse::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoprocessorServiceResponse::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoprocessorServiceResponse::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& CoprocessorServiceResponse::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceResponse::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceResponse::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void CoprocessorServiceResponse::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// required .hbase.pb.NameBytesPair value = 2;
inline bool CoprocessorServiceResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoprocessorServiceResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoprocessorServiceResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoprocessorServiceResponse::clear_value() {
  if (value_ != NULL) value_->::hbase::pb::NameBytesPair::Clear();
  clear_has_value();
}
inline const ::hbase::pb::NameBytesPair& CoprocessorServiceResponse::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::hbase::pb::NameBytesPair;
  return value_;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResponse::release_value() {
  clear_has_value();
  ::hbase::pb::NameBytesPair* temp = value_;
  value_ = NULL;
  return temp;
}
inline void CoprocessorServiceResponse::set_allocated_value(::hbase::pb::NameBytesPair* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// Action

// optional uint32 index = 1;
inline bool Action::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Action::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Action::index() const {
  return index_;
}
inline void Action::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .hbase.pb.MutationProto mutation = 2;
inline bool Action::has_mutation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_mutation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_mutation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Action::clear_mutation() {
  if (mutation_ != NULL) mutation_->::hbase::pb::MutationProto::Clear();
  clear_has_mutation();
}
inline const ::hbase::pb::MutationProto& Action::mutation() const {
  return mutation_ != NULL ? *mutation_ : *default_instance_->mutation_;
}
inline ::hbase::pb::MutationProto* Action::mutable_mutation() {
  set_has_mutation();
  if (mutation_ == NULL) mutation_ = new ::hbase::pb::MutationProto;
  return mutation_;
}
inline ::hbase::pb::MutationProto* Action::release_mutation() {
  clear_has_mutation();
  ::hbase::pb::MutationProto* temp = mutation_;
  mutation_ = NULL;
  return temp;
}
inline void Action::set_allocated_mutation(::hbase::pb::MutationProto* mutation) {
  delete mutation_;
  mutation_ = mutation;
  if (mutation) {
    set_has_mutation();
  } else {
    clear_has_mutation();
  }
}

// optional .hbase.pb.Get get = 3;
inline bool Action::has_get() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_get() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_get() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Action::clear_get() {
  if (get_ != NULL) get_->::hbase::pb::Get::Clear();
  clear_has_get();
}
inline const ::hbase::pb::Get& Action::get() const {
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::hbase::pb::Get* Action::mutable_get() {
  set_has_get();
  if (get_ == NULL) get_ = new ::hbase::pb::Get;
  return get_;
}
inline ::hbase::pb::Get* Action::release_get() {
  clear_has_get();
  ::hbase::pb::Get* temp = get_;
  get_ = NULL;
  return temp;
}
inline void Action::set_allocated_get(::hbase::pb::Get* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
}

// optional .hbase.pb.CoprocessorServiceCall service_call = 4;
inline bool Action::has_service_call() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_service_call() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_service_call() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Action::clear_service_call() {
  if (service_call_ != NULL) service_call_->::hbase::pb::CoprocessorServiceCall::Clear();
  clear_has_service_call();
}
inline const ::hbase::pb::CoprocessorServiceCall& Action::service_call() const {
  return service_call_ != NULL ? *service_call_ : *default_instance_->service_call_;
}
inline ::hbase::pb::CoprocessorServiceCall* Action::mutable_service_call() {
  set_has_service_call();
  if (service_call_ == NULL) service_call_ = new ::hbase::pb::CoprocessorServiceCall;
  return service_call_;
}
inline ::hbase::pb::CoprocessorServiceCall* Action::release_service_call() {
  clear_has_service_call();
  ::hbase::pb::CoprocessorServiceCall* temp = service_call_;
  service_call_ = NULL;
  return temp;
}
inline void Action::set_allocated_service_call(::hbase::pb::CoprocessorServiceCall* service_call) {
  delete service_call_;
  service_call_ = service_call;
  if (service_call) {
    set_has_service_call();
  } else {
    clear_has_service_call();
  }
}

// -------------------------------------------------------------------

// RegionAction

// required .hbase.pb.RegionSpecifier region = 1;
inline bool RegionAction::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionAction::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionAction::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionAction::clear_region() {
  if (region_ != NULL) region_->::hbase::pb::RegionSpecifier::Clear();
  clear_has_region();
}
inline const ::hbase::pb::RegionSpecifier& RegionAction::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::hbase::pb::RegionSpecifier* RegionAction::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::hbase::pb::RegionSpecifier;
  return region_;
}
inline ::hbase::pb::RegionSpecifier* RegionAction::release_region() {
  clear_has_region();
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = NULL;
  return temp;
}
inline void RegionAction::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// optional bool atomic = 2;
inline bool RegionAction::has_atomic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionAction::set_has_atomic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionAction::clear_has_atomic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionAction::clear_atomic() {
  atomic_ = false;
  clear_has_atomic();
}
inline bool RegionAction::atomic() const {
  return atomic_;
}
inline void RegionAction::set_atomic(bool value) {
  set_has_atomic();
  atomic_ = value;
}

// repeated .hbase.pb.Action action = 3;
inline int RegionAction::action_size() const {
  return action_.size();
}
inline void RegionAction::clear_action() {
  action_.Clear();
}
inline const ::hbase::pb::Action& RegionAction::action(int index) const {
  return action_.Get(index);
}
inline ::hbase::pb::Action* RegionAction::mutable_action(int index) {
  return action_.Mutable(index);
}
inline ::hbase::pb::Action* RegionAction::add_action() {
  return action_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::Action >&
RegionAction::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::Action >*
RegionAction::mutable_action() {
  return &action_;
}

// -------------------------------------------------------------------

// RegionLoadStats

// optional int32 memstoreLoad = 1 [default = 0];
inline bool RegionLoadStats::has_memstoreload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionLoadStats::set_has_memstoreload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionLoadStats::clear_has_memstoreload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionLoadStats::clear_memstoreload() {
  memstoreload_ = 0;
  clear_has_memstoreload();
}
inline ::google::protobuf::int32 RegionLoadStats::memstoreload() const {
  return memstoreload_;
}
inline void RegionLoadStats::set_memstoreload(::google::protobuf::int32 value) {
  set_has_memstoreload();
  memstoreload_ = value;
}

// optional int32 heapOccupancy = 2 [default = 0];
inline bool RegionLoadStats::has_heapoccupancy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionLoadStats::set_has_heapoccupancy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionLoadStats::clear_has_heapoccupancy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionLoadStats::clear_heapoccupancy() {
  heapoccupancy_ = 0;
  clear_has_heapoccupancy();
}
inline ::google::protobuf::int32 RegionLoadStats::heapoccupancy() const {
  return heapoccupancy_;
}
inline void RegionLoadStats::set_heapoccupancy(::google::protobuf::int32 value) {
  set_has_heapoccupancy();
  heapoccupancy_ = value;
}

// optional int32 compactionPressure = 3 [default = 0];
inline bool RegionLoadStats::has_compactionpressure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionLoadStats::set_has_compactionpressure() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionLoadStats::clear_has_compactionpressure() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionLoadStats::clear_compactionpressure() {
  compactionpressure_ = 0;
  clear_has_compactionpressure();
}
inline ::google::protobuf::int32 RegionLoadStats::compactionpressure() const {
  return compactionpressure_;
}
inline void RegionLoadStats::set_compactionpressure(::google::protobuf::int32 value) {
  set_has_compactionpressure();
  compactionpressure_ = value;
}

// -------------------------------------------------------------------

// MultiRegionLoadStats

// repeated .hbase.pb.RegionSpecifier region = 1;
inline int MultiRegionLoadStats::region_size() const {
  return region_.size();
}
inline void MultiRegionLoadStats::clear_region() {
  region_.Clear();
}
inline const ::hbase::pb::RegionSpecifier& MultiRegionLoadStats::region(int index) const {
  return region_.Get(index);
}
inline ::hbase::pb::RegionSpecifier* MultiRegionLoadStats::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::hbase::pb::RegionSpecifier* MultiRegionLoadStats::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionSpecifier >&
MultiRegionLoadStats::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionSpecifier >*
MultiRegionLoadStats::mutable_region() {
  return &region_;
}

// repeated .hbase.pb.RegionLoadStats stat = 2;
inline int MultiRegionLoadStats::stat_size() const {
  return stat_.size();
}
inline void MultiRegionLoadStats::clear_stat() {
  stat_.Clear();
}
inline const ::hbase::pb::RegionLoadStats& MultiRegionLoadStats::stat(int index) const {
  return stat_.Get(index);
}
inline ::hbase::pb::RegionLoadStats* MultiRegionLoadStats::mutable_stat(int index) {
  return stat_.Mutable(index);
}
inline ::hbase::pb::RegionLoadStats* MultiRegionLoadStats::add_stat() {
  return stat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionLoadStats >&
MultiRegionLoadStats::stat() const {
  return stat_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionLoadStats >*
MultiRegionLoadStats::mutable_stat() {
  return &stat_;
}

// -------------------------------------------------------------------

// ResultOrException

// optional uint32 index = 1;
inline bool ResultOrException::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultOrException::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultOrException::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultOrException::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ResultOrException::index() const {
  return index_;
}
inline void ResultOrException::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .hbase.pb.Result result = 2;
inline bool ResultOrException::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultOrException::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultOrException::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultOrException::clear_result() {
  if (result_ != NULL) result_->::hbase::pb::Result::Clear();
  clear_has_result();
}
inline const ::hbase::pb::Result& ResultOrException::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::hbase::pb::Result* ResultOrException::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::hbase::pb::Result;
  return result_;
}
inline ::hbase::pb::Result* ResultOrException::release_result() {
  clear_has_result();
  ::hbase::pb::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResultOrException::set_allocated_result(::hbase::pb::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .hbase.pb.NameBytesPair exception = 3;
inline bool ResultOrException::has_exception() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultOrException::set_has_exception() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultOrException::clear_has_exception() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultOrException::clear_exception() {
  if (exception_ != NULL) exception_->::hbase::pb::NameBytesPair::Clear();
  clear_has_exception();
}
inline const ::hbase::pb::NameBytesPair& ResultOrException::exception() const {
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::hbase::pb::NameBytesPair* ResultOrException::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::hbase::pb::NameBytesPair;
  return exception_;
}
inline ::hbase::pb::NameBytesPair* ResultOrException::release_exception() {
  clear_has_exception();
  ::hbase::pb::NameBytesPair* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void ResultOrException::set_allocated_exception(::hbase::pb::NameBytesPair* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
}

// optional .hbase.pb.CoprocessorServiceResult service_result = 4;
inline bool ResultOrException::has_service_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultOrException::set_has_service_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResultOrException::clear_has_service_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResultOrException::clear_service_result() {
  if (service_result_ != NULL) service_result_->::hbase::pb::CoprocessorServiceResult::Clear();
  clear_has_service_result();
}
inline const ::hbase::pb::CoprocessorServiceResult& ResultOrException::service_result() const {
  return service_result_ != NULL ? *service_result_ : *default_instance_->service_result_;
}
inline ::hbase::pb::CoprocessorServiceResult* ResultOrException::mutable_service_result() {
  set_has_service_result();
  if (service_result_ == NULL) service_result_ = new ::hbase::pb::CoprocessorServiceResult;
  return service_result_;
}
inline ::hbase::pb::CoprocessorServiceResult* ResultOrException::release_service_result() {
  clear_has_service_result();
  ::hbase::pb::CoprocessorServiceResult* temp = service_result_;
  service_result_ = NULL;
  return temp;
}
inline void ResultOrException::set_allocated_service_result(::hbase::pb::CoprocessorServiceResult* service_result) {
  delete service_result_;
  service_result_ = service_result;
  if (service_result) {
    set_has_service_result();
  } else {
    clear_has_service_result();
  }
}

// optional .hbase.pb.RegionLoadStats loadStats = 5 [deprecated = true];
inline bool ResultOrException::has_loadstats() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultOrException::set_has_loadstats() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResultOrException::clear_has_loadstats() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResultOrException::clear_loadstats() {
  if (loadstats_ != NULL) loadstats_->::hbase::pb::RegionLoadStats::Clear();
  clear_has_loadstats();
}
inline const ::hbase::pb::RegionLoadStats& ResultOrException::loadstats() const {
  return loadstats_ != NULL ? *loadstats_ : *default_instance_->loadstats_;
}
inline ::hbase::pb::RegionLoadStats* ResultOrException::mutable_loadstats() {
  set_has_loadstats();
  if (loadstats_ == NULL) loadstats_ = new ::hbase::pb::RegionLoadStats;
  return loadstats_;
}
inline ::hbase::pb::RegionLoadStats* ResultOrException::release_loadstats() {
  clear_has_loadstats();
  ::hbase::pb::RegionLoadStats* temp = loadstats_;
  loadstats_ = NULL;
  return temp;
}
inline void ResultOrException::set_allocated_loadstats(::hbase::pb::RegionLoadStats* loadstats) {
  delete loadstats_;
  loadstats_ = loadstats;
  if (loadstats) {
    set_has_loadstats();
  } else {
    clear_has_loadstats();
  }
}

// -------------------------------------------------------------------

// RegionActionResult

// repeated .hbase.pb.ResultOrException resultOrException = 1;
inline int RegionActionResult::resultorexception_size() const {
  return resultorexception_.size();
}
inline void RegionActionResult::clear_resultorexception() {
  resultorexception_.Clear();
}
inline const ::hbase::pb::ResultOrException& RegionActionResult::resultorexception(int index) const {
  return resultorexception_.Get(index);
}
inline ::hbase::pb::ResultOrException* RegionActionResult::mutable_resultorexception(int index) {
  return resultorexception_.Mutable(index);
}
inline ::hbase::pb::ResultOrException* RegionActionResult::add_resultorexception() {
  return resultorexception_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::ResultOrException >&
RegionActionResult::resultorexception() const {
  return resultorexception_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::ResultOrException >*
RegionActionResult::mutable_resultorexception() {
  return &resultorexception_;
}

// optional .hbase.pb.NameBytesPair exception = 2;
inline bool RegionActionResult::has_exception() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionActionResult::set_has_exception() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionActionResult::clear_has_exception() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionActionResult::clear_exception() {
  if (exception_ != NULL) exception_->::hbase::pb::NameBytesPair::Clear();
  clear_has_exception();
}
inline const ::hbase::pb::NameBytesPair& RegionActionResult::exception() const {
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::hbase::pb::NameBytesPair* RegionActionResult::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::hbase::pb::NameBytesPair;
  return exception_;
}
inline ::hbase::pb::NameBytesPair* RegionActionResult::release_exception() {
  clear_has_exception();
  ::hbase::pb::NameBytesPair* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void RegionActionResult::set_allocated_exception(::hbase::pb::NameBytesPair* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
}

// -------------------------------------------------------------------

// MultiRequest

// repeated .hbase.pb.RegionAction regionAction = 1;
inline int MultiRequest::regionaction_size() const {
  return regionaction_.size();
}
inline void MultiRequest::clear_regionaction() {
  regionaction_.Clear();
}
inline const ::hbase::pb::RegionAction& MultiRequest::regionaction(int index) const {
  return regionaction_.Get(index);
}
inline ::hbase::pb::RegionAction* MultiRequest::mutable_regionaction(int index) {
  return regionaction_.Mutable(index);
}
inline ::hbase::pb::RegionAction* MultiRequest::add_regionaction() {
  return regionaction_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionAction >&
MultiRequest::regionaction() const {
  return regionaction_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionAction >*
MultiRequest::mutable_regionaction() {
  return &regionaction_;
}

// optional uint64 nonceGroup = 2;
inline bool MultiRequest::has_noncegroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiRequest::set_has_noncegroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiRequest::clear_has_noncegroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiRequest::clear_noncegroup() {
  noncegroup_ = GOOGLE_ULONGLONG(0);
  clear_has_noncegroup();
}
inline ::google::protobuf::uint64 MultiRequest::noncegroup() const {
  return noncegroup_;
}
inline void MultiRequest::set_noncegroup(::google::protobuf::uint64 value) {
  set_has_noncegroup();
  noncegroup_ = value;
}

// optional .hbase.pb.Condition condition = 3;
inline bool MultiRequest::has_condition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiRequest::set_has_condition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiRequest::clear_has_condition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiRequest::clear_condition() {
  if (condition_ != NULL) condition_->::hbase::pb::Condition::Clear();
  clear_has_condition();
}
inline const ::hbase::pb::Condition& MultiRequest::condition() const {
  return condition_ != NULL ? *condition_ : *default_instance_->condition_;
}
inline ::hbase::pb::Condition* MultiRequest::mutable_condition() {
  set_has_condition();
  if (condition_ == NULL) condition_ = new ::hbase::pb::Condition;
  return condition_;
}
inline ::hbase::pb::Condition* MultiRequest::release_condition() {
  clear_has_condition();
  ::hbase::pb::Condition* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline void MultiRequest::set_allocated_condition(::hbase::pb::Condition* condition) {
  delete condition_;
  condition_ = condition;
  if (condition) {
    set_has_condition();
  } else {
    clear_has_condition();
  }
}

// -------------------------------------------------------------------

// MultiResponse

// repeated .hbase.pb.RegionActionResult regionActionResult = 1;
inline int MultiResponse::regionactionresult_size() const {
  return regionactionresult_.size();
}
inline void MultiResponse::clear_regionactionresult() {
  regionactionresult_.Clear();
}
inline const ::hbase::pb::RegionActionResult& MultiResponse::regionactionresult(int index) const {
  return regionactionresult_.Get(index);
}
inline ::hbase::pb::RegionActionResult* MultiResponse::mutable_regionactionresult(int index) {
  return regionactionresult_.Mutable(index);
}
inline ::hbase::pb::RegionActionResult* MultiResponse::add_regionactionresult() {
  return regionactionresult_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionActionResult >&
MultiResponse::regionactionresult() const {
  return regionactionresult_;
}
inline ::google::protobuf::RepeatedPtrField< ::hbase::pb::RegionActionResult >*
MultiResponse::mutable_regionactionresult() {
  return &regionactionresult_;
}

// optional bool processed = 2;
inline bool MultiResponse::has_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiResponse::set_has_processed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiResponse::clear_has_processed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiResponse::clear_processed() {
  processed_ = false;
  clear_has_processed();
}
inline bool MultiResponse::processed() const {
  return processed_;
}
inline void MultiResponse::set_processed(bool value) {
  set_has_processed();
  processed_ = value;
}

// optional .hbase.pb.MultiRegionLoadStats regionStatistics = 3;
inline bool MultiResponse::has_regionstatistics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiResponse::set_has_regionstatistics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiResponse::clear_has_regionstatistics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiResponse::clear_regionstatistics() {
  if (regionstatistics_ != NULL) regionstatistics_->::hbase::pb::MultiRegionLoadStats::Clear();
  clear_has_regionstatistics();
}
inline const ::hbase::pb::MultiRegionLoadStats& MultiResponse::regionstatistics() const {
  return regionstatistics_ != NULL ? *regionstatistics_ : *default_instance_->regionstatistics_;
}
inline ::hbase::pb::MultiRegionLoadStats* MultiResponse::mutable_regionstatistics() {
  set_has_regionstatistics();
  if (regionstatistics_ == NULL) regionstatistics_ = new ::hbase::pb::MultiRegionLoadStats;
  return regionstatistics_;
}
inline ::hbase::pb::MultiRegionLoadStats* MultiResponse::release_regionstatistics() {
  clear_has_regionstatistics();
  ::hbase::pb::MultiRegionLoadStats* temp = regionstatistics_;
  regionstatistics_ = NULL;
  return temp;
}
inline void MultiResponse::set_allocated_regionstatistics(::hbase::pb::MultiRegionLoadStats* regionstatistics) {
  delete regionstatistics_;
  regionstatistics_ = regionstatistics;
  if (regionstatistics) {
    set_has_regionstatistics();
  } else {
    clear_has_regionstatistics();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_Durability>() {
  return ::hbase::pb::MutationProto_Durability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_MutationType>() {
  return ::hbase::pb::MutationProto_MutationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_DeleteType>() {
  return ::hbase::pb::MutationProto_DeleteType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Consistency>() {
  return ::hbase::pb::Consistency_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Client_2eproto__INCLUDED
