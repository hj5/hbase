// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Quota.proto

#ifndef PROTOBUF_Quota_2eproto__INCLUDED
#define PROTOBUF_Quota_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
// @@protoc_insertion_point(includes)

namespace hbase {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Quota_2eproto();
void protobuf_AssignDesc_Quota_2eproto();
void protobuf_ShutdownFile_Quota_2eproto();

class TimedQuota;
class Throttle;
class ThrottleRequest;
class Quotas;
class QuotaUsage;

enum QuotaScope {
  CLUSTER = 1,
  MACHINE = 2
};
bool QuotaScope_IsValid(int value);
const QuotaScope QuotaScope_MIN = CLUSTER;
const QuotaScope QuotaScope_MAX = MACHINE;
const int QuotaScope_ARRAYSIZE = QuotaScope_MAX + 1;

const ::google::protobuf::EnumDescriptor* QuotaScope_descriptor();
inline const ::std::string& QuotaScope_Name(QuotaScope value) {
  return ::google::protobuf::internal::NameOfEnum(
    QuotaScope_descriptor(), value);
}
inline bool QuotaScope_Parse(
    const ::std::string& name, QuotaScope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuotaScope>(
    QuotaScope_descriptor(), name, value);
}
enum ThrottleType {
  REQUEST_NUMBER = 1,
  REQUEST_SIZE = 2,
  WRITE_NUMBER = 3,
  WRITE_SIZE = 4,
  READ_NUMBER = 5,
  READ_SIZE = 6
};
bool ThrottleType_IsValid(int value);
const ThrottleType ThrottleType_MIN = REQUEST_NUMBER;
const ThrottleType ThrottleType_MAX = READ_SIZE;
const int ThrottleType_ARRAYSIZE = ThrottleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ThrottleType_descriptor();
inline const ::std::string& ThrottleType_Name(ThrottleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ThrottleType_descriptor(), value);
}
inline bool ThrottleType_Parse(
    const ::std::string& name, ThrottleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ThrottleType>(
    ThrottleType_descriptor(), name, value);
}
enum QuotaType {
  THROTTLE = 1
};
bool QuotaType_IsValid(int value);
const QuotaType QuotaType_MIN = THROTTLE;
const QuotaType QuotaType_MAX = THROTTLE;
const int QuotaType_ARRAYSIZE = QuotaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* QuotaType_descriptor();
inline const ::std::string& QuotaType_Name(QuotaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    QuotaType_descriptor(), value);
}
inline bool QuotaType_Parse(
    const ::std::string& name, QuotaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuotaType>(
    QuotaType_descriptor(), name, value);
}
// ===================================================================

class TimedQuota : public ::google::protobuf::Message {
 public:
  TimedQuota();
  virtual ~TimedQuota();

  TimedQuota(const TimedQuota& from);

  inline TimedQuota& operator=(const TimedQuota& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimedQuota& default_instance();

  void Swap(TimedQuota* other);

  // implements Message ----------------------------------------------

  TimedQuota* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimedQuota& from);
  void MergeFrom(const TimedQuota& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hbase.pb.TimeUnit time_unit = 1;
  inline bool has_time_unit() const;
  inline void clear_time_unit();
  static const int kTimeUnitFieldNumber = 1;
  inline ::hbase::pb::TimeUnit time_unit() const;
  inline void set_time_unit(::hbase::pb::TimeUnit value);

  // optional uint64 soft_limit = 2;
  inline bool has_soft_limit() const;
  inline void clear_soft_limit();
  static const int kSoftLimitFieldNumber = 2;
  inline ::google::protobuf::uint64 soft_limit() const;
  inline void set_soft_limit(::google::protobuf::uint64 value);

  // optional float share = 3;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 3;
  inline float share() const;
  inline void set_share(float value);

  // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
  inline bool has_scope() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 4;
  inline ::hbase::pb::QuotaScope scope() const;
  inline void set_scope(::hbase::pb::QuotaScope value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TimedQuota)
 private:
  inline void set_has_time_unit();
  inline void clear_has_time_unit();
  inline void set_has_soft_limit();
  inline void clear_has_soft_limit();
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_scope();
  inline void clear_has_scope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 soft_limit_;
  int time_unit_;
  float share_;
  int scope_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Quota_2eproto();
  friend void protobuf_AssignDesc_Quota_2eproto();
  friend void protobuf_ShutdownFile_Quota_2eproto();

  void InitAsDefaultInstance();
  static TimedQuota* default_instance_;
};
// -------------------------------------------------------------------

class Throttle : public ::google::protobuf::Message {
 public:
  Throttle();
  virtual ~Throttle();

  Throttle(const Throttle& from);

  inline Throttle& operator=(const Throttle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Throttle& default_instance();

  void Swap(Throttle* other);

  // implements Message ----------------------------------------------

  Throttle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Throttle& from);
  void MergeFrom(const Throttle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.TimedQuota req_num = 1;
  inline bool has_req_num() const;
  inline void clear_req_num();
  static const int kReqNumFieldNumber = 1;
  inline const ::hbase::pb::TimedQuota& req_num() const;
  inline ::hbase::pb::TimedQuota* mutable_req_num();
  inline ::hbase::pb::TimedQuota* release_req_num();
  inline void set_allocated_req_num(::hbase::pb::TimedQuota* req_num);

  // optional .hbase.pb.TimedQuota req_size = 2;
  inline bool has_req_size() const;
  inline void clear_req_size();
  static const int kReqSizeFieldNumber = 2;
  inline const ::hbase::pb::TimedQuota& req_size() const;
  inline ::hbase::pb::TimedQuota* mutable_req_size();
  inline ::hbase::pb::TimedQuota* release_req_size();
  inline void set_allocated_req_size(::hbase::pb::TimedQuota* req_size);

  // optional .hbase.pb.TimedQuota write_num = 3;
  inline bool has_write_num() const;
  inline void clear_write_num();
  static const int kWriteNumFieldNumber = 3;
  inline const ::hbase::pb::TimedQuota& write_num() const;
  inline ::hbase::pb::TimedQuota* mutable_write_num();
  inline ::hbase::pb::TimedQuota* release_write_num();
  inline void set_allocated_write_num(::hbase::pb::TimedQuota* write_num);

  // optional .hbase.pb.TimedQuota write_size = 4;
  inline bool has_write_size() const;
  inline void clear_write_size();
  static const int kWriteSizeFieldNumber = 4;
  inline const ::hbase::pb::TimedQuota& write_size() const;
  inline ::hbase::pb::TimedQuota* mutable_write_size();
  inline ::hbase::pb::TimedQuota* release_write_size();
  inline void set_allocated_write_size(::hbase::pb::TimedQuota* write_size);

  // optional .hbase.pb.TimedQuota read_num = 5;
  inline bool has_read_num() const;
  inline void clear_read_num();
  static const int kReadNumFieldNumber = 5;
  inline const ::hbase::pb::TimedQuota& read_num() const;
  inline ::hbase::pb::TimedQuota* mutable_read_num();
  inline ::hbase::pb::TimedQuota* release_read_num();
  inline void set_allocated_read_num(::hbase::pb::TimedQuota* read_num);

  // optional .hbase.pb.TimedQuota read_size = 6;
  inline bool has_read_size() const;
  inline void clear_read_size();
  static const int kReadSizeFieldNumber = 6;
  inline const ::hbase::pb::TimedQuota& read_size() const;
  inline ::hbase::pb::TimedQuota* mutable_read_size();
  inline ::hbase::pb::TimedQuota* release_read_size();
  inline void set_allocated_read_size(::hbase::pb::TimedQuota* read_size);

  // @@protoc_insertion_point(class_scope:hbase.pb.Throttle)
 private:
  inline void set_has_req_num();
  inline void clear_has_req_num();
  inline void set_has_req_size();
  inline void clear_has_req_size();
  inline void set_has_write_num();
  inline void clear_has_write_num();
  inline void set_has_write_size();
  inline void clear_has_write_size();
  inline void set_has_read_num();
  inline void clear_has_read_num();
  inline void set_has_read_size();
  inline void clear_has_read_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TimedQuota* req_num_;
  ::hbase::pb::TimedQuota* req_size_;
  ::hbase::pb::TimedQuota* write_num_;
  ::hbase::pb::TimedQuota* write_size_;
  ::hbase::pb::TimedQuota* read_num_;
  ::hbase::pb::TimedQuota* read_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Quota_2eproto();
  friend void protobuf_AssignDesc_Quota_2eproto();
  friend void protobuf_ShutdownFile_Quota_2eproto();

  void InitAsDefaultInstance();
  static Throttle* default_instance_;
};
// -------------------------------------------------------------------

class ThrottleRequest : public ::google::protobuf::Message {
 public:
  ThrottleRequest();
  virtual ~ThrottleRequest();

  ThrottleRequest(const ThrottleRequest& from);

  inline ThrottleRequest& operator=(const ThrottleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThrottleRequest& default_instance();

  void Swap(ThrottleRequest* other);

  // implements Message ----------------------------------------------

  ThrottleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThrottleRequest& from);
  void MergeFrom(const ThrottleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hbase.pb.ThrottleType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::hbase::pb::ThrottleType type() const;
  inline void set_type(::hbase::pb::ThrottleType value);

  // optional .hbase.pb.TimedQuota timed_quota = 2;
  inline bool has_timed_quota() const;
  inline void clear_timed_quota();
  static const int kTimedQuotaFieldNumber = 2;
  inline const ::hbase::pb::TimedQuota& timed_quota() const;
  inline ::hbase::pb::TimedQuota* mutable_timed_quota();
  inline ::hbase::pb::TimedQuota* release_timed_quota();
  inline void set_allocated_timed_quota(::hbase::pb::TimedQuota* timed_quota);

  // @@protoc_insertion_point(class_scope:hbase.pb.ThrottleRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timed_quota();
  inline void clear_has_timed_quota();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::TimedQuota* timed_quota_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Quota_2eproto();
  friend void protobuf_AssignDesc_Quota_2eproto();
  friend void protobuf_ShutdownFile_Quota_2eproto();

  void InitAsDefaultInstance();
  static ThrottleRequest* default_instance_;
};
// -------------------------------------------------------------------

class Quotas : public ::google::protobuf::Message {
 public:
  Quotas();
  virtual ~Quotas();

  Quotas(const Quotas& from);

  inline Quotas& operator=(const Quotas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quotas& default_instance();

  void Swap(Quotas* other);

  // implements Message ----------------------------------------------

  Quotas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quotas& from);
  void MergeFrom(const Quotas& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bypass_globals = 1 [default = false];
  inline bool has_bypass_globals() const;
  inline void clear_bypass_globals();
  static const int kBypassGlobalsFieldNumber = 1;
  inline bool bypass_globals() const;
  inline void set_bypass_globals(bool value);

  // optional .hbase.pb.Throttle throttle = 2;
  inline bool has_throttle() const;
  inline void clear_throttle();
  static const int kThrottleFieldNumber = 2;
  inline const ::hbase::pb::Throttle& throttle() const;
  inline ::hbase::pb::Throttle* mutable_throttle();
  inline ::hbase::pb::Throttle* release_throttle();
  inline void set_allocated_throttle(::hbase::pb::Throttle* throttle);

  // @@protoc_insertion_point(class_scope:hbase.pb.Quotas)
 private:
  inline void set_has_bypass_globals();
  inline void clear_has_bypass_globals();
  inline void set_has_throttle();
  inline void clear_has_throttle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hbase::pb::Throttle* throttle_;
  bool bypass_globals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Quota_2eproto();
  friend void protobuf_AssignDesc_Quota_2eproto();
  friend void protobuf_ShutdownFile_Quota_2eproto();

  void InitAsDefaultInstance();
  static Quotas* default_instance_;
};
// -------------------------------------------------------------------

class QuotaUsage : public ::google::protobuf::Message {
 public:
  QuotaUsage();
  virtual ~QuotaUsage();

  QuotaUsage(const QuotaUsage& from);

  inline QuotaUsage& operator=(const QuotaUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuotaUsage& default_instance();

  void Swap(QuotaUsage* other);

  // implements Message ----------------------------------------------

  QuotaUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuotaUsage& from);
  void MergeFrom(const QuotaUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.QuotaUsage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Quota_2eproto();
  friend void protobuf_AssignDesc_Quota_2eproto();
  friend void protobuf_ShutdownFile_Quota_2eproto();

  void InitAsDefaultInstance();
  static QuotaUsage* default_instance_;
};
// ===================================================================


// ===================================================================

// TimedQuota

// required .hbase.pb.TimeUnit time_unit = 1;
inline bool TimedQuota::has_time_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimedQuota::set_has_time_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimedQuota::clear_has_time_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimedQuota::clear_time_unit() {
  time_unit_ = 1;
  clear_has_time_unit();
}
inline ::hbase::pb::TimeUnit TimedQuota::time_unit() const {
  return static_cast< ::hbase::pb::TimeUnit >(time_unit_);
}
inline void TimedQuota::set_time_unit(::hbase::pb::TimeUnit value) {
  assert(::hbase::pb::TimeUnit_IsValid(value));
  set_has_time_unit();
  time_unit_ = value;
}

// optional uint64 soft_limit = 2;
inline bool TimedQuota::has_soft_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimedQuota::set_has_soft_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimedQuota::clear_has_soft_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimedQuota::clear_soft_limit() {
  soft_limit_ = GOOGLE_ULONGLONG(0);
  clear_has_soft_limit();
}
inline ::google::protobuf::uint64 TimedQuota::soft_limit() const {
  return soft_limit_;
}
inline void TimedQuota::set_soft_limit(::google::protobuf::uint64 value) {
  set_has_soft_limit();
  soft_limit_ = value;
}

// optional float share = 3;
inline bool TimedQuota::has_share() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimedQuota::set_has_share() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimedQuota::clear_has_share() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimedQuota::clear_share() {
  share_ = 0;
  clear_has_share();
}
inline float TimedQuota::share() const {
  return share_;
}
inline void TimedQuota::set_share(float value) {
  set_has_share();
  share_ = value;
}

// optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
inline bool TimedQuota::has_scope() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimedQuota::set_has_scope() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimedQuota::clear_has_scope() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimedQuota::clear_scope() {
  scope_ = 2;
  clear_has_scope();
}
inline ::hbase::pb::QuotaScope TimedQuota::scope() const {
  return static_cast< ::hbase::pb::QuotaScope >(scope_);
}
inline void TimedQuota::set_scope(::hbase::pb::QuotaScope value) {
  assert(::hbase::pb::QuotaScope_IsValid(value));
  set_has_scope();
  scope_ = value;
}

// -------------------------------------------------------------------

// Throttle

// optional .hbase.pb.TimedQuota req_num = 1;
inline bool Throttle::has_req_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Throttle::set_has_req_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Throttle::clear_has_req_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Throttle::clear_req_num() {
  if (req_num_ != NULL) req_num_->::hbase::pb::TimedQuota::Clear();
  clear_has_req_num();
}
inline const ::hbase::pb::TimedQuota& Throttle::req_num() const {
  return req_num_ != NULL ? *req_num_ : *default_instance_->req_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_req_num() {
  set_has_req_num();
  if (req_num_ == NULL) req_num_ = new ::hbase::pb::TimedQuota;
  return req_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_req_num() {
  clear_has_req_num();
  ::hbase::pb::TimedQuota* temp = req_num_;
  req_num_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_req_num(::hbase::pb::TimedQuota* req_num) {
  delete req_num_;
  req_num_ = req_num;
  if (req_num) {
    set_has_req_num();
  } else {
    clear_has_req_num();
  }
}

// optional .hbase.pb.TimedQuota req_size = 2;
inline bool Throttle::has_req_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Throttle::set_has_req_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Throttle::clear_has_req_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Throttle::clear_req_size() {
  if (req_size_ != NULL) req_size_->::hbase::pb::TimedQuota::Clear();
  clear_has_req_size();
}
inline const ::hbase::pb::TimedQuota& Throttle::req_size() const {
  return req_size_ != NULL ? *req_size_ : *default_instance_->req_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_req_size() {
  set_has_req_size();
  if (req_size_ == NULL) req_size_ = new ::hbase::pb::TimedQuota;
  return req_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_req_size() {
  clear_has_req_size();
  ::hbase::pb::TimedQuota* temp = req_size_;
  req_size_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_req_size(::hbase::pb::TimedQuota* req_size) {
  delete req_size_;
  req_size_ = req_size;
  if (req_size) {
    set_has_req_size();
  } else {
    clear_has_req_size();
  }
}

// optional .hbase.pb.TimedQuota write_num = 3;
inline bool Throttle::has_write_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Throttle::set_has_write_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Throttle::clear_has_write_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Throttle::clear_write_num() {
  if (write_num_ != NULL) write_num_->::hbase::pb::TimedQuota::Clear();
  clear_has_write_num();
}
inline const ::hbase::pb::TimedQuota& Throttle::write_num() const {
  return write_num_ != NULL ? *write_num_ : *default_instance_->write_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_write_num() {
  set_has_write_num();
  if (write_num_ == NULL) write_num_ = new ::hbase::pb::TimedQuota;
  return write_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_write_num() {
  clear_has_write_num();
  ::hbase::pb::TimedQuota* temp = write_num_;
  write_num_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_write_num(::hbase::pb::TimedQuota* write_num) {
  delete write_num_;
  write_num_ = write_num;
  if (write_num) {
    set_has_write_num();
  } else {
    clear_has_write_num();
  }
}

// optional .hbase.pb.TimedQuota write_size = 4;
inline bool Throttle::has_write_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Throttle::set_has_write_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Throttle::clear_has_write_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Throttle::clear_write_size() {
  if (write_size_ != NULL) write_size_->::hbase::pb::TimedQuota::Clear();
  clear_has_write_size();
}
inline const ::hbase::pb::TimedQuota& Throttle::write_size() const {
  return write_size_ != NULL ? *write_size_ : *default_instance_->write_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_write_size() {
  set_has_write_size();
  if (write_size_ == NULL) write_size_ = new ::hbase::pb::TimedQuota;
  return write_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_write_size() {
  clear_has_write_size();
  ::hbase::pb::TimedQuota* temp = write_size_;
  write_size_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_write_size(::hbase::pb::TimedQuota* write_size) {
  delete write_size_;
  write_size_ = write_size;
  if (write_size) {
    set_has_write_size();
  } else {
    clear_has_write_size();
  }
}

// optional .hbase.pb.TimedQuota read_num = 5;
inline bool Throttle::has_read_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Throttle::set_has_read_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Throttle::clear_has_read_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Throttle::clear_read_num() {
  if (read_num_ != NULL) read_num_->::hbase::pb::TimedQuota::Clear();
  clear_has_read_num();
}
inline const ::hbase::pb::TimedQuota& Throttle::read_num() const {
  return read_num_ != NULL ? *read_num_ : *default_instance_->read_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_read_num() {
  set_has_read_num();
  if (read_num_ == NULL) read_num_ = new ::hbase::pb::TimedQuota;
  return read_num_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_read_num() {
  clear_has_read_num();
  ::hbase::pb::TimedQuota* temp = read_num_;
  read_num_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_read_num(::hbase::pb::TimedQuota* read_num) {
  delete read_num_;
  read_num_ = read_num;
  if (read_num) {
    set_has_read_num();
  } else {
    clear_has_read_num();
  }
}

// optional .hbase.pb.TimedQuota read_size = 6;
inline bool Throttle::has_read_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Throttle::set_has_read_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Throttle::clear_has_read_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Throttle::clear_read_size() {
  if (read_size_ != NULL) read_size_->::hbase::pb::TimedQuota::Clear();
  clear_has_read_size();
}
inline const ::hbase::pb::TimedQuota& Throttle::read_size() const {
  return read_size_ != NULL ? *read_size_ : *default_instance_->read_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_read_size() {
  set_has_read_size();
  if (read_size_ == NULL) read_size_ = new ::hbase::pb::TimedQuota;
  return read_size_;
}
inline ::hbase::pb::TimedQuota* Throttle::release_read_size() {
  clear_has_read_size();
  ::hbase::pb::TimedQuota* temp = read_size_;
  read_size_ = NULL;
  return temp;
}
inline void Throttle::set_allocated_read_size(::hbase::pb::TimedQuota* read_size) {
  delete read_size_;
  read_size_ = read_size;
  if (read_size) {
    set_has_read_size();
  } else {
    clear_has_read_size();
  }
}

// -------------------------------------------------------------------

// ThrottleRequest

// optional .hbase.pb.ThrottleType type = 1;
inline bool ThrottleRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThrottleRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThrottleRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThrottleRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hbase::pb::ThrottleType ThrottleRequest::type() const {
  return static_cast< ::hbase::pb::ThrottleType >(type_);
}
inline void ThrottleRequest::set_type(::hbase::pb::ThrottleType value) {
  assert(::hbase::pb::ThrottleType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .hbase.pb.TimedQuota timed_quota = 2;
inline bool ThrottleRequest::has_timed_quota() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThrottleRequest::set_has_timed_quota() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThrottleRequest::clear_has_timed_quota() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThrottleRequest::clear_timed_quota() {
  if (timed_quota_ != NULL) timed_quota_->::hbase::pb::TimedQuota::Clear();
  clear_has_timed_quota();
}
inline const ::hbase::pb::TimedQuota& ThrottleRequest::timed_quota() const {
  return timed_quota_ != NULL ? *timed_quota_ : *default_instance_->timed_quota_;
}
inline ::hbase::pb::TimedQuota* ThrottleRequest::mutable_timed_quota() {
  set_has_timed_quota();
  if (timed_quota_ == NULL) timed_quota_ = new ::hbase::pb::TimedQuota;
  return timed_quota_;
}
inline ::hbase::pb::TimedQuota* ThrottleRequest::release_timed_quota() {
  clear_has_timed_quota();
  ::hbase::pb::TimedQuota* temp = timed_quota_;
  timed_quota_ = NULL;
  return temp;
}
inline void ThrottleRequest::set_allocated_timed_quota(::hbase::pb::TimedQuota* timed_quota) {
  delete timed_quota_;
  timed_quota_ = timed_quota;
  if (timed_quota) {
    set_has_timed_quota();
  } else {
    clear_has_timed_quota();
  }
}

// -------------------------------------------------------------------

// Quotas

// optional bool bypass_globals = 1 [default = false];
inline bool Quotas::has_bypass_globals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quotas::set_has_bypass_globals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quotas::clear_has_bypass_globals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quotas::clear_bypass_globals() {
  bypass_globals_ = false;
  clear_has_bypass_globals();
}
inline bool Quotas::bypass_globals() const {
  return bypass_globals_;
}
inline void Quotas::set_bypass_globals(bool value) {
  set_has_bypass_globals();
  bypass_globals_ = value;
}

// optional .hbase.pb.Throttle throttle = 2;
inline bool Quotas::has_throttle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quotas::set_has_throttle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quotas::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quotas::clear_throttle() {
  if (throttle_ != NULL) throttle_->::hbase::pb::Throttle::Clear();
  clear_has_throttle();
}
inline const ::hbase::pb::Throttle& Quotas::throttle() const {
  return throttle_ != NULL ? *throttle_ : *default_instance_->throttle_;
}
inline ::hbase::pb::Throttle* Quotas::mutable_throttle() {
  set_has_throttle();
  if (throttle_ == NULL) throttle_ = new ::hbase::pb::Throttle;
  return throttle_;
}
inline ::hbase::pb::Throttle* Quotas::release_throttle() {
  clear_has_throttle();
  ::hbase::pb::Throttle* temp = throttle_;
  throttle_ = NULL;
  return temp;
}
inline void Quotas::set_allocated_throttle(::hbase::pb::Throttle* throttle) {
  delete throttle_;
  throttle_ = throttle;
  if (throttle) {
    set_has_throttle();
  } else {
    clear_has_throttle();
  }
}

// -------------------------------------------------------------------

// QuotaUsage


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::QuotaScope>() {
  return ::hbase::pb::QuotaScope_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ThrottleType>() {
  return ::hbase::pb::ThrottleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::QuotaType>() {
  return ::hbase::pb::QuotaType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Quota_2eproto__INCLUDED
